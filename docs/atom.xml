<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns='http://www.w3.org/2005/Atom' xmlns:g='http://base.google.com/ns/1.0'>
  <title>Reasonably Polymorphic</title>
  <updated>2022-03-22T11:16:00Z</updated>
  <author><name>Sandy Maguire</name></author>
  <id>https://reasonablypolymorphic.com</id>
  <link rel='self' href='https://reasonablypolymorphic.com/atom.xml'/>

    <entry>
      <title>Review: Proof-Carrying Code</title>
      <id>blog/proof-carrying-code/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/proof-carrying-code/index.html'/>
      <published>2022-03-22</published>
      <updated>2022-03-22</updated>

      <content type="html">
        <![CDATA[
        <!--
<pre class="Agda"><a id="146" class="Keyword">module</a> <a id="153" href="blog.proof-carrying-code.html" class="Module">blog.proof-carrying-code</a> <a id="178" class="Keyword">where</a>

<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="206" class="Keyword">open</a> <a id="211" class="Keyword">import</a> <a id="218" href="Data.Vec.html" class="Module">Data.Vec</a>
<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="Data.Fin.html" class="Module">Data.Fin</a>
</pre>-->
<p>A few months ago, the excellent <a href="https://davidrusu.github.io/">David Rusu</a> gave me an impromptu lecture on <a href="https://en.wikipedia.org/wiki/Ring_signature">ring signatures</a>, which are a way of signing something as an anonymous member of a group. That is, you can show someone in the signing pool was actually responsible for signing the thing, but can’t determine <em>which member of the pool actually signed it.</em> David walked me through all the math as to how that actually happens, but I was unable to follow it, because the math was hard and, perhaps more importantly, it felt like hand-compiling a proof.</p>
<p>What do I mean by “hand-compiling” a proof? Well, we have some mathematical object, something like</p>
<pre class="Agda"><a id="1003" class="Keyword">postulate</a>
  <a id="Identity"></a><a id="1015" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1024" class="Symbol">:</a> <a id="1026" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="Message"></a><a id="1032" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="1040" class="Symbol">:</a> <a id="1042" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="SignedBy"></a><a id="1048" href="blog/proof-carrying-code/index.html#1048" class="Postulate">SignedBy</a> <a id="1057" class="Symbol">:</a> <a id="1059" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="1067" class="Symbol">→</a> <a id="1069" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1078" class="Symbol">→</a> <a id="1080" href="Agda.Primitive.html#326" class="Primitive">Set</a>

  <a id="use-your-imagination"></a><a id="1087" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a> <a id="1108" class="Symbol">:</a> <a id="1110" class="Symbol">{</a><a id="1111" href="blog/proof-carrying-code/index.html#1111" class="Bound">A</a> <a id="1113" class="Symbol">:</a> <a id="1115" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1118" class="Symbol">}</a> <a id="1120" class="Symbol">→</a> <a id="1122" href="blog/proof-carrying-code/index.html#1111" class="Bound">A</a>

<a id="1125" class="Keyword">record</a> <a id="SignedMessage"></a><a id="1132" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="1146" class="Symbol">{</a><a id="1147" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a> <a id="1149" class="Symbol">:</a> <a id="1151" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1152" class="Symbol">}</a> <a id="1154" class="Symbol">(</a><a id="1155" href="blog/proof-carrying-code/index.html#1155" class="Bound">pool</a> <a id="1160" class="Symbol">:</a> <a id="1162" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="1166" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1175" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a><a id="1176" class="Symbol">)</a> <a id="1178" class="Symbol">:</a> <a id="1180" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1184" class="Keyword">where</a>
  <a id="1192" class="Keyword">field</a>
    <a id="SignedMessage.message"></a><a id="1202" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a> <a id="1210" class="Symbol">:</a> <a id="1212" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a>
    <a id="1224" class="Symbol">@</a><a id="1225" class="Symbol">erased</a>
      <a id="SignedMessage.signer"></a><a id="1238" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a> <a id="1245" class="Symbol">:</a> <a id="1247" href="Data.Fin.Base.html#1126" class="Datatype">Fin</a> <a id="1251" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a>
    <a id="SignedMessage.signature"></a><a id="1257" href="blog/proof-carrying-code/index.html#1257" class="Field">signature</a> <a id="1267" class="Symbol">:</a> <a id="1269" href="blog/proof-carrying-code/index.html#1048" class="Postulate">SignedBy</a> <a id="1278" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a> <a id="1286" class="Symbol">(</a><a id="1287" href="Data.Vec.Base.html#1605" class="Function">lookup</a> <a id="1294" href="blog/proof-carrying-code/index.html#1155" class="Bound">pool</a> <a id="1299" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a><a id="1305" class="Symbol">)</a>
</pre>
<p>where <code>@erased</code> is Agda’s <a href="https://agda.readthedocs.io/en/v2.6.2.1/language/runtime-irrelevance.html#runtime-irrelevance">runtime irrelevance</a> annotation, meaning the <span class="Agda"><a href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a></span> field won’t exist at runtime. In fact, attempting to write a function that would extract it results in the following error:</p>
<blockquote>
<p>Identifier <code>signer</code> is declared erased, so it cannot be used here<br />
when checking that the expression <code>signer x</code> has type <code>Fin n</code></p>
</blockquote>
<p>Nice one Agda!</p>
<p>Hand-compiling this thing is thus constructing some object that has the desired properties, but doing it in a way that requires BEING VERY SMART, and throwing away any chance at composability in the process. For example, it’d be nice to have the following:</p>
<pre class="Agda"><a id="2045" class="Keyword">open</a> <a id="2050" href="blog/proof-carrying-code/index.html#1132" class="Module">SignedMessage</a>

<a id="weakenL"></a><a id="2065" href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a> <a id="2073" class="Symbol">:</a> <a id="2075" class="Symbol">∀</a> <a id="2077" class="Symbol">{</a><a id="2078" href="blog/proof-carrying-code/index.html#2078" class="Bound">n</a> <a id="2080" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a> <a id="2085" href="blog/proof-carrying-code/index.html#2085" class="Bound">new-id</a><a id="2091" class="Symbol">}</a>
        <a id="2101" class="Symbol">→</a> <a id="2103" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2117" class="Symbol">{</a><a id="2118" href="blog/proof-carrying-code/index.html#2078" class="Bound">n</a><a id="2119" class="Symbol">}</a> <a id="2121" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a>
        <a id="2134" class="Symbol">→</a> <a id="2136" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2150" class="Symbol">(</a><a id="2151" href="blog/proof-carrying-code/index.html#2085" class="Bound">new-id</a> <a id="2158" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="2160" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a><a id="2164" class="Symbol">)</a>
<a id="2166" href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a> <a id="2174" href="blog/proof-carrying-code/index.html#2174" class="Bound">x</a> <a id="2176" class="Symbol">=</a> <a id="2178" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>

<a id="weakenR"></a><a id="2200" href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a> <a id="2208" class="Symbol">:</a> <a id="2210" class="Symbol">∀</a> <a id="2212" class="Symbol">{</a><a id="2213" href="blog/proof-carrying-code/index.html#2213" class="Bound">n</a> <a id="2215" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a> <a id="2220" href="blog/proof-carrying-code/index.html#2220" class="Bound">new-id</a><a id="2226" class="Symbol">}</a>
        <a id="2236" class="Symbol">→</a> <a id="2238" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2252" class="Symbol">{</a><a id="2253" href="blog/proof-carrying-code/index.html#2213" class="Bound">n</a><a id="2254" class="Symbol">}</a> <a id="2256" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a>
        <a id="2269" class="Symbol">→</a> <a id="2271" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2285" class="Symbol">(</a><a id="2286" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a> <a id="2291" href="Data.Vec.Base.html#2709" class="Function Operator">++</a> <a id="2294" href="Data.Vec.Base.html#5750" class="Function Operator">[</a> <a id="2296" href="blog/proof-carrying-code/index.html#2220" class="Bound">new-id</a> <a id="2303" href="Data.Vec.Base.html#5750" class="Function Operator">]</a><a id="2304" class="Symbol">)</a>
<a id="2306" href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a> <a id="2314" href="blog/proof-carrying-code/index.html#2314" class="Bound">x</a> <a id="2316" class="Symbol">=</a> <a id="2318" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>
</pre>
<p>which would allow us to arbitrarily extend the pool of a signed message. Then, we could trivially construct one:</p>
<pre class="Agda"><a id="sign"></a><a id="2462" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2467" class="Symbol">:</a> <a id="2469" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="2477" class="Symbol">→</a> <a id="2479" class="Symbol">(</a><a id="2480" href="blog/proof-carrying-code/index.html#2480" class="Bound">who</a> <a id="2484" class="Symbol">:</a> <a id="2486" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a><a id="2494" class="Symbol">)</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2512" href="Data.Vec.Base.html#5750" class="Function Operator">[</a> <a id="2514" href="blog/proof-carrying-code/index.html#2480" class="Bound">who</a> <a id="2518" href="Data.Vec.Base.html#5750" class="Function Operator">]</a>
<a id="2520" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a>   <a id="2530" class="Symbol">(</a><a id="2531" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2536" href="blog/proof-carrying-code/index.html#2536" class="Bound">msg</a> <a id="2540" href="blog/proof-carrying-code/index.html#2540" class="Bound">who</a><a id="2543" class="Symbol">)</a> <a id="2545" class="Symbol">=</a> <a id="2547" href="blog/proof-carrying-code/index.html#2536" class="Bound">msg</a>
<a id="2551" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a>    <a id="2561" class="Symbol">(</a><a id="2562" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2567" href="blog/proof-carrying-code/index.html#2567" class="Bound">msg</a> <a id="2571" href="blog/proof-carrying-code/index.html#2571" class="Bound">who</a><a id="2574" class="Symbol">)</a> <a id="2576" class="Symbol">=</a> <a id="2578" href="Data.Fin.Base.html#1148" class="InductiveConstructor">zero</a>
<a id="2583" href="blog/proof-carrying-code/index.html#1257" class="Field">signature</a> <a id="2593" class="Symbol">(</a><a id="2594" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2599" href="blog/proof-carrying-code/index.html#2599" class="Bound">msg</a> <a id="2603" href="blog/proof-carrying-code/index.html#2603" class="Bound">who</a><a id="2606" class="Symbol">)</a> <a id="2608" class="Symbol">=</a> <a id="2610" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>
</pre>
<p>and then obfuscate who signed by some random choice of subsequent <span class="Agda"><a href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a></span>s and <span class="Agda"><a href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a></span>s.</p>
<p>Unfortunately, this is not the case with ring signatures. Ring signatures require you to “bake in” the signing pool when you construct your signature, and you can never again change that pool, short of doing all the work again. This behavior is non-composable, and thus, in my reckoning, unlikely to be a true solution to the problem.</p>
<p>The paper I chose to review this week is <a href="https://www.cs.jhu.edu/~fabian/courses/CS600.624/proof-carrying-code.pdf">Proof-Carrying Code</a> by George Necula, in an attempt to understand if the PL literature has anything to say about this problem.</p>
<p>PCC is an old paper (from 1997, egads!) but it was the first thing I found on the subject. I should really get better at vetting my literature before I go through the effort of going through it, but hey, what are you going to do?</p>
<p>The idea behind PCC is that we want to execute some untrusted machine code. But we don’t want to sacrifice our system security to do it. And we don’t want to evaluate some safe language into machine code, because that would be too slow. Instead, we’ll send the machine code, as well as a safety proof that verifies it’s safe to execute this code. The safety proof is tied to the machine code, such that you can’t just generate a safety proof for an unrelated problem, and then attach it to some malicious code. But the safety proof isn’t obfuscated or anything; the claim is that if you can construct a safety proof for a given program, that program is necessarily safe to run.</p>
<p>On the runtime side, there is a simple algorithm for checking the safety proof, and it is independent of the arguments that the program is run with; therefore, we can get away with checking code once and evaluating it many times. It’s important that the algorithm be simple, because it’s a necessarily trusted piece of code, and it would be bad news if it were to have bugs.</p>
<p>PCC’s approach is a bit… unimaginative. For every opcode we’d like to allow in the programs, we attach a safety precondition, and a postcondition. Then, we map the vector of opcodes we’d like to run into its pre/post conditions, and make sure they are confluent. If they are, we’re good to go. This vector of conditions is called the vector VC in the paper.</p>
<p>So, the compiler computes the VC and attaches it to the code. Think of the VC as a proposition of safety (that is, a type), and a proof of that proposition (the VC itself.) In order to validate this, the runtime does a safety typecheck, figuring out what the proposition of safety would have to be. It compares this against the attached proof, and if they match, it typechecks the VC to ensure it has the type it says. If it does, our code is safe.</p>
<p>The PCC paper is a bit light on details here, so it’s worth thinking about exactly what’s going on here. Presumably determining the safety preconditions is an easy problem if we can do it at runtime, but proving some code satisfies it is hard, <em>or else we could just do that at runtime too.</em></p>
<p>I’m a bit hesitant to dive into the details here, because I don’t really care about determining whether some blob of machine code is safe to run. It’s a big ball of poorly typed typing judgments about memory usage. Why do I say poorly typed? Well consider one of the rules from the paper:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>m</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi><mtext>list</mtext><mspace width="1em"></mspace><mspace width="1em"></mspace><mi>e</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><mrow><mi>m</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mtext>addr</mtext><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{m \vdash e : \tau \text{list} \quad \quad e \neq 0}
     {m \vdash e : \text{addr} ...}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">addr</span></span><span class="mord">...</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mord text"><span class="mord">list</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Here we have that from <code>e : List τ</code> (and that <code>e</code> isn’t 0) we can derive <code>e : addr</code>. At best, if we are charitable in assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">e \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> means that <code>e</code> isn’t <code>nil</code>, there is a type preservation error here. If we are less charitable, there is also some awful type error here involving 0, which might be a null check or something? This seems sufficiently messy that I don’t care enough to decipher it.</p>
<p>How applicable is any of this to our original question around ring signatures? Not very, I think, unfortunately. We already have the ring signature math if we’d like to encode a proof, and the verification of it is easy enough. But it’s still not very composable, and I doubt this paper will add much there. Some more promising approaches would be to draw the mystery commutative diagrams ala <a href="/blog/adders-and-arrows">Adders and Arrows</a>, starting from a specification and deriving a chain of proofs that the eventual implementation satisfies the specification. The value there is in all the intermediary nodes of the commutative diagram, and whether we can prove weakening lemmas there.</p>
<p>But PCC isn’t entirely a loss; I learned about <code>@empty</code> in Agda.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Syntax-Guided Synthesis</title>
      <id>blog/syntax-guided-synthesis/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/syntax-guided-synthesis/index.html'/>
      <published>2022-03-19</published>
      <updated>2022-03-19</updated>

      <content type="html">
        <![CDATA[
        <!--
<pre class="Agda"><a id="153" class="Keyword">module</a> <a id="160" href="blog.syntax-guided-synthesis.html" class="Module">blog.syntax-guided-synthesis</a> <a id="189" class="Keyword">where</a>

<a id="196" class="Keyword">open</a> <a id="201" class="Keyword">import</a> <a id="208" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="249" class="Keyword">open</a> <a id="254" class="Keyword">import</a> <a id="261" href="Data.Product.html" class="Module">Data.Product</a>
<a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="345" class="Keyword">open</a> <a id="350" class="Keyword">import</a> <a id="357" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="374" class="Keyword">using</a> <a id="380" class="Symbol">(</a><a id="381" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="384" class="Symbol">;</a> <a id="386" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="389" class="Symbol">;</a> <a id="391" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="393" class="Symbol">;</a> <a id="395" href="Relation.Nullary.html#1559" class="InductiveConstructor Operator">_because_</a><a id="404" class="Symbol">;</a> <a id="406" href="Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="408" class="Symbol">;</a> <a id="410" href="Relation.Nullary.html#902" class="InductiveConstructor">ofʸ</a><a id="413" class="Symbol">;</a> <a id="415" href="Relation.Nullary.html#939" class="InductiveConstructor">ofⁿ</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="442" class="Keyword">hiding</a> <a id="449" class="Symbol">(</a><a id="450" href="Data.Bool.Properties.html#1126" class="Function Operator">_≟_</a><a id="453" class="Symbol">;</a> <a id="455" href="Data.Bool.Base.html#672" class="Datatype Operator">_≤_</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Bool.Properties.html#1964" class="Function Operator">_≤?_</a><a id="464" class="Symbol">)</a>
<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.html" class="Module">Data.List</a> <a id="526" class="Keyword">hiding</a> <a id="533" class="Symbol">(</a><a id="534" href="Data.List.Base.html#4588" class="Function">and</a><a id="537" class="Symbol">;</a> <a id="539" href="Data.List.Base.html#5025" class="Function Operator">[_]</a><a id="542" class="Symbol">)</a>
<a id="544" class="Keyword">open</a> <a id="549" class="Keyword">import</a> <a id="556" href="Function.html" class="Module">Function</a> <a id="565" class="Keyword">hiding</a> <a id="572" class="Symbol">(</a><a id="573" href="Function.Base.html#636" class="Function">const</a><a id="578" class="Symbol">)</a>
<a id="580" class="Keyword">open</a> <a id="585" class="Keyword">import</a> <a id="592" href="Data.Maybe.html" class="Module">Data.Maybe</a>
</pre>-->
<p>I was describing my idea from <a href="/blog/generic-parallel-fp">last week</a> to <a href="/blog/generic-parallel-fp/#future-work">automatically optimize programs</a> to Colin, who pointed me towards <a href="https://sygus.org/assets/pdf/Journal_SyGuS.pdf">Syntax-Guided Synthesis</a> by Alur et al.</p>
<p>Syntax-Guided Synthesis is the idea that free-range program synthesis is really hard, so instead, let’s constrain the search space with a grammar of allowable programs. We can then enumerate those possible programs, attempting to find one that satisfies some constraints. The idea is quite straightforward when you see it, but that’s not to say it’s unimpressive; the paper has lots of quantitative results about exactly how well this approach does.</p>
<p>The idea is we want to find programs with type <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a></span> <code>→</code> <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a></span>, that satisfy some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>ification. We’ll do that by picking some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage of syntax, and trying to build our programs there.</p>
<p>All of this is sorta moot, because we assume we have some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> which can tell us if our program satisfies the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. But the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is probably some SMT solver, and is thus expensive to call, so we’d like to try hard not to call it if possible.</p>
<p>Let’s take an example, and say that we’d like to synthesize the <code>max</code> of two <code class="sourceCode agda">Nat</code>s. There are lots of ways of doing that! But we’d like to find a function that satisfies the following:</p>
<pre class="Agda"><a id="2068" class="Keyword">data</a> <a id="MaxSpec"></a><a id="2073" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2081" class="Symbol">(</a><a id="2082" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2084" class="Symbol">:</a> <a id="2086" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2088" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2090" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2092" class="Symbol">→</a> <a id="2094" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2095" class="Symbol">)</a> <a id="2097" class="Symbol">:</a> <a id="2099" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2101" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2103" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2105" class="Symbol">→</a> <a id="2107" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2111" class="Keyword">where</a>
  <a id="MaxSpec.is-max"></a><a id="2119" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">{</a><a id="2129" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2131" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2133" class="Symbol">:</a> <a id="2135" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2136" class="Symbol">}</a>
         <a id="2147" class="Symbol">→</a> <a id="2149" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2151" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="2153" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2155" class="Symbol">(</a><a id="2156" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2158" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2160" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2161" class="Symbol">)</a>
         <a id="2172" class="Symbol">→</a> <a id="2174" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2176" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="2178" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2180" class="Symbol">(</a><a id="2181" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2183" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2185" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2186" class="Symbol">)</a>
         <a id="2197" class="Symbol">→</a> <a id="2199" class="Symbol">((</a><a id="2201" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2203" class="Symbol">(</a><a id="2204" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2206" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2208" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2209" class="Symbol">)</a> <a id="2211" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2213" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a><a id="2214" class="Symbol">)</a> <a id="2216" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="2218" class="Symbol">(</a><a id="2219" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2221" class="Symbol">(</a><a id="2222" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2224" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2226" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2227" class="Symbol">)</a> <a id="2229" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2231" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2232" class="Symbol">))</a>
         <a id="2244" class="Symbol">→</a> <a id="2246" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2254" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2256" class="Symbol">(</a><a id="2257" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2259" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2261" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2262" class="Symbol">)</a>
</pre>
<p>If we can successfully produce an element of <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code>, we have a proof that <code>f</code> is an implementation of <code>max</code>. Of course, actually producing such a thing is rather tricky; it’s equivalent to determining if <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code> is <span class="Agda"><a href="Relation.Nullary.html#1511" class="Record">Dec</a></span>idable for the given input.</p>
<p>In the first three cases, we have some conflicting piece of information, so we are unable to produce a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>:</p>
<pre class="Agda"><a id="decideMax"></a><a id="2679" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2689" class="Symbol">:</a> <a id="2691" class="Symbol">(</a><a id="2692" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2694" class="Symbol">:</a> <a id="2696" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2698" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2700" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2702" class="Symbol">→</a> <a id="2704" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2705" class="Symbol">)</a> <a id="2707" class="Symbol">→</a> <a id="2709" class="Symbol">(</a><a id="2710" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a> <a id="2712" class="Symbol">:</a> <a id="2714" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2716" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2718" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2719" class="Symbol">)</a> <a id="2721" class="Symbol">→</a> <a id="2723" href="Relation.Nullary.html#1511" class="Record">Dec</a> <a id="2727" class="Symbol">(</a><a id="2728" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2736" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2738" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a><a id="2739" class="Symbol">)</a>
<a id="2741" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2751" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2753" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a><a id="2754" class="Symbol">@(</a><a id="2756" href="blog/syntax-guided-synthesis/index.html#2756" class="Bound">x</a> <a id="2758" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2760" href="blog/syntax-guided-synthesis/index.html#2760" class="Bound">y</a><a id="2761" class="Symbol">)</a> <a id="2763" class="Keyword">with</a> <a id="2768" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2770" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a> <a id="2772" class="Symbol">|</a> <a id="2774" href="Relation.Binary.PropositionalEquality.html#2382" class="Function">inspect</a> <a id="2782" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2784" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a>
<a id="2786" class="Symbol">...</a> <a id="2790" class="Symbol">|</a> <a id="2792" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2794" class="Symbol">|</a> <a id="2796" href="Relation.Binary.PropositionalEquality.html#2356" class="InductiveConstructor Operator">[</a> <a id="2798" href="blog/syntax-guided-synthesis/index.html#2798" class="Bound">fi≡o</a> <a id="2803" href="Relation.Binary.PropositionalEquality.html#2356" class="InductiveConstructor Operator">]</a> <a id="2805" class="Keyword">with</a> <a id="2810" class="Bound">x</a> <a id="2812" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="2815" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2817" class="Symbol">|</a> <a id="2819" class="Bound">y</a> <a id="2821" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="2824" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a>
<a id="2826" class="Symbol">...</a> <a id="2830" class="Symbol">|</a> <a id="2832" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2835" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2840" class="Symbol">|</a> <a id="2842" class="Symbol">_</a> <a id="2844" class="Symbol">=</a> <a id="2846" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2849" class="Symbol">λ</a> <a id="2851" class="Symbol">{</a> <a id="2853" class="Symbol">(</a><a id="2854" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2861" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2865" class="Symbol">_</a> <a id="2867" class="Symbol">_)</a> <a id="2870" class="Symbol">→</a>
        <a id="2880" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="2894" class="Symbol">(</a><a id="2895" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="2903" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2907" class="Symbol">(</a><a id="2908" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="2920" class="Bound">fi≡o</a><a id="2924" class="Symbol">))</a> <a id="2927" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2932" class="Symbol">}</a>
<a id="2934" class="Symbol">...</a> <a id="2938" class="Symbol">|</a> <a id="2940" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="2944" class="Symbol">_</a> <a id="2946" class="Symbol">|</a> <a id="2948" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2951" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="2956" class="Symbol">=</a> <a id="2958" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2961" class="Symbol">λ</a> <a id="2963" class="Symbol">{</a> <a id="2965" class="Symbol">(</a><a id="2966" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2973" href="blog/syntax-guided-synthesis/index.html#2973" class="Bound">x</a> <a id="2975" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="2979" href="blog/syntax-guided-synthesis/index.html#2979" class="Bound">x₂</a><a id="2981" class="Symbol">)</a> <a id="2983" class="Symbol">→</a>
        <a id="2993" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3007" class="Symbol">(</a><a id="3008" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3016" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="3020" class="Symbol">(</a><a id="3021" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3033" class="Bound">fi≡o</a><a id="3037" class="Symbol">))</a> <a id="3040" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="3045" class="Symbol">}</a>
<a id="3047" class="Symbol">...</a> <a id="3051" class="Symbol">|</a> <a id="3053" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3057" href="blog/syntax-guided-synthesis/index.html#3057" class="Bound">x≤o</a> <a id="3061" class="Symbol">|</a> <a id="3063" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3067" href="blog/syntax-guided-synthesis/index.html#3067" class="Bound">y≤o</a> <a id="3071" class="Keyword">with</a> <a id="3076" class="Bound">o</a> <a id="3078" href="Data.Nat.Properties.html#2529" class="Function Operator">≟</a> <a id="3080" class="Bound">x</a> <a id="3082" class="Symbol">|</a> <a id="3084" class="Bound">o</a> <a id="3086" href="Data.Nat.Properties.html#2529" class="Function Operator">≟</a> <a id="3088" class="Bound">y</a>
<a id="3090" class="Symbol">...</a> <a id="3094" class="Symbol">|</a> <a id="3096" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3099" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a> <a id="3103" class="Symbol">|</a> <a id="3105" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3108" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a> <a id="3112" class="Symbol">=</a>
        <a id="3122" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3125" class="Symbol">λ</a> <a id="3127" class="Symbol">{</a> <a id="3129" class="Symbol">(</a><a id="3130" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3137" href="blog/syntax-guided-synthesis/index.html#3137" class="Bound">x</a> <a id="3139" href="blog/syntax-guided-synthesis/index.html#3139" class="Bound">x₁</a> <a id="3142" class="Symbol">(</a><a id="3143" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="3148" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3150" class="Symbol">))</a> <a id="3153" class="Symbol">→</a>
                  <a id="3173" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3187" class="Symbol">(</a><a id="3188" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3194" class="Symbol">(</a><a id="3195" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3199" class="Bound">fi≡o</a><a id="3203" class="Symbol">)</a> <a id="3205" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3207" class="Symbol">)</a> <a id="3209" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a>
             <a id="3226" class="Symbol">;</a> <a id="3228" class="Symbol">(</a><a id="3229" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3236" href="blog/syntax-guided-synthesis/index.html#3236" class="Bound">x</a> <a id="3238" href="blog/syntax-guided-synthesis/index.html#3238" class="Bound">x₁</a> <a id="3241" class="Symbol">(</a><a id="3242" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="3247" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3248" class="Symbol">))</a> <a id="3251" class="Symbol">→</a>
                  <a id="3271" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3292" class="Symbol">(</a><a id="3293" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3297" class="Bound">fi≡o</a><a id="3301" class="Symbol">)</a> <a id="3303" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3304" class="Symbol">)</a> <a id="3306" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a>
             <a id="3323" class="Symbol">}</a>
</pre>
<p>Otherwise, we have a proof that <code>o</code> is equal to either <code>y</code> or <code>x</code>:</p>
<pre class="Agda"><a id="3402" class="Symbol">...</a> <a id="3406" class="Symbol">|</a> <a id="3408" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3411" href="blog/syntax-guided-synthesis/index.html#3411" class="Bound">proof</a> <a id="3417" class="Symbol">|</a> <a id="3419" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3423" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a> <a id="3427" class="Symbol">=</a> <a id="3429" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a>
        <a id="3441" class="Symbol">(</a><a id="3442" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3449" class="Symbol">(</a><a id="3450" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3458" class="Bound">x≤o</a> <a id="3462" class="Symbol">(</a><a id="3463" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3475" class="Symbol">(</a><a id="3476" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3480" class="Bound">fi≡o</a><a id="3484" class="Symbol">)))</a>
                <a id="3504" class="Symbol">(</a><a id="3505" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3513" class="Bound">y≤o</a> <a id="3517" class="Symbol">(</a><a id="3518" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3530" class="Symbol">(</a><a id="3531" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3535" class="Bound">fi≡o</a><a id="3539" class="Symbol">)))</a>
                <a id="3559" class="Symbol">(</a><a id="3560" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="3565" class="Symbol">(</a><a id="3566" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3572" class="Bound">fi≡o</a> <a id="3577" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a><a id="3580" class="Symbol">)))</a>
<a id="3584" class="Symbol">...</a> <a id="3588" class="Symbol">|</a> <a id="3590" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3594" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a> <a id="3598" class="Symbol">|</a> <a id="3600" class="Symbol">_</a> <a id="3602" class="Symbol">=</a> <a id="3604" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a>
        <a id="3616" class="Symbol">(</a><a id="3617" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3624" class="Symbol">(</a><a id="3625" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3633" class="Bound">x≤o</a> <a id="3637" class="Symbol">(</a><a id="3638" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3650" class="Symbol">(</a><a id="3651" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3655" class="Bound">fi≡o</a><a id="3659" class="Symbol">)))</a>
                <a id="3679" class="Symbol">(</a><a id="3680" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3688" class="Bound">y≤o</a> <a id="3692" class="Symbol">(</a><a id="3693" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3705" class="Symbol">(</a><a id="3706" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3710" class="Bound">fi≡o</a><a id="3714" class="Symbol">)))</a>
                <a id="3734" class="Symbol">(</a><a id="3735" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="3740" class="Symbol">(</a><a id="3741" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3747" class="Bound">fi≡o</a> <a id="3752" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a><a id="3755" class="Symbol">)))</a>
</pre>
<p><span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> is a proof that our function is an implementation of <code>max</code>, and <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a></span> is a proof that “we’d know one if we saw one.” So that’s the specification taken care of. The next step is to define the syntax we’d like to guard our search.</p>
<p>The paper presents this syntax as a BNF grammar, but my thought is why use a grammar when we could instead use a type system? Our syntax is a tiny little branching calculus, capable of representing <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>s and branching <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a></span>itionals:</p>
<pre class="Agda"><a id="4279" class="Keyword">mutual</a>
  <a id="4288" class="Keyword">data</a> <a id="Term"></a><a id="4293" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4298" class="Symbol">:</a> <a id="4300" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="4304" class="Keyword">where</a>
    <a id="Term.var-x"></a><a id="4314" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4320" class="Symbol">:</a> <a id="4322" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.var-y"></a><a id="4331" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4337" class="Symbol">:</a> <a id="4339" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.const"></a><a id="4348" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4354" class="Symbol">:</a> <a id="4356" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4358" class="Symbol">→</a> <a id="4360" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.if-then-else"></a><a id="4369" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4382" class="Symbol">:</a> <a id="4384" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4389" class="Symbol">→</a> <a id="4391" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4396" class="Symbol">→</a> <a id="4398" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4403" class="Symbol">→</a> <a id="4405" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>

  <a id="4413" class="Keyword">data</a> <a id="Cond"></a><a id="4418" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4423" class="Symbol">:</a> <a id="4425" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="4429" class="Keyword">where</a>
    <a id="Cond.leq"></a><a id="4439" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4443" class="Symbol">:</a> <a id="4445" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4450" class="Symbol">→</a> <a id="4452" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4457" class="Symbol">→</a> <a id="4459" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.and"></a><a id="4468" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="4472" class="Symbol">:</a> <a id="4474" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4479" class="Symbol">→</a> <a id="4481" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4486" class="Symbol">→</a> <a id="4488" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.invert"></a><a id="4497" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4511" class="Symbol">→</a> <a id="4513" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
</pre>
<p>All that’s left for our example is the ability to “compile” a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span> down to a candidate function. Just pattern match on the constructors and push the inputs around until we’re done:</p>
<pre class="Agda"><a id="4719" class="Keyword">mutual</a>
  <a id="eval"></a><a id="4728" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4733" class="Symbol">:</a> <a id="4735" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4740" class="Symbol">→</a> <a id="4742" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4744" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="4746" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4748" class="Symbol">→</a> <a id="4750" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="4754" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4759" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4765" class="Symbol">(</a><a id="4766" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a> <a id="4768" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4770" href="blog/syntax-guided-synthesis/index.html#4770" class="Bound">y</a><a id="4771" class="Symbol">)</a> <a id="4773" class="Symbol">=</a> <a id="4775" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a>
  <a id="4779" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4784" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4790" class="Symbol">(</a><a id="4791" href="blog/syntax-guided-synthesis/index.html#4791" class="Bound">x</a> <a id="4793" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4795" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a><a id="4796" class="Symbol">)</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a>
  <a id="4804" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4809" class="Symbol">(</a><a id="4810" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4816" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a><a id="4817" class="Symbol">)</a> <a id="4819" class="Symbol">(</a><a id="4820" href="blog/syntax-guided-synthesis/index.html#4820" class="Bound">x</a> <a id="4822" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4824" href="blog/syntax-guided-synthesis/index.html#4824" class="Bound">y</a><a id="4825" class="Symbol">)</a> <a id="4827" class="Symbol">=</a> <a id="4829" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a>
  <a id="4833" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4838" class="Symbol">(</a><a id="4839" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4852" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4854" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4856" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a><a id="4857" class="Symbol">)</a> <a id="4859" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4861" class="Symbol">=</a>
    <a id="4867" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="4870" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4879" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4881" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4883" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="4888" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4893" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4895" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4897" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="4902" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4907" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a> <a id="4909" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a>

  <a id="evalCond"></a><a id="4914" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4923" class="Symbol">:</a> <a id="4925" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4930" class="Symbol">→</a> <a id="4932" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4934" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="4936" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4938" class="Symbol">→</a> <a id="4940" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="4947" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4956" class="Symbol">(</a><a id="4957" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4961" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4963" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a><a id="4964" class="Symbol">)</a> <a id="4966" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a>   <a id="4970" class="Symbol">=</a> <a id="4972" href="Relation.Nullary.html#1581" class="Field">Dec.does</a> <a id="4981" class="Symbol">(</a><a id="4982" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4987" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4989" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a> <a id="4991" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="4994" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4999" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a> <a id="5001" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a><a id="5002" class="Symbol">)</a>
  <a id="5006" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5015" class="Symbol">(</a><a id="5016" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="5020" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5023" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a><a id="5025" class="Symbol">)</a> <a id="5027" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5029" class="Symbol">=</a> <a id="5031" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5040" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5043" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5045" href="Data.Bool.Base.html#986" class="Function Operator">∧</a> <a id="5047" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5056" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a> <a id="5059" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a>
  <a id="5063" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5072" class="Symbol">(</a><a id="5073" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="5080" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a><a id="5081" class="Symbol">)</a> <a id="5083" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a>  <a id="5086" class="Symbol">=</a> <a id="5088" href="Data.Bool.Base.html#932" class="Function">not</a> <a id="5092" class="Symbol">(</a><a id="5093" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5102" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a> <a id="5104" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a><a id="5105" class="Symbol">)</a>
</pre>
<p>So that’s most of the idea; we’ve specified what we’re looking for, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>, what our syntax is, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>, and a way of compiling our syntax into functions, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a></span>. This is the gist of the technique; the rest is just algorithms.</p>
<p>The paper presents several algorithms and evaluates their performances. But one is clearly better than the others in the included benchmarks, so we’ll just go through that one.</p>
<p>Our algorithm to synthesize code corresponding to the specification takes a few parameters. We’ve seen the first few:</p>
<pre class="Agda"><a id="5677" class="Keyword">module</a> <a id="Solver"></a><a id="5684" href="blog/syntax-guided-synthesis/index.html#5684" class="Module">Solver</a>
    <a id="5695" class="Symbol">{</a><a id="5696" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5701" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5703" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a> <a id="5705" class="Symbol">:</a> <a id="5707" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5710" class="Symbol">}</a>
    <a id="5716" class="Symbol">(</a><a id="5717" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5722" class="Symbol">:</a> <a id="5724" class="Symbol">(</a><a id="5725" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5727" class="Symbol">→</a> <a id="5729" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5730" class="Symbol">)</a> <a id="5732" class="Symbol">→</a> <a id="5734" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5736" class="Symbol">→</a> <a id="5738" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5741" class="Symbol">)</a>
    <a id="5747" class="Symbol">(</a><a id="5748" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="5755" class="Symbol">:</a> <a id="5757" class="Symbol">(</a><a id="5758" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5760" class="Symbol">:</a> <a id="5762" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5764" class="Symbol">→</a> <a id="5766" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5767" class="Symbol">)</a> <a id="5769" class="Symbol">→</a> <a id="5771" class="Symbol">(</a><a id="5772" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a> <a id="5774" class="Symbol">:</a> <a id="5776" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="5777" class="Symbol">)</a> <a id="5779" class="Symbol">→</a> <a id="5781" href="Relation.Nullary.html#1511" class="Record">Dec</a> <a id="5785" class="Symbol">(</a><a id="5786" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5791" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5793" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a><a id="5794" class="Symbol">))</a>
    <a id="5801" class="Symbol">(</a><a id="5802" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="5810" class="Symbol">:</a> <a id="5812" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5817" class="Symbol">→</a> <a id="5819" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5824" class="Symbol">)</a>
</pre>
<p>However, we also need a way of synthesizing terms in our <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage. For that, we’ll use <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which maps a natural number to a term:</p>
<pre class="Agda">    <a id="5995" class="Symbol">(</a><a id="5996" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6006" class="Symbol">:</a> <a id="6008" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="6010" class="Symbol">→</a> <a id="6012" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6016" class="Symbol">)</a>
</pre>
<p>Although it’s not necessary for the algorithm, we should be able to implement <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a></span> over <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which states every <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span> is eventually produced by <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>:</p>
<pre class="Agda">    <a id="6234" class="Symbol">(</a><a id="6235" href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a> <a id="6246" class="Symbol">:</a> <a id="6248" class="Symbol">(</a><a id="6249" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a> <a id="6251" class="Symbol">:</a> <a id="6253" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6257" class="Symbol">)</a> <a id="6259" class="Symbol">→</a> <a id="6261" href="Data.Product.html#916" class="Function">Σ[</a> <a id="6264" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6266" href="Data.Product.html#916" class="Function">∈</a> <a id="6268" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="6270" href="Data.Product.html#916" class="Function">]</a> <a id="6272" class="Symbol">(</a><a id="6273" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6283" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6285" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6287" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a><a id="6288" class="Symbol">))</a>
</pre>
<p>Finally, we need an <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> capable of telling us if our solution is correct. This might sound a bit like cheating, but behind the scenes it’s just a magic SMT solver. The idea is that SMT can either confirm that our program is correct, or produce a counterexample that violates the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. The type here is a bit crazy, so we’ll take it one step at a time.</p>
<p>An <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is a function that takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>…</p>
<pre class="Agda">    <a id="6742" class="Symbol">(</a><a id="6743" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a>
      <a id="6756" class="Symbol">:</a> <a id="6758" class="Symbol">(</a><a id="6759" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a> <a id="6763" class="Symbol">:</a> <a id="6765" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6769" class="Symbol">)</a>
</pre>
<p>and either gives back a function that can produce a <code>spec (compile exp)</code> for every input:</p>
<pre class="Agda">      <a id="6877" class="Symbol">→</a>   <a id="6881" class="Symbol">((</a><a id="6883" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a> <a id="6885" class="Symbol">:</a> <a id="6887" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="6888" class="Symbol">)</a> <a id="6890" class="Symbol">→</a> <a id="6892" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="6897" class="Symbol">(</a><a id="6898" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="6906" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="6909" class="Symbol">)</a> <a id="6911" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a><a id="6912" class="Symbol">)</a>
</pre>
<p>or gives back some input which is not a <code>spec (compile exp)</code>:</p>
<pre class="Agda">        <a id="6994" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="6996" href="Data.Product.html#916" class="Function">Σ[</a> <a id="6999" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a> <a id="7001" href="Data.Product.html#916" class="Function">∈</a> <a id="7003" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7005" href="Data.Product.html#916" class="Function">]</a> <a id="7007" href="Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="7009" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="7014" class="Symbol">(</a><a id="7015" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="7023" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="7026" class="Symbol">)</a> <a id="7028" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a><a id="7029" class="Symbol">)</a>
    <a id="7035" class="Keyword">where</a>
</pre>
<p>The algorithm here is actually quite clever. The idea is that to try each <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d value in order, attempting to minimize the number of calls we make to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>, because they’re expensive. So instead, well keep a list of every counterexample we’ve seen so far, and ensure that our synthesized function passes all of them before sending it off to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>. First, we’ll need a data structure to store our search progress:</p>
<pre class="Agda">  <a id="7508" class="Keyword">record</a> <a id="Solver.SearchState"></a><a id="7515" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a> <a id="7527" class="Symbol">:</a> <a id="7529" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="7533" class="Keyword">where</a>
    <a id="7543" class="Keyword">field</a>
      <a id="Solver.SearchState.iteration"></a><a id="7555" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7565" class="Symbol">:</a> <a id="7567" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
      <a id="Solver.SearchState.cases"></a><a id="7575" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7581" class="Symbol">:</a> <a id="7583" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="7588" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a>
  <a id="7592" class="Keyword">open</a> <a id="7597" href="blog/syntax-guided-synthesis/index.html#7515" class="Module">SearchState</a>
</pre>
<p>The initial search state is one in which we start at the beginning, and have no counterexamples:</p>
<pre class="Agda">  <a id="Solver.start"></a><a id="7718" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7724" class="Symbol">:</a> <a id="7726" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
  <a id="7740" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7750" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7756" class="Symbol">=</a> <a id="7758" class="Number">0</a>
  <a id="7762" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7768" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7774" class="Symbol">=</a> <a id="7776" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
</pre>
<p>We can try a function by testing every counterexample:</p>
<pre class="Agda">  <a id="Solver.try"></a><a id="7847" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7851" class="Symbol">:</a> <a id="7853" class="Symbol">(</a><a id="7854" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7856" class="Symbol">→</a> <a id="7858" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="7859" class="Symbol">)</a> <a id="7861" class="Symbol">→</a> <a id="7863" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="7868" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7870" class="Symbol">→</a> <a id="7872" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="7879" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7883" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a> <a id="7885" class="Symbol">=</a> <a id="7887" href="Data.List.Base.html#4730" class="Function">all</a> <a id="7891" class="Symbol">(</a><a id="7892" href="Relation.Nullary.html#1581" class="Field">Dec.does</a> <a id="7901" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="7903" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="7910" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a><a id="7911" class="Symbol">)</a>
</pre>
<p>and finally, can now attempt to synthesize some code. Our function <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a></span>, and either gives back the next step of the search, or some program, and a proof that it’s what we’re looking for.</p>
<pre class="Agda">  <a id="Solver.check"></a><a id="8151" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a>
      <a id="8163" class="Symbol">:</a> <a id="8165" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
      <a id="8183" class="Symbol">→</a> <a id="8185" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="8207" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="8209" class="Symbol">(</a><a id="8210" href="Data.Product.html#916" class="Function">Σ[</a> <a id="8213" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a> <a id="8217" href="Data.Product.html#916" class="Function">∈</a> <a id="8219" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="8224" href="Data.Product.html#916" class="Function">]</a> <a id="8226" class="Symbol">((</a><a id="8228" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a> <a id="8230" class="Symbol">:</a> <a id="8232" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="8233" class="Symbol">)</a> <a id="8235" class="Symbol">→</a> <a id="8237" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="8242" class="Symbol">(</a><a id="8243" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8251" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a><a id="8254" class="Symbol">)</a> <a id="8256" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a><a id="8257" class="Symbol">))</a>
  <a id="8262" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="8268" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a>
</pre>
<p>We begin by getting and compiling the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d term:</p>
<pre class="Agda">           <a id="8361" class="Keyword">with</a> <a id="8366" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="8376" class="Symbol">(</a><a id="8377" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8387" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a><a id="8389" class="Symbol">)</a>
  <a id="8393" class="Symbol">...</a> <a id="8397" class="Symbol">|</a> <a id="8399" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a> <a id="8403" class="Keyword">with</a> <a id="8408" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8416" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a>
</pre>
<p>check if it passes all the previous counterexamples:</p>
<pre class="Agda">  <a id="8485" class="Symbol">...</a> <a id="8489" class="Symbol">|</a> <a id="8491" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8493" class="Keyword">with</a> <a id="8498" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="8502" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8504" class="Symbol">(</a><a id="8505" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8511" class="Bound">ss</a><a id="8513" class="Symbol">)</a>
</pre>
<p>if it doesn’t, just fail with the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a></span>:</p>
<pre class="Agda">  <a id="8586" class="Symbol">...</a> <a id="8590" class="Symbol">|</a> <a id="8592" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8598" class="Symbol">=</a> <a id="8600" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8605" class="Symbol">(</a><a id="8606" class="Keyword">record</a> <a id="8613" class="Symbol">{</a> <a id="8615" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8625" class="Symbol">=</a> <a id="8627" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8631" class="Symbol">(</a><a id="8632" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8642" class="Bound">ss</a><a id="8644" class="Symbol">)</a>
                             <a id="8675" class="Symbol">;</a> <a id="8677" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8683" class="Symbol">=</a> <a id="8685" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8691" class="Bound">ss</a>
                             <a id="8723" class="Symbol">})</a>
</pre>
<p>Otherwise, our proposed function might just be the thing we’re looking for, so it’s time to consult the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>:</p>
<pre class="Agda">  <a id="8859" class="Symbol">...</a> <a id="8863" class="Symbol">|</a> <a id="8865" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8870" class="Keyword">with</a> <a id="8875" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a> <a id="8882" class="Bound">exp</a>
</pre>
<p>which either gives a counterexample that we need to record:</p>
<pre class="Agda">  <a id="8958" class="Symbol">...</a> <a id="8962" class="Symbol">|</a> <a id="8964" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="8969" class="Symbol">(</a><a id="8970" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a id="8972" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8974" class="Symbol">_)</a> <a id="8977" class="Symbol">=</a>
          <a id="8989" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8994" class="Symbol">(</a><a id="8995" class="Keyword">record</a> <a id="9002" class="Symbol">{</a> <a id="9004" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9014" class="Symbol">=</a> <a id="9016" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9020" class="Symbol">(</a><a id="9021" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9031" class="Bound">ss</a><a id="9033" class="Symbol">)</a>
                       <a id="9058" class="Symbol">;</a> <a id="9060" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9066" class="Symbol">=</a> <a id="9068" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a id="9070" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9072" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9078" class="Bound">ss</a>
                       <a id="9104" class="Symbol">})</a>
</pre>
<p>or it confirms that our function satisfies the specification, and thus that were done:</p>
<pre class="Agda">  <a id="9206" class="Symbol">...</a> <a id="9210" class="Symbol">|</a> <a id="9212" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="9217" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a> <a id="9219" class="Symbol">=</a> <a id="9221" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="9226" class="Symbol">(</a><a id="9227" class="Bound">exp</a> <a id="9231" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9233" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a><a id="9234" class="Symbol">)</a>
</pre>
<p>Pretty cool! The paper gives an optimization that caches the result of every counterexample on every synthesized program, and reuses these whenever that program appears as a subprogram of a larger one. The idea is that we can trade storage so we only ever need to evaluate each subprogram once — important for expensive computations.</p>
<p>Of course, pumping <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> by hand is annoying, so we can instead package it up as <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a></span> which takes a search depth, and iterates <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> until it runs out of gas or gets the right answer:</p>
<pre class="Agda">  <a id="Solver.solve"></a><a id="9797" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a>
      <a id="9809" class="Symbol">:</a> <a id="9811" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
      <a id="9819" class="Symbol">→</a> <a id="9821" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="9827" class="Symbol">(</a><a id="9828" href="Data.Product.html#916" class="Function">Σ[</a> <a id="9831" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">exp</a> <a id="9835" href="Data.Product.html#916" class="Function">∈</a> <a id="9837" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9842" href="Data.Product.html#916" class="Function">]</a> <a id="9844" class="Symbol">((</a><a id="9846" href="blog/syntax-guided-synthesis/index.html#9846" class="Bound">i</a> <a id="9848" class="Symbol">:</a> <a id="9850" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="9851" class="Symbol">)</a> <a id="9853" class="Symbol">→</a> <a id="9855" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="9860" class="Symbol">(</a><a id="9861" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="9869" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">exp</a><a id="9872" class="Symbol">)</a> <a id="9874" href="blog/syntax-guided-synthesis/index.html#9846" class="Bound">i</a><a id="9875" class="Symbol">))</a>
  <a id="9880" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a> <a id="9886" class="Symbol">=</a> <a id="9888" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="9891" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a>
    <a id="9901" class="Keyword">where</a>
      <a id="9913" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a>
          <a id="9926" class="Symbol">:</a> <a id="9928" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="9950" class="Symbol">→</a> <a id="9952" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
          <a id="9964" class="Symbol">→</a> <a id="9966" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a>
              <a id="9986" class="Symbol">(</a><a id="9987" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="9989" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9994" class="Symbol">(λ</a> <a id="9997" href="blog/syntax-guided-synthesis/index.html#9997" class="Bound">exp</a> <a id="10001" class="Symbol">→</a> <a id="10003" class="Symbol">(</a><a id="10004" href="blog/syntax-guided-synthesis/index.html#10004" class="Bound">i</a> <a id="10006" class="Symbol">:</a> <a id="10008" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="10009" class="Symbol">)</a> <a id="10011" class="Symbol">→</a> <a id="10013" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="10018" class="Symbol">(</a><a id="10019" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="10027" href="blog/syntax-guided-synthesis/index.html#9997" class="Bound">exp</a><a id="10030" class="Symbol">)</a> <a id="10032" href="blog/syntax-guided-synthesis/index.html#10004" class="Bound">i</a><a id="10033" class="Symbol">))</a>
      <a id="10042" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10045" href="blog/syntax-guided-synthesis/index.html#10045" class="Bound">ss</a> <a id="10048" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="10053" class="Symbol">=</a> <a id="10055" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
      <a id="10069" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10072" href="blog/syntax-guided-synthesis/index.html#10072" class="Bound">ss</a> <a id="10075" class="Symbol">(</a><a id="10076" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10080" href="blog/syntax-guided-synthesis/index.html#10080" class="Bound">n</a><a id="10081" class="Symbol">)</a> <a id="10083" class="Keyword">with</a> <a id="10088" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="10094" href="blog/syntax-guided-synthesis/index.html#10072" class="Bound">ss</a>
      <a id="10103" class="Symbol">...</a> <a id="10107" class="Symbol">|</a> <a id="10109" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="10114" href="blog/syntax-guided-synthesis/index.html#10114" class="Bound">x</a> <a id="10116" class="Symbol">=</a> <a id="10118" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10121" class="Bound">ss</a> <a id="10124" class="Bound">n</a>
      <a id="10132" class="Symbol">...</a> <a id="10136" class="Symbol">|</a> <a id="10138" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="10143" href="blog/syntax-guided-synthesis/index.html#10143" class="Bound">y</a> <a id="10145" class="Symbol">=</a> <a id="10147" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10152" href="blog/syntax-guided-synthesis/index.html#10143" class="Bound">y</a>
</pre>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Generic Parallel Functional Programming</title>
      <id>blog/generic-parallel-fp/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/generic-parallel-fp/index.html'/>
      <published>2022-03-12</published>
      <updated>2022-03-12</updated>

      <content type="html">
        <![CDATA[
        <!--
<pre class="Agda"><a id="164" class="Keyword">module</a> <a id="171" href="blog.generic-parallel-fp.html" class="Module">blog.generic-parallel-fp</a> <a id="196" class="Keyword">where</a>

<a id="203" class="Keyword">open</a> <a id="208" class="Keyword">import</a> <a id="215" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>

<a id="231" class="Keyword">private</a>
  <a id="241" class="Keyword">variable</a>
    <a id="254" href="blog.generic-parallel-fp.html#254" class="Generalizable">A</a> <a id="256" class="Symbol">:</a> <a id="258" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="266" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="268" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="270" class="Symbol">:</a> <a id="272" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="276" class="Symbol">→</a> <a id="278" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="286" href="blog.generic-parallel-fp.html#286" class="Generalizable">𝓁</a> <a id="288" class="Symbol">:</a> <a id="290" href="Agda.Primitive.html#597" class="Postulate">Level</a>

<a id="297" class="Keyword">record</a> <a id="Monoid"></a><a id="304" href="blog.generic-parallel-fp.html#304" class="Record">Monoid</a> <a id="311" class="Symbol">(</a><a id="312" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="314" class="Symbol">:</a> <a id="316" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="319" class="Symbol">)</a> <a id="321" class="Symbol">:</a> <a id="323" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="327" class="Keyword">where</a>
  <a id="335" class="Keyword">infixr</a> <a id="342" class="Number">6</a> <a id="344" href="blog.generic-parallel-fp.html#376" class="Field Operator">_&lt;&gt;_</a>
  <a id="351" class="Keyword">field</a>
    <a id="Monoid.mempty"></a><a id="361" href="blog.generic-parallel-fp.html#361" class="Field">mempty</a> <a id="368" class="Symbol">:</a> <a id="370" href="blog.generic-parallel-fp.html#312" class="Bound">A</a>
    <a id="Monoid._&lt;&gt;_"></a><a id="376" href="blog.generic-parallel-fp.html#376" class="Field Operator">_&lt;&gt;_</a> <a id="381" class="Symbol">:</a> <a id="383" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="385" class="Symbol">→</a> <a id="387" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="389" class="Symbol">→</a> <a id="391" href="blog.generic-parallel-fp.html#312" class="Bound">A</a>
<a id="393" class="Keyword">open</a> <a id="398" href="blog.generic-parallel-fp.html#304" class="Module">Monoid</a> <a id="405" class="Symbol">⦃</a> <a id="407" class="Symbol">...</a> <a id="411" class="Symbol">⦄</a>


<a id="415" class="Keyword">open</a> <a id="420" class="Keyword">import</a> <a id="427" href="Function.html" class="Module">Function</a>
<a id="436" class="Keyword">open</a> <a id="441" class="Keyword">import</a> <a id="448" href="Data.Product.html" class="Module">Data.Product</a> <a id="461" class="Keyword">hiding</a> <a id="468" class="Symbol">(</a><a id="469" href="Data.Product.html#3060" class="Function">zip</a><a id="472" class="Symbol">)</a>
</pre>-->
<p>Today we’re heading back into the Elliottverse — a beautiful world where programming is principled and makes sense. The paper of the week is Conal Elliott’s <a href="http://conal.net/papers/generic-parallel-functional/generic-parallel-functional.pdf">Generic Parallel Functional Programming</a>, which productively addresses the duality between “easy to reason about” and “fast to run.”</p>
<p>Consider the case of a right-associated list, we can give a scan of it in linear time and constant space:</p>
<pre class="Agda"><a id="989" class="Keyword">module</a> <a id="ExR"></a><a id="996" href="blog/generic-parallel-fp/index.html#996" class="Module">ExR</a> <a id="1000" class="Keyword">where</a>
  <a id="1008" class="Keyword">data</a> <a id="ExR.RList"></a><a id="1013" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1019" class="Symbol">(</a><a id="1020" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1022" class="Symbol">:</a> <a id="1024" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1027" class="Symbol">)</a> <a id="1029" class="Symbol">:</a> <a id="1031" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1035" class="Keyword">where</a>
    <a id="ExR.RList.RNil"></a><a id="1045" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a> <a id="1050" class="Symbol">:</a> <a id="1052" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1058" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a>
    <a id="ExR.RList._◁_"></a><a id="1064" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">_◁_</a> <a id="1068" class="Symbol">:</a> <a id="1070" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1072" class="Symbol">→</a> <a id="1074" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1080" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1082" class="Symbol">→</a> <a id="1084" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1090" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a>

  <a id="1095" class="Keyword">infixr</a> <a id="1102" class="Number">5</a> <a id="1104" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">_◁_</a>

  <a id="ExR.scanR"></a><a id="1111" href="blog/generic-parallel-fp/index.html#1111" class="Function">scanR</a> <a id="1117" class="Symbol">:</a> <a id="1119" class="Symbol">⦃</a> <a id="1121" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1128" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1130" class="Symbol">⦄</a> <a id="1132" class="Symbol">→</a> <a id="1134" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1140" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1142" class="Symbol">→</a> <a id="1144" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1150" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="1154" href="blog/generic-parallel-fp/index.html#1111" class="Function">scanR</a> <a id="1160" class="Symbol">=</a> <a id="1162" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1165" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
    <a id="1176" class="Keyword">where</a>
      <a id="1188" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1191" class="Symbol">:</a> <a id="1193" class="Symbol">⦃</a> <a id="1195" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1202" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1204" class="Symbol">⦄</a> <a id="1206" class="Symbol">→</a> <a id="1208" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1210" class="Symbol">→</a> <a id="1212" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1218" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1220" class="Symbol">→</a> <a id="1222" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1228" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
      <a id="1236" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1239" href="blog/generic-parallel-fp/index.html#1239" class="Bound">acc</a> <a id="1243" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a> <a id="1248" class="Symbol">=</a> <a id="1250" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a>
      <a id="1261" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1264" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1268" class="Symbol">(</a><a id="1269" href="blog/generic-parallel-fp/index.html#1269" class="Bound">x</a> <a id="1271" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">◁</a> <a id="1273" href="blog/generic-parallel-fp/index.html#1273" class="Bound">xs</a><a id="1275" class="Symbol">)</a> <a id="1277" class="Symbol">=</a> <a id="1279" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1283" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">◁</a> <a id="1285" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1288" class="Symbol">(</a><a id="1289" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1293" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="1296" href="blog/generic-parallel-fp/index.html#1269" class="Bound">x</a><a id="1297" class="Symbol">)</a> <a id="1299" href="blog/generic-parallel-fp/index.html#1273" class="Bound">xs</a>
</pre>
<p>This is a nice functional algorithm that runs in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time, and requires <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> space. However, consider the equivalent algorithm over left-associative lists:</p>
<pre class="Agda"><a id="1473" class="Keyword">module</a> <a id="ExL"></a><a id="1480" href="blog/generic-parallel-fp/index.html#1480" class="Module">ExL</a> <a id="1484" class="Keyword">where</a>
  <a id="1492" class="Keyword">data</a> <a id="ExL.LList"></a><a id="1497" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1503" class="Symbol">(</a><a id="1504" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1506" class="Symbol">:</a> <a id="1508" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="1511" class="Symbol">)</a> <a id="1513" class="Symbol">:</a> <a id="1515" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1519" class="Keyword">where</a>
    <a id="ExL.LList.LNil"></a><a id="1529" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1534" class="Symbol">:</a> <a id="1536" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1542" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a>
    <a id="ExL.LList._▷_"></a><a id="1548" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">_▷_</a> <a id="1552" class="Symbol">:</a> <a id="1554" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1560" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1562" class="Symbol">→</a> <a id="1564" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1566" class="Symbol">→</a> <a id="1568" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1574" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a>

  <a id="1579" class="Keyword">infixl</a> <a id="1586" class="Number">5</a> <a id="1588" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">_▷_</a>

  <a id="ExL.scanL"></a><a id="1595" href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a> <a id="1601" class="Symbol">:</a> <a id="1603" class="Symbol">⦃</a> <a id="1605" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1612" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1614" class="Symbol">⦄</a> <a id="1616" class="Symbol">→</a> <a id="1618" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1624" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1626" class="Symbol">→</a> <a id="1628" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1634" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="1638" href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a> <a id="1644" class="Symbol">=</a> <a id="1646" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="1652" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="1654" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a>
    <a id="1661" class="Keyword">where</a>
      <a id="1673" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1676" class="Symbol">:</a> <a id="1678" class="Symbol">⦃</a> <a id="1680" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1687" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1689" class="Symbol">⦄</a> <a id="1691" class="Symbol">→</a> <a id="1693" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1699" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1709" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1711" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1713" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
      <a id="1721" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1724" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1729" class="Symbol">=</a> <a id="1731" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1736" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1738" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
      <a id="1751" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1754" class="Symbol">(</a><a id="1755" href="blog/generic-parallel-fp/index.html#1755" class="Bound">xs</a> <a id="1758" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">▷</a> <a id="1760" href="blog/generic-parallel-fp/index.html#1760" class="Bound">x</a><a id="1761" class="Symbol">)</a> <a id="1763" class="Symbol">=</a>
        <a id="1773" class="Keyword">let</a> <a id="1777" href="blog/generic-parallel-fp/index.html#1777" class="Bound">xs&#39;</a> <a id="1781" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1783" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a> <a id="1787" class="Symbol">=</a> <a id="1789" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1792" href="blog/generic-parallel-fp/index.html#1755" class="Bound">xs</a>
         <a id="1804" class="Keyword">in</a> <a id="1807" href="blog/generic-parallel-fp/index.html#1777" class="Bound">xs&#39;</a> <a id="1811" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">▷</a> <a id="1813" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a> <a id="1817" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1819" href="blog/generic-parallel-fp/index.html#1760" class="Bound">x</a> <a id="1821" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="1824" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a>
</pre>
<p>While <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a></span> is also <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> in its runtime, it is not amenable to tail call optimization, and thus also requires <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> <em>space.</em> Egads!</p>
<p>You are probably not amazed to learn that different ways of structuring data lead to different runtime and space complexities. But it’s a more interesting puzzle than it sounds; because <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a></span> are isomorphic! So what gives?</p>
<p>Reed’s pithy description here is</p>
<blockquote>
<p>Computation time doesn’t respect isos</p>
</blockquote>
<p>Exploring that question with him has been very illuminating. Math is deeply about extentionality; two mathematical objects are equivalent if their abstract interfaces are indistinguishable. Computation… doesn’t have this property. When computing, we care a great deal about runtime performance, which depends on fiddly implementation details, even if those aren’t externally observable.</p>
<p>In fact, as he goes on to state, this is the whole idea of denotational design. Figure out the extensional behavior first, and then figure out how to implement it.</p>
<p>This all harkens back to my review of another of Elliott’s papers, <a href="/blog/adders-and-arrows">Adders and Arrows</a>, which starts from the extensional behavior of natural addition (encoded as the Peano naturals), and then derives a chain of proofs showing that our everyday binary adders preserve this behavior.</p>
<p>Anyway, let’s switch topics and consider a weird fact of the world. Why do so many parallel algorithms require gnarly array indexing? Here’s an example I found by googling for “parallel c algorithms cuda”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> stencil_1d<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>in<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  __shared__ <span class="dt">int</span> temp<span class="op">[</span>BLOCK_SIZE <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> RADIUS<span class="op">];</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> gindex <span class="op">=</span> threadIdx<span class="op">.</span>x <span class="op">+</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> lindex <span class="op">=</span> threadIdx<span class="op">.</span>x <span class="op">+</span> RADIUS<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  temp<span class="op">[</span>lindex<span class="op">]</span> <span class="op">=</span> in<span class="op">[</span>gindex<span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>threadIdx<span class="op">.</span>x <span class="op">&lt;</span> RADIUS<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    temp<span class="op">[</span>lindex <span class="op">-</span> RADIUS<span class="op">]</span> <span class="op">=</span> in<span class="op">[</span>gindex <span class="op">-</span> RADIUS<span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    temp<span class="op">[</span>lindex <span class="op">+</span> BLOCK_SIZE<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    in<span class="op">[</span>gindex <span class="op">+</span> BLOCK_SIZE<span class="op">];</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  __syncthreads<span class="op">();</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> result <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> offset <span class="op">=</span> <span class="op">-</span>RADIUS <span class="op">;</span> offset <span class="op">&lt;=</span> RADIUS <span class="op">;</span> offset<span class="op">++)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    result <span class="op">+=</span> temp<span class="op">[</span>lindex <span class="op">+</span> offset<span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  out<span class="op">[</span>gindex<span class="op">]</span> <span class="op">=</span> result<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and here’s another, expressed as an “easy induction” recurrence relation, from <a href="http://personal.denison.edu/~bressoud/cs402-s11/Supplements/ParallelPrefix.pdf">Richard E Ladner and Michael J Fischer. Parallel prefix computation</a>:</p>
<center>
<img src="/images/generic-parallel-fp/indices.png">
</center>
<p>Sweet lord. No wonder we’re all stuck pretending our computer machines are single threaded behemoths from the 1960s. Taking full advantage of parallelism on modern CPUs must require a research team and five years!</p>
<p>But it’s worth taking a moment and thinking about what all of this janky indexing must be doing. Whatever algorithm is telling the programmer which indices to write where necessarily must be providing a view on the data. That is, the programmer has some sort of “shape” in mind for how the problem should be subdivided, and the indexing is an implementation of accessing the raw array elements in the desired shape.</p>
<p>At risk of beating you on the head with it, this array indexing is <em>a bad implementation of a type system.</em> Bad because it’s something the implementer needed to invent by hand, and is not in any form that the compiler can help ensure the correctness of.</p>
<p>That returns us to the big contribution of <em>Generic Function Parallel Algorithms,</em> which is a technique for decoupling the main thrust of an algorithm from extentionally-inconsequential encodings of things. The idea is to implement the algorithm on lots of trivial data structures, and then compose those small pieces together to get a <em>class</em> of algorithms.</p>
<h2 id="generic-representations"><a href="#generic-representations" class="header-link">Generic Representations<span class="header-link-emoji">🔗</span></a></h2>
<p>The first step is to determine which trivial data structures we need to support. Following the steps of Haskell’s <code>GHC.Generics</code> module, we can decompose any Haskell98 data type as compositions of the following pieces:</p>
<pre class="Agda"><a id="5738" class="Keyword">data</a> <a id="Rep"></a><a id="5743" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5747" class="Symbol">:</a> <a id="5749" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="5754" class="Keyword">where</a>
  <a id="Rep.V"></a><a id="5762" href="blog/generic-parallel-fp/index.html#5762" class="InductiveConstructor">V</a> <a id="5764" class="Symbol">:</a> <a id="5766" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.U"></a><a id="5772" href="blog/generic-parallel-fp/index.html#5772" class="InductiveConstructor">U</a> <a id="5774" class="Symbol">:</a> <a id="5776" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.K"></a><a id="5782" href="blog/generic-parallel-fp/index.html#5782" class="InductiveConstructor">K</a> <a id="5784" class="Symbol">:</a> <a id="5786" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="5790" class="Symbol">→</a> <a id="5792" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.Par"></a><a id="5798" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="5802" class="Symbol">:</a> <a id="5804" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.Rec"></a><a id="5810" href="blog/generic-parallel-fp/index.html#5810" class="InductiveConstructor">Rec</a> <a id="5814" class="Symbol">:</a> <a id="5816" class="Symbol">(</a><a id="5817" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5826" class="Symbol">)</a> <a id="5828" class="Symbol">→</a> <a id="5830" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:+:_"></a><a id="5836" href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">_:+:_</a> <a id="5842" class="Symbol">:</a> <a id="5844" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5848" class="Symbol">→</a> <a id="5850" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5854" class="Symbol">→</a> <a id="5856" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:*:_"></a><a id="5862" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">_:*:_</a> <a id="5868" class="Symbol">:</a> <a id="5870" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5874" class="Symbol">→</a> <a id="5876" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5880" class="Symbol">→</a> <a id="5882" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:∘:_"></a><a id="5888" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">_:∘:_</a> <a id="5894" class="Symbol">:</a> <a id="5896" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5900" class="Symbol">→</a> <a id="5902" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5906" class="Symbol">→</a> <a id="5908" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
</pre>
<p>which we can embed in <span class="Agda"><a href="Agda.Primitive.html#326" class="Primitive">Set</a></span> via <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>:</p>
<pre class="Agda"><a id="5981" class="Keyword">open</a> <a id="5986" class="Keyword">import</a> <a id="5993" href="Data.Empty.html" class="Module">Data.Empty</a>
<a id="6004" class="Keyword">open</a> <a id="6009" class="Keyword">import</a> <a id="6016" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="6025" class="Keyword">open</a> <a id="6030" class="Keyword">import</a> <a id="6037" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="6047" class="Keyword">hiding</a> <a id="6054" class="Symbol">(</a><a id="6055" href="Data.Unit.Base.html#1023" class="Record Operator">_≤_</a><a id="6058" class="Symbol">)</a>

<a id="6061" class="Keyword">record</a> <a id="Compose"></a><a id="6068" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="6076" class="Symbol">(</a><a id="6077" href="blog/generic-parallel-fp/index.html#6077" class="Bound">F</a> <a id="6079" href="blog/generic-parallel-fp/index.html#6079" class="Bound">G</a> <a id="6081" class="Symbol">:</a> <a id="6083" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6087" class="Symbol">→</a> <a id="6089" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6092" class="Symbol">)</a> <a id="6094" class="Symbol">(</a><a id="6095" href="blog/generic-parallel-fp/index.html#6095" class="Bound">A</a> <a id="6097" class="Symbol">:</a> <a id="6099" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6102" class="Symbol">)</a> <a id="6104" class="Symbol">:</a> <a id="6106" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6110" class="Keyword">where</a>
  <a id="6118" class="Keyword">constructor</a> <a id="compose"></a><a id="6130" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a>
  <a id="6140" class="Keyword">field</a>
    <a id="Compose.composed"></a><a id="6150" href="blog/generic-parallel-fp/index.html#6150" class="Field">composed</a> <a id="6159" class="Symbol">:</a> <a id="6161" href="blog/generic-parallel-fp/index.html#6077" class="Bound">F</a> <a id="6163" class="Symbol">(</a><a id="6164" href="blog/generic-parallel-fp/index.html#6079" class="Bound">G</a> <a id="6166" href="blog/generic-parallel-fp/index.html#6095" class="Bound">A</a><a id="6167" class="Symbol">)</a>
<a id="6169" class="Keyword">open</a> <a id="6174" href="blog/generic-parallel-fp/index.html#6068" class="Module">Compose</a>

<a id="Represent"></a><a id="6183" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6193" class="Symbol">:</a> <a id="6195" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="6199" class="Symbol">→</a> <a id="6201" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6205" class="Symbol">→</a> <a id="6207" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="6211" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6221" href="blog/generic-parallel-fp/index.html#5762" class="InductiveConstructor">V</a> <a id="6223" href="blog/generic-parallel-fp/index.html#6223" class="Bound">a</a>         <a id="6233" class="Symbol">=</a> <a id="6235" href="Data.Empty.html#526" class="Datatype">⊥</a>
<a id="6237" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6247" href="blog/generic-parallel-fp/index.html#5772" class="InductiveConstructor">U</a> <a id="6249" href="blog/generic-parallel-fp/index.html#6249" class="Bound">a</a>         <a id="6259" class="Symbol">=</a> <a id="6261" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="6263" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6273" class="Symbol">(</a><a id="6274" href="blog/generic-parallel-fp/index.html#5782" class="InductiveConstructor">K</a> <a id="6276" href="blog/generic-parallel-fp/index.html#6276" class="Bound">x</a><a id="6277" class="Symbol">)</a> <a id="6279" href="blog/generic-parallel-fp/index.html#6279" class="Bound">a</a>     <a id="6285" class="Symbol">=</a> <a id="6287" href="blog/generic-parallel-fp/index.html#6276" class="Bound">x</a>
<a id="6289" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6299" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="6303" href="blog/generic-parallel-fp/index.html#6303" class="Bound">a</a>       <a id="6311" class="Symbol">=</a> <a id="6313" href="blog/generic-parallel-fp/index.html#6303" class="Bound">a</a>
<a id="6315" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6325" class="Symbol">(</a><a id="6326" href="blog/generic-parallel-fp/index.html#5810" class="InductiveConstructor">Rec</a> <a id="6330" href="blog/generic-parallel-fp/index.html#6330" class="Bound">f</a><a id="6331" class="Symbol">)</a> <a id="6333" href="blog/generic-parallel-fp/index.html#6333" class="Bound">a</a>   <a id="6337" class="Symbol">=</a> <a id="6339" href="blog/generic-parallel-fp/index.html#6330" class="Bound">f</a> <a id="6341" href="blog/generic-parallel-fp/index.html#6333" class="Bound">a</a>
<a id="6343" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6353" class="Symbol">(</a><a id="6354" href="blog/generic-parallel-fp/index.html#6354" class="Bound">x</a> <a id="6356" href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">:+:</a> <a id="6360" href="blog/generic-parallel-fp/index.html#6360" class="Bound">y</a><a id="6361" class="Symbol">)</a> <a id="6363" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a> <a id="6365" class="Symbol">=</a> <a id="6367" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6377" href="blog/generic-parallel-fp/index.html#6354" class="Bound">x</a> <a id="6379" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a> <a id="6381" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="6383" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6393" href="blog/generic-parallel-fp/index.html#6360" class="Bound">y</a> <a id="6395" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a>
<a id="6397" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6407" class="Symbol">(</a><a id="6408" href="blog/generic-parallel-fp/index.html#6408" class="Bound">x</a> <a id="6410" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="6414" href="blog/generic-parallel-fp/index.html#6414" class="Bound">y</a><a id="6415" class="Symbol">)</a> <a id="6417" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a> <a id="6419" class="Symbol">=</a> <a id="6421" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6431" href="blog/generic-parallel-fp/index.html#6408" class="Bound">x</a> <a id="6433" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a> <a id="6435" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="6437" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6447" href="blog/generic-parallel-fp/index.html#6414" class="Bound">y</a> <a id="6449" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a>
<a id="6451" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6461" class="Symbol">(</a><a id="6462" href="blog/generic-parallel-fp/index.html#6462" class="Bound">x</a> <a id="6464" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="6468" href="blog/generic-parallel-fp/index.html#6468" class="Bound">y</a><a id="6469" class="Symbol">)</a> <a id="6471" href="blog/generic-parallel-fp/index.html#6471" class="Bound">a</a> <a id="6473" class="Symbol">=</a> <a id="6475" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="6483" class="Symbol">(</a><a id="6484" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6494" href="blog/generic-parallel-fp/index.html#6462" class="Bound">x</a><a id="6495" class="Symbol">)</a> <a id="6497" class="Symbol">(</a><a id="6498" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6508" href="blog/generic-parallel-fp/index.html#6468" class="Bound">y</a><a id="6509" class="Symbol">)</a> <a id="6511" href="blog/generic-parallel-fp/index.html#6471" class="Bound">a</a>
</pre>
<p>If you’ve ever worked with <code>GHC.Generics</code>, none of this should be very exciting. We can bundle everything together, plus an iso to transform to and from the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>ed type:</p>
<pre class="Agda"><a id="6707" class="Keyword">record</a> <a id="Generic"></a><a id="6714" href="blog/generic-parallel-fp/index.html#6714" class="Record">Generic</a> <a id="6722" class="Symbol">(</a><a id="6723" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6725" class="Symbol">:</a> <a id="6727" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6731" class="Symbol">→</a> <a id="6733" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6736" class="Symbol">)</a> <a id="6738" class="Symbol">:</a> <a id="6740" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="6745" class="Keyword">where</a>
  <a id="6753" class="Keyword">field</a>
    <a id="Generic.RepOf"></a><a id="6763" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6769" class="Symbol">:</a> <a id="6771" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
    <a id="Generic.from"></a><a id="6779" href="blog/generic-parallel-fp/index.html#6779" class="Field">from</a>  <a id="6785" class="Symbol">:</a> <a id="6787" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6789" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="6791" class="Symbol">→</a> <a id="6793" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6803" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6809" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
    <a id="Generic.to"></a><a id="6815" href="blog/generic-parallel-fp/index.html#6815" class="Field">to</a>    <a id="6821" class="Symbol">:</a> <a id="6823" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6833" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6839" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="6841" class="Symbol">→</a> <a id="6843" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6845" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="6847" class="Keyword">open</a> <a id="6852" href="blog/generic-parallel-fp/index.html#6714" class="Module">Generic</a> <a id="6860" class="Symbol">⦃</a> <a id="6862" class="Symbol">...</a> <a id="6866" class="Symbol">⦄</a>

<a id="GenericRep"></a><a id="6869" href="blog/generic-parallel-fp/index.html#6869" class="Function">GenericRep</a> <a id="6880" class="Symbol">:</a> <a id="6882" class="Symbol">(</a><a id="6883" href="blog/generic-parallel-fp/index.html#6883" class="Bound">F</a> <a id="6885" class="Symbol">:</a> <a id="6887" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6891" class="Symbol">→</a> <a id="6893" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6896" class="Symbol">)</a> <a id="6898" class="Symbol">→</a> <a id="6900" class="Symbol">⦃</a> <a id="6902" href="blog/generic-parallel-fp/index.html#6714" class="Record">Generic</a> <a id="6910" href="blog/generic-parallel-fp/index.html#6883" class="Bound">F</a> <a id="6912" class="Symbol">⦄</a> <a id="6914" class="Symbol">→</a> <a id="6916" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="6920" class="Symbol">→</a> <a id="6922" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="6926" href="blog/generic-parallel-fp/index.html#6869" class="Function">GenericRep</a> <a id="6937" class="Symbol">_</a> <a id="6939" class="Symbol">=</a> <a id="6941" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6951" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a>
</pre>
<p>Agda doesn’t have any out-of-the-box notion of <code>-XDeriveGeneric</code>, which seems like a headache at first blush. It means we need to explicitly write out a <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6779" class="Field">from</a></span>/<span class="Agda"><a href="blog/generic-parallel-fp/index.html#6815" class="Field">to</a></span> pairs by hand, <em>like peasants.</em> Surprisingly however, needing to implement by hand is beneficial, as it reminds us that <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> <em>is not uniquely determined!</em></p>
<p>A good metaphor here is the number 16, which stands for some type we’d like to generify. A <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> for 16 is an equivalent representation for 16. Here are a few:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2+(2+(2+(2+(2+(2+(2+2))))))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">))))))</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((2+2)*2)+(((2+2)+2)+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(((</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2 \times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">8 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo>×</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(4 \times 2) \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo stretchy="false">)</mo><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(2 \times 4) \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msup><mn>2</mn><mn>2</mn></msup></msup></mrow><annotation encoding="application/x-tex">2^{2^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>And there are lots more! Each of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> and exponentiation corresponds to a different way of building a type, so every one of these expressions is a distinct (if isomorphic) type with 16 values. Every single possible factoring of 16 corresponds to a different way of dividing-and-conquering, which is to say, a different (but related) algorithm.</p>
<p>The trick is to define our algorithm inductively over each <span class="Agda"><a href="Agda.Primitive.html#326" class="Primitive">Set</a></span> that can result from <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>. We can then pick different algorithms from the class by changing the specific way of factoring our type.</p>
<h2 id="left-scans"><a href="#left-scans" class="header-link">Left Scans<span class="header-link-emoji">🔗</span></a></h2>
<p>Let’s consider the case of left scans. I happen to know it’s going to require <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a></span> capabilities, so we’ll also define that:</p>
<pre class="Agda"><a id="8404" class="Keyword">record</a> <a id="Functor"></a><a id="8411" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="8419" class="Symbol">(</a><a id="8420" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8422" class="Symbol">:</a> <a id="8424" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8428" href="blog/generic-parallel-fp/index.html#286" class="Generalizable">𝓁</a> <a id="8430" class="Symbol">→</a> <a id="8432" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8436" href="blog/generic-parallel-fp/index.html#286" class="Generalizable">𝓁</a><a id="8437" class="Symbol">)</a> <a id="8439" class="Symbol">:</a> <a id="8441" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8445" class="Symbol">(</a><a id="8446" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="8451" href="blog/generic-parallel-fp/index.html#8428" class="Bound">𝓁</a><a id="8452" class="Symbol">)</a> <a id="8454" class="Keyword">where</a>
  <a id="8462" class="Keyword">field</a>
    <a id="Functor.fmap"></a><a id="8472" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="8477" class="Symbol">:</a> <a id="8479" class="Symbol">{</a><a id="8480" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8482" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a> <a id="8484" class="Symbol">:</a> <a id="8486" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8490" href="blog/generic-parallel-fp/index.html#8428" class="Bound">𝓁</a><a id="8491" class="Symbol">}</a> <a id="8493" class="Symbol">→</a> <a id="8495" class="Symbol">(</a><a id="8496" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8498" class="Symbol">→</a> <a id="8500" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a><a id="8501" class="Symbol">)</a> <a id="8503" class="Symbol">→</a> <a id="8505" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8507" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8509" class="Symbol">→</a> <a id="8511" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8513" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a>

<a id="8516" class="Keyword">record</a> <a id="LScan"></a><a id="8523" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="8529" class="Symbol">(</a><a id="8530" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8532" class="Symbol">:</a> <a id="8534" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8538" class="Symbol">→</a> <a id="8540" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="8543" class="Symbol">)</a> <a id="8545" class="Symbol">:</a> <a id="8547" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="8552" class="Keyword">where</a>
  <a id="8560" class="Keyword">field</a>
    <a id="8570" class="Keyword">overlap</a> <a id="8578" class="Symbol">⦃</a> <a id="LScan.func"></a><a id="8580" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="8585" class="Symbol">⦄</a> <a id="8587" class="Symbol">:</a> <a id="8589" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="8597" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a>
    <a id="LScan.lscan"></a><a id="8603" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="8609" class="Symbol">:</a> <a id="8611" class="Symbol">⦃</a> <a id="8613" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="8620" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8622" class="Symbol">⦄</a> <a id="8624" class="Symbol">→</a> <a id="8626" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8628" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8630" class="Symbol">→</a> <a id="8632" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8634" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8636" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="8638" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>

<a id="8641" class="Keyword">open</a> <a id="8646" href="blog/generic-parallel-fp/index.html#8411" class="Module">Functor</a> <a id="8654" class="Symbol">⦃</a>  <a id="8657" class="Symbol">...</a>  <a id="8662" class="Symbol">⦄</a>
<a id="8664" class="Keyword">open</a> <a id="8669" href="blog/generic-parallel-fp/index.html#8523" class="Module">LScan</a> <a id="8675" class="Symbol">⦃</a> <a id="8677" class="Symbol">...</a> <a id="8681" class="Symbol">⦄</a>
</pre>
<p>What’s with the type of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span>? This thing is an exclusive scan, so the first element is always <span class="Agda"><a href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a></span>, and thus the last elemenet is always returned as <span class="Agda"><a href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a></span> of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span>.</p>
<p>We need to implement <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> for each <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>ation, and because there is no global coherence requirement in Agda, we can define our <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a></span> instances at the same time.</p>
<p>The simplest case is void which we can scan because we have a <span class="Agda"><a href="Data.Empty.html#526" class="Datatype">⊥</a></span> in negative position:</p>
<pre class="Agda"><a id="9189" class="Keyword">instance</a>
  <a id="lV"></a><a id="9200" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9203" class="Symbol">:</a> <a id="9205" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9211" class="Symbol">(\</a><a id="9213" href="blog/generic-parallel-fp/index.html#9213" class="Bound">a</a> <a id="9215" class="Symbol">→</a> <a id="9217" href="Data.Empty.html#526" class="Datatype">⊥</a><a id="9218" class="Symbol">)</a>
  <a id="9222" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9225" class="Symbol">.</a><a id="9226" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9231" class="Symbol">.</a><a id="9232" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9237" href="blog/generic-parallel-fp/index.html#9237" class="Bound">f</a> <a id="9239" href="blog/generic-parallel-fp/index.html#9239" class="Bound">x</a> <a id="9241" class="Symbol">=</a> <a id="9243" href="Data.Empty.html#628" class="Function">⊥-elim</a> <a id="9250" href="blog/generic-parallel-fp/index.html#9239" class="Bound">x</a>
  <a id="9254" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9257" class="Symbol">.</a><a id="9258" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9264" class="Symbol">()</a>
</pre>
<p><span class="Agda"><a href="Agda.Builtin.Unit.html#164" class="Record">⊤</a></span> is also trivial. Notice that there isn’t any <code>a</code> inside of it, so our final accumulated value must be <span class="Agda"><a href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a></span>:</p>
<pre class="Agda">  <a id="lU"></a><a id="9409" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9412" class="Symbol">:</a> <a id="9414" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9420" class="Symbol">(\</a><a id="9422" href="blog/generic-parallel-fp/index.html#9422" class="Bound">a</a> <a id="9424" class="Symbol">→</a> <a id="9426" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="9427" class="Symbol">)</a>
  <a id="9431" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9434" class="Symbol">.</a><a id="9435" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9440" class="Symbol">.</a><a id="9441" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9446" href="blog/generic-parallel-fp/index.html#9446" class="Bound">f</a> <a id="9448" href="blog/generic-parallel-fp/index.html#9448" class="Bound">x</a> <a id="9450" class="Symbol">=</a> <a id="9452" href="blog/generic-parallel-fp/index.html#9448" class="Bound">x</a>
  <a id="9456" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9459" class="Symbol">.</a><a id="9460" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9466" href="blog/generic-parallel-fp/index.html#9466" class="Bound">x</a> <a id="9468" class="Symbol">=</a> <a id="9470" href="blog/generic-parallel-fp/index.html#9466" class="Bound">x</a> <a id="9472" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9474" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
</pre>
<p>The identity functor is also trivial. Except this time, we <em>do</em> have a result, so it becomes the accumulated value, and we replace it with how much we’ve scaned thus far (nothing):</p>
<pre class="Agda">  <a id="lP"></a><a id="9674" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9677" class="Symbol">:</a> <a id="9679" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9685" class="Symbol">(\</a><a id="9687" href="blog/generic-parallel-fp/index.html#9687" class="Bound">a</a> <a id="9689" class="Symbol">→</a> <a id="9691" href="blog/generic-parallel-fp/index.html#9687" class="Bound">a</a><a id="9692" class="Symbol">)</a>
  <a id="9696" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9699" class="Symbol">.</a><a id="9700" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9705" class="Symbol">.</a><a id="9706" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9711" href="blog/generic-parallel-fp/index.html#9711" class="Bound">f</a> <a id="9713" class="Symbol">=</a> <a id="9715" href="blog/generic-parallel-fp/index.html#9711" class="Bound">f</a>
  <a id="9719" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9722" class="Symbol">.</a><a id="9723" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9729" href="blog/generic-parallel-fp/index.html#9729" class="Bound">x</a> <a id="9731" class="Symbol">=</a> <a id="9733" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a> <a id="9740" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9742" href="blog/generic-parallel-fp/index.html#9729" class="Bound">x</a>
</pre>
<p>Coproducts are uninteresting; we merely lift the tag:</p>
<pre class="Agda">  <a id="l+"></a><a id="9810" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9813" class="Symbol">:</a> <a id="9815" class="Symbol">⦃</a> <a id="9817" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9823" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="9825" class="Symbol">⦄</a> <a id="9827" class="Symbol">→</a> <a id="9829" class="Symbol">⦃</a> <a id="9831" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9837" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="9839" class="Symbol">⦄</a> <a id="9841" class="Symbol">→</a> <a id="9843" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9849" class="Symbol">(\</a><a id="9851" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a> <a id="9853" class="Symbol">→</a> <a id="9855" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="9857" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a> <a id="9859" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="9861" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="9863" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a><a id="9864" class="Symbol">)</a>
  <a id="9868" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9871" class="Symbol">.</a><a id="9872" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9877" class="Symbol">.</a><a id="9878" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9883" href="blog/generic-parallel-fp/index.html#9883" class="Bound">f</a> <a id="9885" class="Symbol">(</a><a id="9886" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="9891" href="blog/generic-parallel-fp/index.html#9891" class="Bound">y</a><a id="9892" class="Symbol">)</a> <a id="9894" class="Symbol">=</a> <a id="9896" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="9901" class="Symbol">(</a><a id="9902" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9907" href="blog/generic-parallel-fp/index.html#9883" class="Bound">f</a> <a id="9909" href="blog/generic-parallel-fp/index.html#9891" class="Bound">y</a><a id="9910" class="Symbol">)</a>
  <a id="9914" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9917" class="Symbol">.</a><a id="9918" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9923" class="Symbol">.</a><a id="9924" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9929" href="blog/generic-parallel-fp/index.html#9929" class="Bound">f</a> <a id="9931" class="Symbol">(</a><a id="9932" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="9937" href="blog/generic-parallel-fp/index.html#9937" class="Bound">y</a><a id="9938" class="Symbol">)</a> <a id="9940" class="Symbol">=</a> <a id="9942" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="9947" class="Symbol">(</a><a id="9948" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9953" href="blog/generic-parallel-fp/index.html#9929" class="Bound">f</a> <a id="9955" href="blog/generic-parallel-fp/index.html#9937" class="Bound">y</a><a id="9956" class="Symbol">)</a>
  <a id="9960" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9963" class="Symbol">.</a><a id="9964" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9970" class="Symbol">(</a><a id="9971" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="9976" href="blog/generic-parallel-fp/index.html#9976" class="Bound">x</a><a id="9977" class="Symbol">)</a> <a id="9979" class="Symbol">=</a>
    <a id="9985" class="Keyword">let</a> <a id="9989" href="blog/generic-parallel-fp/index.html#9989" class="Bound">x&#39;</a> <a id="9992" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9994" href="blog/generic-parallel-fp/index.html#9994" class="Bound">y</a> <a id="9996" class="Symbol">=</a> <a id="9998" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10004" href="blog/generic-parallel-fp/index.html#9976" class="Bound">x</a>
     <a id="10011" class="Keyword">in</a> <a id="10014" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="10019" href="blog/generic-parallel-fp/index.html#9989" class="Bound">x&#39;</a> <a id="10022" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10024" href="blog/generic-parallel-fp/index.html#9994" class="Bound">y</a>
  <a id="10028" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="10031" class="Symbol">.</a><a id="10032" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10038" class="Symbol">(</a><a id="10039" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="10044" href="blog/generic-parallel-fp/index.html#10044" class="Bound">x</a><a id="10045" class="Symbol">)</a> <a id="10047" class="Symbol">=</a>
    <a id="10053" class="Keyword">let</a> <a id="10057" href="blog/generic-parallel-fp/index.html#10057" class="Bound">x&#39;</a> <a id="10060" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10062" href="blog/generic-parallel-fp/index.html#10062" class="Bound">y</a> <a id="10064" class="Symbol">=</a> <a id="10066" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10072" href="blog/generic-parallel-fp/index.html#10044" class="Bound">x</a>
     <a id="10079" class="Keyword">in</a> <a id="10082" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="10087" href="blog/generic-parallel-fp/index.html#10057" class="Bound">x&#39;</a> <a id="10090" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10092" href="blog/generic-parallel-fp/index.html#10062" class="Bound">y</a>
</pre>
<p>And then we come to the interesting cases. To scan the product of <code>F</code> and <code>G</code>, we notice that every left scan of <code>F</code> is a prefix of <code>F × G</code> (because <code>F</code> is on the left.) Thus, we can use <code>lscan F</code> directly in the result, and need only adjust the results of <code>lscan G</code> with the accumulated value from <code>F</code>:</p>
<pre class="Agda">  <a id="l*"></a><a id="10410" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10413" class="Symbol">:</a> <a id="10415" class="Symbol">⦃</a> <a id="10417" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10423" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="10425" class="Symbol">⦄</a> <a id="10427" class="Symbol">→</a> <a id="10429" class="Symbol">⦃</a> <a id="10431" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10437" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="10439" class="Symbol">⦄</a> <a id="10441" class="Symbol">→</a> <a id="10443" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10449" class="Symbol">(\</a><a id="10451" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a> <a id="10453" class="Symbol">→</a> <a id="10455" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="10457" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a> <a id="10459" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="10461" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="10463" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a><a id="10464" class="Symbol">)</a>
  <a id="10468" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10471" class="Symbol">.</a><a id="10472" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="10477" class="Symbol">.</a><a id="10478" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10483" href="blog/generic-parallel-fp/index.html#10483" class="Bound">f</a> <a id="10485" href="blog/generic-parallel-fp/index.html#10485" class="Bound">x</a> <a id="10487" class="Symbol">.</a><a id="10488" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="10494" class="Symbol">=</a> <a id="10496" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10501" href="blog/generic-parallel-fp/index.html#10483" class="Bound">f</a> <a id="10503" class="Symbol">(</a><a id="10504" href="blog/generic-parallel-fp/index.html#10485" class="Bound">x</a> <a id="10506" class="Symbol">.</a><a id="10507" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="10512" class="Symbol">)</a>
  <a id="10516" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10519" class="Symbol">.</a><a id="10520" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="10525" class="Symbol">.</a><a id="10526" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10531" href="blog/generic-parallel-fp/index.html#10531" class="Bound">f</a> <a id="10533" href="blog/generic-parallel-fp/index.html#10533" class="Bound">x</a> <a id="10535" class="Symbol">.</a><a id="10536" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a> <a id="10542" class="Symbol">=</a> <a id="10544" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10549" href="blog/generic-parallel-fp/index.html#10531" class="Bound">f</a> <a id="10551" class="Symbol">(</a><a id="10552" href="blog/generic-parallel-fp/index.html#10533" class="Bound">x</a> <a id="10554" class="Symbol">.</a><a id="10555" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="10560" class="Symbol">)</a>
  <a id="10564" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10567" class="Symbol">.</a><a id="10568" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10574" class="Symbol">(</a><a id="10575" href="blog/generic-parallel-fp/index.html#10575" class="Bound">f-in</a> <a id="10580" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10582" href="blog/generic-parallel-fp/index.html#10582" class="Bound">g-in</a><a id="10586" class="Symbol">)</a> <a id="10588" class="Symbol">=</a>
    <a id="10594" class="Keyword">let</a> <a id="10598" href="blog/generic-parallel-fp/index.html#10598" class="Bound">f-out</a> <a id="10604" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10606" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10612" class="Symbol">=</a> <a id="10614" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10620" href="blog/generic-parallel-fp/index.html#10575" class="Bound">f-in</a>
        <a id="10633" href="blog/generic-parallel-fp/index.html#10633" class="Bound">g-out</a> <a id="10639" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10641" href="blog/generic-parallel-fp/index.html#10641" class="Bound">g-acc</a> <a id="10647" class="Symbol">=</a> <a id="10649" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10655" href="blog/generic-parallel-fp/index.html#10582" class="Bound">g-in</a>
     <a id="10665" class="Keyword">in</a> <a id="10668" class="Symbol">(</a><a id="10669" href="blog/generic-parallel-fp/index.html#10598" class="Bound">f-out</a> <a id="10675" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10677" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10682" class="Symbol">(</a><a id="10683" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10689" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;_</a><a id="10692" class="Symbol">)</a> <a id="10694" href="blog/generic-parallel-fp/index.html#10633" class="Bound">g-out</a><a id="10699" class="Symbol">)</a> <a id="10701" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10703" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10709" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="10712" href="blog/generic-parallel-fp/index.html#10641" class="Bound">g-acc</a>
</pre>
<p><span class="Agda"><a href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a></span> is what makes the whole algorithm parallel. It says we can scan <code>F</code> and <code>G</code> in parallel, and need only a single join node at the end to stick <code>f-acc &lt;&gt;_</code> on at the end. This parallelism is visible in the <code>let</code> expression, where there is no data dependency between the two bindings.</p>
<p>Our final generic instance of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> is over composition. Howevef, we can’t implement <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> for every composition of functors, since we require the ability to “zip” two functors together. The paper is pretty cagey about exactly what <code>Zip</code> is, but after some sleuthing, I think it’s this:</p>
<pre class="Agda"><a id="11328" class="Keyword">record</a> <a id="Zip"></a><a id="11335" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="11339" class="Symbol">(</a><a id="11340" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11342" class="Symbol">:</a> <a id="11344" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11348" class="Symbol">→</a> <a id="11350" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="11353" class="Symbol">)</a> <a id="11355" class="Symbol">:</a> <a id="11357" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="11362" class="Keyword">where</a>
  <a id="11370" class="Keyword">field</a>
    <a id="11380" class="Keyword">overlap</a> <a id="11388" class="Symbol">⦃</a> <a id="Zip.func"></a><a id="11390" href="blog/generic-parallel-fp/index.html#11390" class="Field">func</a> <a id="11395" class="Symbol">⦄</a> <a id="11397" class="Symbol">:</a> <a id="11399" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="11407" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a>
    <a id="Zip.zip"></a><a id="11413" href="blog/generic-parallel-fp/index.html#11413" class="Field">zip</a> <a id="11417" class="Symbol">:</a> <a id="11419" class="Symbol">{</a><a id="11420" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11422" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a> <a id="11424" class="Symbol">:</a> <a id="11426" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="11429" class="Symbol">}</a> <a id="11431" class="Symbol">→</a> <a id="11433" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11435" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11437" class="Symbol">→</a> <a id="11439" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11441" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a> <a id="11443" class="Symbol">→</a> <a id="11445" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11447" class="Symbol">(</a><a id="11448" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11450" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="11452" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a><a id="11453" class="Symbol">)</a>
<a id="11455" class="Keyword">open</a> <a id="11460" href="blog/generic-parallel-fp/index.html#11335" class="Module">Zip</a> <a id="11464" class="Symbol">⦃</a> <a id="11466" class="Symbol">...</a> <a id="11470" class="Symbol">⦄</a>
</pre>
<p>That looks a lot like being an applicative, but it’s missing <code>pure</code> and has some weird idempotent laws that are not particularly relevant today. We can define some helper functions as well:</p>
<pre class="Agda"><a id="zipWith"></a><a id="11674" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="11682" class="Symbol">:</a> <a id="11684" class="Symbol">∀</a> <a id="11686" class="Symbol">{</a><a id="11687" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11689" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11691" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a><a id="11692" class="Symbol">}</a> <a id="11694" class="Symbol">→</a> <a id="11696" class="Symbol">⦃</a> <a id="11698" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="11702" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11704" class="Symbol">⦄</a> <a id="11706" class="Symbol">→</a> <a id="11708" class="Symbol">(</a><a id="11709" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11711" class="Symbol">→</a> <a id="11713" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11715" class="Symbol">→</a> <a id="11717" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a><a id="11718" class="Symbol">)</a> <a id="11720" class="Symbol">→</a> <a id="11722" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11724" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11726" class="Symbol">→</a> <a id="11728" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11730" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11732" class="Symbol">→</a> <a id="11734" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11736" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a>
<a id="11738" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="11746" href="blog/generic-parallel-fp/index.html#11746" class="Bound">f</a> <a id="11748" href="blog/generic-parallel-fp/index.html#11748" class="Bound">fa</a> <a id="11751" href="blog/generic-parallel-fp/index.html#11751" class="Bound">fb</a> <a id="11754" class="Symbol">=</a> <a id="11756" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11761" class="Symbol">(</a><a id="11762" href="Data.Product.html#3422" class="Function">uncurry</a> <a id="11770" href="blog/generic-parallel-fp/index.html#11746" class="Bound">f</a><a id="11771" class="Symbol">)</a> <a id="11773" class="Symbol">(</a><a id="11774" href="blog/generic-parallel-fp/index.html#11413" class="Field">zip</a> <a id="11778" href="blog/generic-parallel-fp/index.html#11748" class="Bound">fa</a> <a id="11781" href="blog/generic-parallel-fp/index.html#11751" class="Bound">fb</a><a id="11783" class="Symbol">)</a>

<a id="unzip"></a><a id="11786" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="11792" class="Symbol">:</a> <a id="11794" class="Symbol">⦃</a> <a id="11796" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="11804" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11806" class="Symbol">⦄</a> <a id="11808" class="Symbol">→</a> <a id="11810" class="Symbol">{</a><a id="11811" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11813" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a> <a id="11815" class="Symbol">:</a> <a id="11817" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="11820" class="Symbol">}</a> <a id="11822" class="Symbol">→</a> <a id="11824" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11826" class="Symbol">(</a><a id="11827" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11829" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="11831" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a><a id="11832" class="Symbol">)</a> <a id="11834" class="Symbol">→</a> <a id="11836" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11838" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11840" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="11842" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11844" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a>
<a id="11846" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="11852" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a> <a id="11854" class="Symbol">=</a> <a id="11856" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11861" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="11867" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a> <a id="11869" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11871" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11876" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a> <a id="11882" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a>
</pre>
<p>Armed with all of this, we can give an implementation of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span> over functor composition. The idea is to <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span> each inner functor, which gives us an <code>G (F A × A)</code>. We can then <span class="Agda"><a href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a></span> that, whose second projection is then the totals of each inner scan. If we scan these <em>totals</em>, we’ll get a running scan for the whole thing; and all that’s left is to adjust each.</p>
<!--
<pre class="Agda"><a id="12288" class="Keyword">instance</a>
  <a id="composeFunc"></a><a id="12299" href="blog.generic-parallel-fp.html#12299" class="Function">composeFunc</a> <a id="12311" class="Symbol">:</a> <a id="12313" class="Symbol">⦃</a> <a id="12315" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12323" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12325" class="Symbol">⦄</a> <a id="12327" class="Symbol">→</a> <a id="12329" class="Symbol">⦃</a> <a id="12331" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12339" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12341" class="Symbol">⦄</a> <a id="12343" class="Symbol">→</a> <a id="12345" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12353" class="Symbol">(</a><a id="12354" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="12362" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12364" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="12365" class="Symbol">)</a>
  <a id="12369" href="blog.generic-parallel-fp.html#12299" class="Function">composeFunc</a> <a id="12381" class="Symbol">.</a><a id="12382" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12387" href="blog.generic-parallel-fp.html#12387" class="Bound">f</a> <a id="12389" class="Symbol">(</a><a id="12390" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="12398" href="blog.generic-parallel-fp.html#12398" class="Bound">x</a><a id="12399" class="Symbol">)</a> <a id="12401" class="Symbol">.</a><a id="12402" href="blog.generic-parallel-fp.html#6150" class="Field">composed</a> <a id="12411" class="Symbol">=</a> <a id="12413" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12418" class="Symbol">(</a><a id="12419" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12424" href="blog.generic-parallel-fp.html#12387" class="Bound">f</a><a id="12425" class="Symbol">)</a> <a id="12427" href="blog.generic-parallel-fp.html#12398" class="Bound">x</a>
</pre>-->
<pre class="Agda"><a id="12442" class="Keyword">instance</a>
  <a id="l∘"></a><a id="12453" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12456" class="Symbol">:</a> <a id="12458" class="Symbol">⦃</a> <a id="12460" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12466" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="12468" class="Symbol">⦄</a> <a id="12470" class="Symbol">→</a> <a id="12472" class="Symbol">⦃</a> <a id="12474" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12480" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12482" class="Symbol">⦄</a> <a id="12484" class="Symbol">→</a> <a id="12486" class="Symbol">⦃</a> <a id="12488" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="12492" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12494" class="Symbol">⦄</a> <a id="12496" class="Symbol">→</a> <a id="12498" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12504" class="Symbol">(</a><a id="12505" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="12513" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12515" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a><a id="12516" class="Symbol">)</a>
  <a id="12520" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12523" class="Symbol">.</a><a id="12524" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="12529" class="Symbol">.</a><a id="12530" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12535" href="blog/generic-parallel-fp/index.html#12535" class="Bound">f</a> <a id="12537" class="Symbol">=</a> <a id="12539" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12544" href="blog/generic-parallel-fp/index.html#12535" class="Bound">f</a>
  <a id="12548" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12551" class="Symbol">.</a><a id="12552" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12558" class="Symbol">(</a><a id="12559" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a> <a id="12567" href="blog/generic-parallel-fp/index.html#12567" class="Bound">gfa</a><a id="12570" class="Symbol">)</a> <a id="12572" class="Symbol">=</a>
    <a id="12578" class="Keyword">let</a> <a id="12582" href="blog/generic-parallel-fp/index.html#12582" class="Bound">gfa&#39;</a> <a id="12587" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12589" href="blog/generic-parallel-fp/index.html#12589" class="Bound">tots</a> <a id="12594" class="Symbol">=</a> <a id="12596" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="12602" class="Symbol">(</a><a id="12603" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12608" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12614" href="blog/generic-parallel-fp/index.html#12567" class="Bound">gfa</a><a id="12617" class="Symbol">)</a>
        <a id="12627" href="blog/generic-parallel-fp/index.html#12627" class="Bound">tots&#39;</a> <a id="12633" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12635" href="blog/generic-parallel-fp/index.html#12635" class="Bound">tot</a> <a id="12639" class="Symbol">=</a> <a id="12641" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12647" href="blog/generic-parallel-fp/index.html#12589" class="Bound">tots</a>
        <a id="12660" href="blog/generic-parallel-fp/index.html#12660" class="Bound">adjustl</a> <a id="12668" href="blog/generic-parallel-fp/index.html#12668" class="Bound">t</a> <a id="12670" class="Symbol">=</a> <a id="12672" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12677" class="Symbol">(</a><a id="12678" href="blog/generic-parallel-fp/index.html#12668" class="Bound">t</a> <a id="12680" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;_</a><a id="12683" class="Symbol">)</a>
    <a id="12689" class="Keyword">in</a> <a id="12692" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a> <a id="12700" class="Symbol">(</a><a id="12701" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="12709" href="blog/generic-parallel-fp/index.html#12660" class="Bound">adjustl</a> <a id="12717" href="blog/generic-parallel-fp/index.html#12627" class="Bound">tots&#39;</a> <a id="12723" href="blog/generic-parallel-fp/index.html#12582" class="Bound">gfa&#39;</a><a id="12727" class="Symbol">)</a> <a id="12729" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12731" href="blog/generic-parallel-fp/index.html#12635" class="Bound">tot</a>
</pre>
<!--
<pre class="Agda"><a id="12749" class="Keyword">instance</a>
  <a id="zI"></a><a id="12760" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12763" class="Symbol">:</a> <a id="12765" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12769" class="Symbol">(\</a><a id="12771" href="blog.generic-parallel-fp.html#12771" class="Bound">a</a> <a id="12773" class="Symbol">→</a> <a id="12775" href="blog.generic-parallel-fp.html#12771" class="Bound">a</a><a id="12776" class="Symbol">)</a>
  <a id="12780" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12783" class="Symbol">.</a><a id="12784" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="12789" class="Symbol">.</a><a id="12790" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12795" href="blog.generic-parallel-fp.html#12795" class="Bound">f</a> <a id="12797" href="blog.generic-parallel-fp.html#12797" class="Bound">a</a> <a id="12799" class="Symbol">=</a> <a id="12801" href="blog.generic-parallel-fp.html#12795" class="Bound">f</a> <a id="12803" href="blog.generic-parallel-fp.html#12797" class="Bound">a</a>
  <a id="12807" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12810" class="Symbol">.</a><a id="12811" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12815" href="blog.generic-parallel-fp.html#12815" class="Bound">a</a> <a id="12817" href="blog.generic-parallel-fp.html#12817" class="Bound">b</a> <a id="12819" class="Symbol">=</a> <a id="12821" href="blog.generic-parallel-fp.html#12815" class="Bound">a</a> <a id="12823" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12825" href="blog.generic-parallel-fp.html#12817" class="Bound">b</a>

  <a id="z*"></a><a id="12830" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12833" class="Symbol">:</a> <a id="12835" class="Symbol">⦃</a> <a id="12837" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12841" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12843" class="Symbol">⦄</a> <a id="12845" class="Symbol">→</a> <a id="12847" class="Symbol">⦃</a> <a id="12849" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12853" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12855" class="Symbol">⦄</a> <a id="12857" class="Symbol">→</a> <a id="12859" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12863" class="Symbol">(\</a><a id="12865" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a> <a id="12867" class="Symbol">→</a> <a id="12869" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12871" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a> <a id="12873" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="12875" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12877" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a><a id="12878" class="Symbol">)</a>
  <a id="12882" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12885" class="Symbol">.</a><a id="12886" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="12891" class="Symbol">.</a><a id="12892" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12897" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12899" class="Symbol">(</a><a id="12900" href="blog.generic-parallel-fp.html#12900" class="Bound">x</a> <a id="12902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12904" href="blog.generic-parallel-fp.html#12904" class="Bound">y</a><a id="12905" class="Symbol">)</a> <a id="12907" class="Symbol">=</a> <a id="12909" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12914" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12916" href="blog.generic-parallel-fp.html#12900" class="Bound">x</a> <a id="12918" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12920" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12925" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12927" href="blog.generic-parallel-fp.html#12904" class="Bound">y</a>
  <a id="12931" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12934" class="Symbol">.</a><a id="12935" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12939" class="Symbol">(</a><a id="12940" href="blog.generic-parallel-fp.html#12940" class="Bound">fa</a> <a id="12943" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12945" href="blog.generic-parallel-fp.html#12945" class="Bound">ga</a><a id="12947" class="Symbol">)</a> <a id="12949" class="Symbol">(</a><a id="12950" href="blog.generic-parallel-fp.html#12950" class="Bound">fb</a> <a id="12953" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12955" href="blog.generic-parallel-fp.html#12955" class="Bound">gb</a><a id="12957" class="Symbol">)</a> <a id="12959" class="Symbol">=</a> <a id="12961" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12965" href="blog.generic-parallel-fp.html#12940" class="Bound">fa</a> <a id="12968" href="blog.generic-parallel-fp.html#12950" class="Bound">fb</a> <a id="12971" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12973" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12977" href="blog.generic-parallel-fp.html#12945" class="Bound">ga</a> <a id="12980" href="blog.generic-parallel-fp.html#12955" class="Bound">gb</a>

  <a id="z∘"></a><a id="12986" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="12989" class="Symbol">:</a> <a id="12991" class="Symbol">⦃</a> <a id="12993" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12997" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12999" class="Symbol">⦄</a> <a id="13001" class="Symbol">→</a> <a id="13003" class="Symbol">⦃</a> <a id="13005" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="13009" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13011" class="Symbol">⦄</a> <a id="13013" class="Symbol">→</a> <a id="13015" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="13019" class="Symbol">(</a><a id="13020" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="13028" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13030" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="13031" class="Symbol">)</a>
  <a id="13035" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="13038" class="Symbol">.</a><a id="13039" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="13044" class="Symbol">.</a><a id="13045" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13050" href="blog.generic-parallel-fp.html#13050" class="Bound">f</a> <a id="13052" class="Symbol">=</a> <a id="13054" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13059" href="blog.generic-parallel-fp.html#13050" class="Bound">f</a>
  <a id="13063" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="13066" class="Symbol">.</a><a id="13067" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="13071" class="Symbol">(</a><a id="13072" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13080" href="blog.generic-parallel-fp.html#13080" class="Bound">fa</a><a id="13082" class="Symbol">)</a> <a id="13084" class="Symbol">(</a><a id="13085" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13093" href="blog.generic-parallel-fp.html#13093" class="Bound">ga</a><a id="13095" class="Symbol">)</a> <a id="13097" class="Symbol">=</a>
    <a id="13103" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13111" class="Symbol">(</a><a id="13112" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13117" class="Symbol">(</a><a id="13118" href="Data.Product.html#3422" class="Function">uncurry</a> <a id="13126" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a><a id="13129" class="Symbol">)</a> <a id="13131" class="Symbol">(</a><a id="13132" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="13136" href="blog.generic-parallel-fp.html#13080" class="Bound">fa</a> <a id="13139" href="blog.generic-parallel-fp.html#13093" class="Bound">ga</a><a id="13141" class="Symbol">))</a>
</pre>-->
<p>And we’re done! We now have an algorithm defined piece-wise over the fundamental ADT building blocks. Let’s put it to use.</p>
<h2 id="dividing-and-conquering"><a href="#dividing-and-conquering" class="header-link">Dividing and Conquering<span class="header-link-emoji">🔗</span></a></h2>
<p>Let’s pretend that <span class="Agda"><a href="Data.Vec.Base.html#998" class="Datatype">Vec</a></span>s are random access arrays. We’d like to be able to build array algorithms out of our algorithmic building blocks. To that end, we can make a typeclass corresponding to types that are isomorphic to arrays:</p>
<pre class="Agda"><a id="13548" class="Keyword">open</a> <a id="13553" class="Keyword">import</a> <a id="13560" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="13569" class="Keyword">open</a> <a id="13574" class="Keyword">import</a> <a id="13581" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="13590" class="Keyword">hiding</a> <a id="13597" class="Symbol">(</a><a id="13598" href="Data.Vec.Base.html#3897" class="Function">zip</a><a id="13601" class="Symbol">;</a> <a id="13603" href="Data.Vec.Base.html#3964" class="Function">unzip</a><a id="13608" class="Symbol">;</a> <a id="13610" href="Data.Vec.Base.html#3418" class="Function">zipWith</a><a id="13617" class="Symbol">)</a>

<a id="13620" class="Keyword">record</a> <a id="ArrayIso"></a><a id="13627" href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a> <a id="13636" class="Symbol">(</a><a id="13637" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13639" class="Symbol">:</a> <a id="13641" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="13645" class="Symbol">→</a> <a id="13647" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="13650" class="Symbol">)</a> <a id="13652" class="Symbol">:</a> <a id="13654" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="13659" class="Keyword">where</a>
  <a id="13667" class="Keyword">field</a>
    <a id="ArrayIso.Size"></a><a id="13677" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="13682" class="Symbol">:</a> <a id="13684" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
    <a id="ArrayIso.deserialize"></a><a id="13690" href="blog/generic-parallel-fp/index.html#13690" class="Field">deserialize</a> <a id="13702" class="Symbol">:</a> <a id="13704" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="13708" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13710" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="13715" class="Symbol">→</a> <a id="13717" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13719" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
    <a id="ArrayIso.serialize"></a><a id="13725" href="blog/generic-parallel-fp/index.html#13725" class="Field">serialize</a> <a id="13735" class="Symbol">:</a> <a id="13737" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13739" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13741" class="Symbol">→</a> <a id="13743" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="13747" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13749" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a>
    <a id="13758" class="Comment">-- also prove it&#39;s an iso</a>

<a id="13785" class="Keyword">open</a> <a id="13790" href="blog/generic-parallel-fp/index.html#13627" class="Module">ArrayIso</a> <a id="13799" class="Symbol">⦃</a> <a id="13801" class="Symbol">...</a> <a id="13805" class="Symbol">⦄</a>
</pre>
<!--
<pre class="Agda"><a id="13821" class="Keyword">instance</a>
  <a id="dU"></a><a id="13832" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13835" class="Symbol">:</a> <a id="13837" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13846" class="Symbol">(\</a><a id="13848" href="blog.generic-parallel-fp.html#13848" class="Bound">a</a> <a id="13850" class="Symbol">→</a> <a id="13852" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="13853" class="Symbol">)</a>
  <a id="13857" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13860" class="Symbol">.</a><a id="13861" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="13866" class="Symbol">=</a> <a id="13868" class="Number">0</a>
  <a id="13872" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13875" class="Symbol">.</a><a id="13876" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="13888" class="Symbol">_</a> <a id="13890" class="Symbol">=</a> <a id="13892" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
  <a id="13897" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13900" class="Symbol">.</a><a id="13901" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="13911" class="Symbol">_</a> <a id="13913" class="Symbol">=</a> <a id="13915" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>

  <a id="d*"></a><a id="13921" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="13924" class="Symbol">:</a> <a id="13926" class="Symbol">⦃</a> <a id="13928" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13937" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13939" class="Symbol">⦄</a> <a id="13941" class="Symbol">→</a> <a id="13943" class="Symbol">⦃</a> <a id="13945" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13954" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13956" class="Symbol">⦄</a> <a id="13958" class="Symbol">→</a> <a id="13960" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13969" class="Symbol">(\</a><a id="13971" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a> <a id="13973" class="Symbol">→</a> <a id="13975" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13977" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a> <a id="13979" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="13981" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13983" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a><a id="13984" class="Symbol">)</a>
  <a id="13988" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="13991" class="Symbol">⦃</a> <a id="13993" href="blog.generic-parallel-fp.html#13993" class="Bound">d-f</a> <a id="13997" class="Symbol">⦄</a> <a id="13999" class="Symbol">⦃</a> <a id="14001" href="blog.generic-parallel-fp.html#14001" class="Bound">d-g</a> <a id="14005" class="Symbol">⦄</a> <a id="14007" class="Symbol">.</a><a id="14008" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14013" class="Symbol">=</a> <a id="14015" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14020" class="Symbol">⦃</a> <a id="14022" href="blog.generic-parallel-fp.html#13993" class="Bound">d-f</a> <a id="14026" class="Symbol">⦄</a> <a id="14028" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14030" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14035" class="Symbol">⦃</a> <a id="14037" href="blog.generic-parallel-fp.html#14001" class="Bound">d-g</a> <a id="14041" class="Symbol">⦄</a>
  <a id="14045" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="14048" class="Symbol">⦃</a> <a id="14050" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14054" class="Symbol">⦄</a> <a id="14056" class="Symbol">⦃</a> <a id="14058" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14062" class="Symbol">⦄</a> <a id="14064" class="Symbol">.</a><a id="14065" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14077" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a> <a id="14079" class="Symbol">=</a>
    <a id="14085" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14097" class="Symbol">⦃</a> <a id="14099" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14103" class="Symbol">⦄</a> <a id="14105" class="Symbol">(</a><a id="14106" href="Data.Vec.Base.html#6461" class="Function">take</a> <a id="14111" class="Symbol">(</a><a id="14112" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14117" class="Symbol">⦃</a> <a id="14119" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14123" class="Symbol">⦄)</a> <a id="14126" class="Symbol">{</a><a id="14127" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14132" class="Symbol">⦃</a> <a id="14134" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14138" class="Symbol">⦄}</a> <a id="14141" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a><a id="14142" class="Symbol">)</a> <a id="14144" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a>
    <a id="14150" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14162" class="Symbol">⦃</a> <a id="14164" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14168" class="Symbol">⦄</a> <a id="14170" class="Symbol">(</a><a id="14171" href="Data.Vec.Base.html#6583" class="Function">drop</a> <a id="14176" class="Symbol">(</a><a id="14177" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14182" class="Symbol">⦃</a> <a id="14184" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14188" class="Symbol">⦄)</a> <a id="14191" class="Symbol">{</a><a id="14192" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14197" class="Symbol">⦃</a> <a id="14199" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14203" class="Symbol">⦄}</a> <a id="14206" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a><a id="14207" class="Symbol">)</a>
  <a id="14211" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="14214" class="Symbol">⦃</a> <a id="14216" href="blog.generic-parallel-fp.html#14216" class="Bound">d-f</a> <a id="14220" class="Symbol">⦄</a> <a id="14222" class="Symbol">⦃</a> <a id="14224" href="blog.generic-parallel-fp.html#14224" class="Bound">d-g</a> <a id="14228" class="Symbol">⦄</a> <a id="14230" class="Symbol">.</a><a id="14231" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14241" class="Symbol">(</a><a id="14242" href="blog.generic-parallel-fp.html#14242" class="Bound">f</a> <a id="14244" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14246" href="blog.generic-parallel-fp.html#14246" class="Bound">g</a><a id="14247" class="Symbol">)</a> <a id="14249" class="Symbol">=</a>
    <a id="14255" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14265" class="Symbol">⦃</a> <a id="14267" href="blog.generic-parallel-fp.html#14216" class="Bound">d-f</a> <a id="14271" class="Symbol">⦄</a> <a id="14273" href="blog.generic-parallel-fp.html#14242" class="Bound">f</a> <a id="14275" href="Data.Vec.Base.html#2709" class="Function Operator">++</a> <a id="14278" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14288" class="Symbol">⦃</a> <a id="14290" href="blog.generic-parallel-fp.html#14224" class="Bound">d-g</a> <a id="14294" class="Symbol">⦄</a> <a id="14296" href="blog.generic-parallel-fp.html#14246" class="Bound">g</a>

  <a id="dP"></a><a id="14301" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14304" class="Symbol">:</a> <a id="14306" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14315" class="Symbol">(\</a><a id="14317" href="blog.generic-parallel-fp.html#14317" class="Bound">a</a> <a id="14319" class="Symbol">→</a> <a id="14321" href="blog.generic-parallel-fp.html#14317" class="Bound">a</a><a id="14322" class="Symbol">)</a>
  <a id="14326" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14329" class="Symbol">.</a><a id="14330" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14335" class="Symbol">=</a> <a id="14337" class="Number">1</a>
  <a id="14341" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14344" class="Symbol">.</a><a id="14345" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14357" class="Symbol">(</a><a id="14358" href="blog.generic-parallel-fp.html#14358" class="Bound">x</a> <a id="14360" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="14362" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="14364" class="Symbol">)</a> <a id="14366" class="Symbol">=</a> <a id="14368" href="blog.generic-parallel-fp.html#14358" class="Bound">x</a>
  <a id="14372" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14375" class="Symbol">.</a><a id="14376" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14386" href="blog.generic-parallel-fp.html#14386" class="Bound">x</a> <a id="14388" class="Symbol">=</a> <a id="14390" href="blog.generic-parallel-fp.html#14386" class="Bound">x</a> <a id="14392" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="14394" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>

  <a id="d∘"></a><a id="14400" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14403" class="Symbol">:</a> <a id="14405" class="Symbol">⦃</a> <a id="14407" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14416" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="14418" class="Symbol">⦄</a> <a id="14420" class="Symbol">→</a> <a id="14422" class="Symbol">⦃</a> <a id="14424" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14433" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="14435" class="Symbol">⦄</a> <a id="14437" class="Symbol">→</a> <a id="14439" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14448" class="Symbol">(</a><a id="14449" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="14457" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="14459" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="14460" class="Symbol">)</a>
  <a id="14464" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14467" class="Symbol">⦃</a> <a id="14469" href="blog.generic-parallel-fp.html#14469" class="Bound">d-f</a> <a id="14473" class="Symbol">⦄</a> <a id="14475" class="Symbol">⦃</a> <a id="14477" href="blog.generic-parallel-fp.html#14477" class="Bound">d-g</a> <a id="14481" class="Symbol">⦄</a> <a id="14483" class="Symbol">.</a><a id="14484" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14489" class="Symbol">=</a> <a id="14491" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14496" class="Symbol">⦃</a> <a id="14498" href="blog.generic-parallel-fp.html#14469" class="Bound">d-f</a> <a id="14502" class="Symbol">⦄</a> <a id="14504" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="14506" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14511" class="Symbol">⦃</a> <a id="14513" href="blog.generic-parallel-fp.html#14477" class="Bound">d-g</a> <a id="14517" class="Symbol">⦄</a>
  <a id="14521" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14524" class="Symbol">⦃</a> <a id="14526" href="blog.generic-parallel-fp.html#14526" class="Bound">d-f</a> <a id="14530" class="Symbol">⦄</a> <a id="14532" class="Symbol">⦃</a> <a id="14534" href="blog.generic-parallel-fp.html#14534" class="Bound">d-g</a> <a id="14538" class="Symbol">⦄</a> <a id="14540" class="Symbol">.</a><a id="14541" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14553" href="blog.generic-parallel-fp.html#14553" class="Bound">x</a> <a id="14555" class="Symbol">=</a>
    <a id="14561" class="Keyword">let</a> <a id="14565" href="blog.generic-parallel-fp.html#14565" class="Bound">y</a> <a id="14567" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="14569" class="Symbol">_</a> <a id="14571" class="Symbol">=</a> <a id="14573" href="Data.Vec.Base.html#6705" class="Function">group</a> <a id="14579" class="Symbol">(</a><a id="14580" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14585" class="Symbol">⦃</a> <a id="14587" href="blog.generic-parallel-fp.html#14526" class="Bound">d-f</a> <a id="14591" class="Symbol">⦄)</a> <a id="14594" class="Symbol">_</a> <a id="14596" href="blog.generic-parallel-fp.html#14553" class="Bound">x</a>
     <a id="14603" class="Keyword">in</a> <a id="14606" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="14614" class="Symbol">(</a><a id="14615" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14627" class="Symbol">(</a><a id="14628" href="Data.Vec.Base.html#2580" class="Function">Data.Vec.map</a> <a id="14641" class="Symbol">(</a><a id="14642" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14654" class="Symbol">⦃</a> <a id="14656" href="blog.generic-parallel-fp.html#14534" class="Bound">d-g</a> <a id="14660" class="Symbol">⦄)</a> <a id="14663" href="blog.generic-parallel-fp.html#14565" class="Bound">y</a><a id="14664" class="Symbol">))</a>
  <a id="14669" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14672" class="Symbol">⦃</a> <a id="14674" href="blog.generic-parallel-fp.html#14674" class="Bound">d-f</a> <a id="14678" class="Symbol">⦄</a> <a id="14680" class="Symbol">⦃</a> <a id="14682" href="blog.generic-parallel-fp.html#14682" class="Bound">d-g</a> <a id="14686" class="Symbol">⦄</a> <a id="14688" class="Symbol">.</a><a id="14689" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14699" class="Symbol">(</a><a id="14700" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="14708" href="blog.generic-parallel-fp.html#14708" class="Bound">x</a><a id="14709" class="Symbol">)</a> <a id="14711" class="Symbol">=</a>
    <a id="14717" href="Data.Vec.Base.html#2813" class="Function">concat</a> <a id="14724" class="Symbol">(</a><a id="14725" href="Data.Vec.Base.html#2580" class="Function">Data.Vec.map</a> <a id="14738" class="Symbol">(</a><a id="14739" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14749" class="Symbol">⦃</a> <a id="14751" href="blog.generic-parallel-fp.html#14682" class="Bound">d-g</a> <a id="14755" class="Symbol">⦄)</a> <a id="14758" class="Symbol">(</a><a id="14759" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14769" class="Symbol">⦃</a> <a id="14771" href="blog.generic-parallel-fp.html#14674" class="Bound">d-f</a> <a id="14775" class="Symbol">⦄</a> <a id="14777" href="blog.generic-parallel-fp.html#14708" class="Bound">x</a><a id="14778" class="Symbol">))</a>
</pre>-->
<p>There are instances of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> for the functor building blocks (though none for <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">:+:</a></span> since arrays are big records.) We can now use an <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> and an <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> to get our desired parallel array algorithms:</p>
<pre class="Agda"><a id="genericScan"></a><a id="15033" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a>
    <a id="15049" class="Symbol">:</a> <a id="15051" class="Symbol">⦃</a> <a id="15053" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15060" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15062" class="Symbol">⦄</a>
    <a id="15068" class="Symbol">→</a> <a id="15070" class="Symbol">(</a><a id="15071" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a> <a id="15075" class="Symbol">:</a> <a id="15077" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a><a id="15080" class="Symbol">)</a>
    <a id="15086" class="Symbol">→</a> <a id="15088" class="Symbol">⦃</a> <a id="15090" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15092" class="Symbol">:</a> <a id="15094" href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a> <a id="15103" class="Symbol">(</a><a id="15104" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="15114" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a><a id="15117" class="Symbol">)</a> <a id="15119" class="Symbol">⦄</a>
    <a id="15125" class="Symbol">→</a> <a id="15127" class="Symbol">⦃</a> <a id="15129" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="15135" class="Symbol">(</a><a id="15136" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="15146" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a><a id="15149" class="Symbol">)</a> <a id="15151" class="Symbol">⦄</a>
    <a id="15157" class="Symbol">→</a> <a id="15159" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15163" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15165" class="Symbol">(</a><a id="15166" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="15171" class="Symbol">⦃</a> <a id="15173" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15175" class="Symbol">⦄)</a>
    <a id="15182" class="Symbol">→</a> <a id="15184" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15188" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15190" class="Symbol">(</a><a id="15191" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="15196" class="Symbol">⦃</a> <a id="15198" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15200" class="Symbol">⦄)</a> <a id="15203" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="15205" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15207" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15219" class="Symbol">_</a> <a id="15221" class="Symbol">⦃</a> <a id="15223" class="Argument">d</a> <a id="15225" class="Symbol">=</a> <a id="15227" href="blog/generic-parallel-fp/index.html#15227" class="Bound">d</a> <a id="15229" class="Symbol">⦄</a> <a id="15231" href="blog/generic-parallel-fp/index.html#15231" class="Bound">x</a> <a id="15233" class="Symbol">=</a>
  <a id="15237" class="Keyword">let</a> <a id="15241" href="blog/generic-parallel-fp/index.html#15241" class="Bound">res</a> <a id="15245" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15247" href="blog/generic-parallel-fp/index.html#15247" class="Bound">a</a> <a id="15249" class="Symbol">=</a> <a id="15251" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="15257" class="Symbol">(</a><a id="15258" href="blog/generic-parallel-fp/index.html#13690" class="Field">deserialize</a> <a id="15270" href="blog/generic-parallel-fp/index.html#15231" class="Bound">x</a><a id="15271" class="Symbol">)</a>
   <a id="15276" class="Keyword">in</a> <a id="15279" href="blog/generic-parallel-fp/index.html#13725" class="Field">serialize</a> <a id="15289" class="Symbol">⦃</a> <a id="15291" href="blog/generic-parallel-fp/index.html#15227" class="Bound">d</a> <a id="15293" class="Symbol">⦄</a> <a id="15295" href="blog/generic-parallel-fp/index.html#15241" class="Bound">res</a> <a id="15299" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15301" href="blog/generic-parallel-fp/index.html#15247" class="Bound">a</a>
</pre>
<p>I think this is the first truly dependent type I’ve ever written. We take a <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a></span> corresponding to how we’d like to divvy up the problem, and then see if the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span> of that has <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> instances, and then give back an algorithm that scans over arrays of the correct <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a></span>.</p>
<p>Finally we’re ready to try this out. We can give the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a></span> implementation from earlier:</p>
<pre class="Agda"><a id="▷_"></a><a id="15740" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷_</a> <a id="15743" class="Symbol">:</a> <a id="15745" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="15749" class="Symbol">→</a> <a id="15751" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
<a id="15755" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷_</a> <a id="15758" href="blog/generic-parallel-fp/index.html#15758" class="Bound">a</a> <a id="15760" class="Symbol">=</a> <a id="15762" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="15766" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="15770" href="blog/generic-parallel-fp/index.html#15758" class="Bound">a</a>

<a id="15773" href="blog/generic-parallel-fp/index.html#15773" class="Function">_</a> <a id="15775" class="Symbol">:</a> <a id="15777" class="Symbol">⦃</a> <a id="15779" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15786" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15788" class="Symbol">⦄</a> <a id="15790" class="Symbol">→</a> <a id="15792" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15796" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15798" class="Number">4</a> <a id="15800" class="Symbol">→</a> <a id="15802" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15806" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15808" class="Number">4</a> <a id="15810" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="15812" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15814" class="Symbol">_</a> <a id="15816" class="Symbol">=</a> <a id="15818" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15830" class="Symbol">(</a><a id="15831" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15833" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15835" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15837" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a><a id="15840" class="Symbol">)</a>
</pre>
<p>or the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a></span> instance:</p>
<pre class="Agda"><a id="_◁"></a><a id="15884" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">_◁</a> <a id="15887" class="Symbol">:</a> <a id="15889" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="15893" class="Symbol">→</a> <a id="15895" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
<a id="15899" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">_◁</a> <a id="15902" href="blog/generic-parallel-fp/index.html#15902" class="Bound">a</a> <a id="15904" class="Symbol">=</a> <a id="15906" href="blog/generic-parallel-fp/index.html#15902" class="Bound">a</a> <a id="15908" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="15912" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a>

<a id="15917" href="blog/generic-parallel-fp/index.html#15917" class="Function">_</a> <a id="15919" class="Symbol">:</a> <a id="15921" class="Symbol">⦃</a> <a id="15923" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15930" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15932" class="Symbol">⦄</a> <a id="15934" class="Symbol">→</a> <a id="15936" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15940" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15942" class="Number">4</a> <a id="15944" class="Symbol">→</a> <a id="15946" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="15950" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15952" class="Number">4</a> <a id="15954" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="15956" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15958" class="Symbol">_</a> <a id="15960" class="Symbol">=</a> <a id="15962" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15974" class="Symbol">(</a><a id="15975" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="15979" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="15981" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="15983" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a><a id="15984" class="Symbol">)</a>
</pre>
<p>But we can also come up with more interesting strategies as well. For example, we can divvy up the problem by left-associating the first half, and right-associating the second:</p>
<pre class="Agda"><a id="16173" href="blog/generic-parallel-fp/index.html#16173" class="Function">_</a> <a id="16175" class="Symbol">:</a> <a id="16177" class="Symbol">⦃</a> <a id="16179" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16186" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16188" class="Symbol">⦄</a> <a id="16190" class="Symbol">→</a> <a id="16192" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16196" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16198" class="Number">8</a> <a id="16200" class="Symbol">→</a> <a id="16202" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16206" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16208" class="Number">8</a> <a id="16210" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="16212" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="16214" class="Symbol">_</a> <a id="16216" class="Symbol">=</a> <a id="16218" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="16230" class="Symbol">((</a><a id="16232" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="16236" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="16238" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="16240" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a><a id="16241" class="Symbol">)</a> <a id="16243" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="16247" class="Symbol">(</a><a id="16248" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16250" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16252" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16254" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a><a id="16257" class="Symbol">))</a>
</pre>
<p>This one probably isn’t an <em>efficient</em> algorithm, but it’s cool that we can express such a thing so succinctly. Probably of more interest is a balanced tree over our array:</p>
<pre class="Agda"><a id="16443" href="blog/generic-parallel-fp/index.html#16443" class="Function">_</a> <a id="16445" class="Symbol">:</a> <a id="16447" class="Symbol">⦃</a> <a id="16449" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16456" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16458" class="Symbol">⦄</a> <a id="16460" class="Symbol">→</a> <a id="16462" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16466" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16468" class="Number">16</a> <a id="16471" class="Symbol">→</a> <a id="16473" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16477" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16479" class="Number">16</a> <a id="16482" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="16484" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="16486" class="Symbol">_</a> <a id="16488" class="Symbol">=</a> <a id="16490" class="Keyword">let</a> <a id="16494" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a> <a id="16498" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a> <a id="16500" class="Symbol">=</a> <a id="16502" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a> <a id="16504" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="16508" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a>
     <a id="16515" class="Keyword">in</a> <a id="16518" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="16530" class="Symbol">(</a><a id="16531" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16533" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16535" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16537" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16539" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="16543" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16545" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16547" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16549" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a><a id="16550" class="Symbol">)</a>
</pre>
<p>The balanced tree over products is interesting, but what if we make a balanced tree over <em>composition?</em> In essence, we can split the problem into chunks of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mo stretchy="false">(</mo></msup><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> amounts of work via <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a></span>:</p>
<pre class="Agda"><a id="16763" class="Symbol">{-#</a> <a id="16767" class="Keyword">NO_POSITIVITY_CHECK</a> <a id="16787" class="Symbol">#-}</a>
<a id="16791" class="Keyword">data</a> <a id="Bush"></a><a id="16796" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16801" class="Symbol">:</a> <a id="16803" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="16805" class="Symbol">→</a> <a id="16807" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="16811" class="Symbol">→</a> <a id="16813" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="16817" class="Keyword">where</a>
  <a id="Bush.twig"></a><a id="16825" href="blog/generic-parallel-fp/index.html#16825" class="InductiveConstructor">twig</a> <a id="16830" class="Symbol">:</a> <a id="16832" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16834" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="16836" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16838" class="Symbol">→</a> <a id="16840" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16845" class="Number">0</a> <a id="16847" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="Bush.bush"></a><a id="16851" href="blog/generic-parallel-fp/index.html#16851" class="InductiveConstructor">bush</a> <a id="16856" class="Symbol">:</a> <a id="16858" class="Symbol">{</a><a id="16859" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16861" class="Symbol">:</a> <a id="16863" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="16864" class="Symbol">}</a> <a id="16866" class="Symbol">→</a> <a id="16868" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16873" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16875" class="Symbol">(</a><a id="16876" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16881" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16883" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a><a id="16884" class="Symbol">)</a> <a id="16886" class="Symbol">→</a> <a id="16888" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16893" class="Symbol">(</a><a id="16894" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="16898" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a><a id="16899" class="Symbol">)</a> <a id="16901" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
</pre>
<p>Which we won’t use directly, but can use it’s <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a></span>:</p>
<pre class="Agda"><a id="16973" href="blog/generic-parallel-fp/index.html#16973" class="Function">_</a> <a id="16975" class="Symbol">:</a> <a id="16977" class="Symbol">⦃</a> <a id="16979" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16986" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16988" class="Symbol">⦄</a> <a id="16990" class="Symbol">→</a> <a id="16992" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16996" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16998" class="Number">16</a> <a id="17001" class="Symbol">→</a> <a id="17003" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="17007" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="17009" class="Number">16</a> <a id="17012" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="17014" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="17016" class="Symbol">_</a> <a id="17018" class="Symbol">=</a> <a id="17020" class="Keyword">let</a> <a id="17024" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17029" class="Symbol">=</a> <a id="17031" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="17035" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="17039" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a>
     <a id="17048" class="Keyword">in</a> <a id="17051" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="17063" class="Symbol">((</a><a id="17065" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17070" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17074" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a><a id="17078" class="Symbol">)</a> <a id="17080" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17084" class="Symbol">(</a><a id="17085" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17090" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17094" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a><a id="17098" class="Symbol">))</a>
</pre>
<p>The paper compares several of these strategies for dividing-and-conquering. In particular, it shows that we can minimize total work via a left-associated <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a></span> strategy, but maximize parallelism with a <em>right</em>-associated <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a></span>. And using the <code>Bush</code> from earlier, we can get a nice middle ground.</p>
<h2 id="very-quick-ffts"><a href="#very-quick-ffts" class="header-link">Very Quick FFTs<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper follows up, applying this approach to implementations of the fast fourier transform. There, the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a></span> approach gives constant factor improvments for both <em>work</em> and <em>parallelism,</em> compared to all previously known algorithms.</p>
<p>Results like these are strong evidence that Elliott is <em>actually onto something</em> with his seemingly crazy ideas that computation should be elegant and well principled. Giving significant constant factor improvements to well-known, extremely important algorithms <em>mostly for free</em> is a true superpower, and is worth taking extremely seriously.</p>
<h2 id="fighting-against-publication-bias"><a href="#fighting-against-publication-bias" class="header-link">Fighting Against Publication Bias<span class="header-link-emoji">🔗</span></a></h2>
<p>Andrew McKnight and I tried to use this same approach to get a nice algorithm for sorting, hoping that we could get well-known sorting algorithms to fall out as special cases of our more general functor building blocks. We completely failed on this front, namely because we couldn’t figure out how to give an instance for product types. Rather alarmingly, we’re not entirely sure <em>why</em> the approach failed there; maybe it was just not thinking hard enough.</p>
<p>Another plausible idea is that sorting requires branching, and that this approach only works for statically-known codepaths.</p>
<h2 id="future-work"><a href="#future-work" class="header-link">Future Work<span class="header-link-emoji">🔗</span></a></h2>
<p>Andrew and I spent a good chunk of the week thinking about this problem, and we figure there are solid odds that you could <em>automatically</em> discover these generic algorithmic building blocks from a well-known algorithm. Here’s the sketch:</p>
<p>Use the well-known algorithm as a specification, instantiate all parameters at small types and see if you can find instances of the algorithm for the functor building blocks that agree with the spec. It seems like you should be able to use factorization of the input to target which instances you’re looking for.</p>
<p>Of course, once you have the algorithmic building blocks, conventional search techniques can be used to optimize any particular goal you might have.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Lightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures</title>
      <id>blog/complexity-analysis/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/complexity-analysis/index.html'/>
      <published>2022-03-06</published>
      <updated>2022-03-06</updated>

      <content type="html">
        <![CDATA[
        <p>What a mouthful of a title! <a href="https://www.cse.chalmers.se/~nad/publications/danielsson-popl2008.pdf">LWTCAfPFDS</a> is our paper for the week, written by Nils Anders Danielsson. At a high level, the idea is to introduce a graded monad which counts computation steps, whose bind adds those steps together. By constructing our program in this monad, we can use the type-system to track its runtime asymptotics.</p>
<h2 id="core-definitions"><a href="#core-definitions" class="header-link">Core Definitions<span class="header-link-emoji">🔗</span></a></h2>
<p>We might as well dive in. Since all of this complexity analysis stuff shouldn’t <em>change</em> anything at runtime, we really only need to stick the analysis in the types, and can erase it all at runtime.</p>
<p>The paper thus presents its main tools in an <code>abstract</code> block, which is a new Agda feature for me. And wow, does Agda ever feel like it’s Haskell but from the future. An <code>abstract</code> block lets us give some definitions, which <em>inside</em> the <code>abstract</code> block can be normalized. But outside the block, they are opaque symbols that are just what they are. This is a delightful contrast to Haskell, where we need to play a game of making a new module, and carefully not exporting things in order to get the same behavior. And even then, in Haskell, we can’t give opaque <code>type</code> synonyms or anything like that.</p>
<p>Anyway, the main type in the paper is <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span>, which tracks how many computation steps are necessary to produce an eventual value:</p>
<!--
<pre class="Agda"><a id="1606" class="Symbol">{-#</a> <a id="1610" class="Keyword">OPTIONS</a> <a id="1618" class="Pragma">--rewriting</a> <a id="1630" class="Symbol">#-}</a>

<a id="1635" class="Keyword">module</a> <a id="1642" href="blog.complexity-analysis.html" class="Module">blog.complexity-analysis</a> <a id="1667" class="Keyword">where</a>

<a id="1674" class="Keyword">open</a> <a id="1679" class="Keyword">import</a> <a id="1686" href="Function.html" class="Module">Function</a>
<a id="1695" class="Keyword">open</a> <a id="1700" class="Keyword">import</a> <a id="1707" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="1716" class="Keyword">open</a> <a id="1721" class="Keyword">import</a> <a id="1728" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="1748" class="Keyword">open</a> <a id="1753" class="Keyword">import</a> <a id="1760" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="1770" class="Keyword">using</a> <a id="1776" class="Symbol">(</a><a id="1777" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1781" class="Symbol">;</a> <a id="1783" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="1787" class="Symbol">;</a> <a id="1789" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="1794" class="Symbol">)</a>
<a id="1796" class="Keyword">open</a> <a id="1801" class="Keyword">import</a> <a id="1808" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1846" class="Symbol">as</a> <a id="1849" class="Module">Eq</a>

<a id="1853" class="Keyword">open</a> <a id="1858" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a>

<a id="1862" class="Keyword">private</a> <a id="1870" class="Keyword">variable</a>
  <a id="1881" href="blog.complexity-analysis.html#1881" class="Generalizable">a</a> <a id="1883" href="blog.complexity-analysis.html#1883" class="Generalizable">b</a> <a id="1885" class="Symbol">:</a> <a id="1887" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1893" href="blog.complexity-analysis.html#1893" class="Generalizable">m</a> <a id="1895" href="blog.complexity-analysis.html#1895" class="Generalizable">n</a> <a id="1897" class="Symbol">:</a> <a id="1899" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
</pre>-->
<pre class="Agda"><a id="1914" class="Keyword">abstract</a>
  <a id="Thunk"></a><a id="1925" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="1931" class="Symbol">:</a> <a id="1933" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1935" class="Symbol">→</a> <a id="1937" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1941" class="Symbol">→</a> <a id="1943" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1949" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="1955" href="blog/complexity-analysis/index.html#1955" class="Bound">n</a> <a id="1957" href="blog/complexity-analysis/index.html#1957" class="Bound">a</a> <a id="1959" class="Symbol">=</a> <a id="1961" href="blog/complexity-analysis/index.html#1957" class="Bound">a</a>
</pre>
<p>Because none of this exists at runtime, we can just ignore the <code>n</code> argument, and use the <code>abstract</code>ion barrier to ensure nobody can use this fact in anger. <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is a <em>graded</em> monad, that is, a monad parameterized by a monoid, which uses <code>mempty</code> for <code>pure</code>, and <code>mappend</code> for binding. We can show that <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> does form a graded monad:</p>
<pre class="Agda">  <a id="pure"></a><a id="2328" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="2333" class="Symbol">:</a> <a id="2335" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2337" class="Symbol">→</a> <a id="2339" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2345" class="Number">0</a> <a id="2347" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="2351" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="2356" href="blog/complexity-analysis/index.html#2356" class="Bound">x</a> <a id="2358" class="Symbol">=</a> <a id="2360" href="blog/complexity-analysis/index.html#2356" class="Bound">x</a>

  <a id="2365" class="Keyword">infixl</a> <a id="2372" class="Number">1</a> <a id="2374" href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a>
  <a id="_&gt;&gt;=_"></a><a id="2382" href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a> <a id="2388" class="Symbol">:</a> <a id="2390" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2396" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2398" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2400" class="Symbol">→</a> <a id="2402" class="Symbol">(</a><a id="2403" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2405" class="Symbol">→</a> <a id="2407" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2413" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2415" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="2416" class="Symbol">)</a> <a id="2418" class="Symbol">→</a> <a id="2420" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2426" class="Symbol">(</a><a id="2427" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2429" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2431" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2432" class="Symbol">)</a> <a id="2434" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a>
  <a id="2438" href="blog/complexity-analysis/index.html#2438" class="Bound">x</a> <a id="2440" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="2444" href="blog/complexity-analysis/index.html#2444" class="Bound">f</a> <a id="2446" class="Symbol">=</a> <a id="2448" href="blog/complexity-analysis/index.html#2444" class="Bound">f</a> <a id="2450" href="blog/complexity-analysis/index.html#2438" class="Bound">x</a>

  <a id="2455" class="Keyword">infixr</a> <a id="2462" class="Number">1</a> <a id="2464" href="blog/complexity-analysis/index.html#2472" class="Function Operator">_=&lt;&lt;_</a>
  <a id="_=&lt;&lt;_"></a><a id="2472" href="blog/complexity-analysis/index.html#2472" class="Function Operator">_=&lt;&lt;_</a> <a id="2478" class="Symbol">:</a> <a id="2480" class="Symbol">(</a><a id="2481" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2483" class="Symbol">→</a> <a id="2485" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2491" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2493" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="2494" class="Symbol">)</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2504" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2506" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2508" class="Symbol">→</a> <a id="2510" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2516" class="Symbol">(</a><a id="2517" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2519" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2521" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2522" class="Symbol">)</a> <a id="2524" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a>
  <a id="2528" href="blog/complexity-analysis/index.html#2528" class="Bound">f</a> <a id="2530" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="2534" href="blog/complexity-analysis/index.html#2534" class="Bound">x</a> <a id="2536" class="Symbol">=</a> <a id="2538" href="blog/complexity-analysis/index.html#2528" class="Bound">f</a> <a id="2540" href="blog/complexity-analysis/index.html#2534" class="Bound">x</a>
</pre>
<p>We’ll omit the proofs that <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> really is a monad, but it’s not hard to see; <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is truly just the identity monad.</p>
<p><span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is also equipped with two further operations; the ability to mark a computation cycle, and the ability to extract the underlying value by throwing away the complexity analysis:</p>
<pre class="Agda">  <a id="2883" class="Keyword">infixr</a> <a id="2890" class="Number">0</a> <a id="2892" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a>
  <a id="!_"></a><a id="2897" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a> <a id="2900" class="Symbol">:</a> <a id="2902" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2908" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2910" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2912" class="Symbol">→</a> <a id="2914" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2920" class="Symbol">(</a><a id="2921" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2925" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2926" class="Symbol">)</a> <a id="2928" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="2932" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a> <a id="2935" href="blog/complexity-analysis/index.html#2935" class="Bound">a</a> <a id="2937" class="Symbol">=</a> <a id="2939" href="blog/complexity-analysis/index.html#2935" class="Bound">a</a>

  <a id="force"></a><a id="2944" href="blog/complexity-analysis/index.html#2944" class="Function">force</a> <a id="2950" class="Symbol">:</a> <a id="2952" class="Symbol">{</a><a id="2953" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a> <a id="2955" class="Symbol">:</a> <a id="2957" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2960" class="Symbol">}</a> <a id="2962" class="Symbol">→</a> <a id="2964" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2970" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2972" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a> <a id="2974" class="Symbol">→</a> <a id="2976" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a>
  <a id="2980" href="blog/complexity-analysis/index.html#2944" class="Function">force</a> <a id="2986" href="blog/complexity-analysis/index.html#2986" class="Bound">x</a> <a id="2988" class="Symbol">=</a> <a id="2990" href="blog/complexity-analysis/index.html#2986" class="Bound">x</a>
</pre>
<p>Here, <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> is given a low, right-spanning precedence, which means it’s relatively painless to annotate with:</p>
<pre class="Agda"><a id="3118" href="blog/complexity-analysis/index.html#3118" class="Function">_</a> <a id="3120" class="Symbol">:</a> <a id="3122" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="3128" class="Number">3</a> <a id="3130" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="3132" class="Symbol">_</a> <a id="3134" class="Symbol">=</a> <a id="3136" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3138" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3140" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3142" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="3147" class="Number">0</a>
</pre>
<h2 id="conventions"><a href="#conventions" class="header-link">Conventions<span class="header-link-emoji">🔗</span></a></h2>
<p>Our definitions are “opt-in,” in the sense that the compiler won’t yell at you if you forget to call <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> somewhere a computational step happens. Thus, we require users to follow the following conventions:</p>
<ol type="1">
<li>Every function body must begin with a call to <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span>.</li>
<li><span class="Agda"><a href="blog/complexity-analysis/index.html#2944" class="Function">force</a></span> may not be used in a function body.</li>
<li>None of <span class="Agda"><a href="blog/complexity-analysis/index.html#2328" class="Function">pure</a></span>, <span class="Agda"><a href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a></span> nor <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> may be called partially applied.</li>
</ol>
<p>The first convention ensures we count everything that should be counted. The second ensures we don’t cheat by discarding complexity information before it’s been counted. And the third ensures we don’t accidentally introduce uncounted computation steps.</p>
<p>The first two are pretty obvious, but the third is a little subtler. Under the hood, partial application gets turned into a lambda, which introduces a computation step to evaluate. But that step won’t be ticked via <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span>, so we will have lost the bijection between our programs and their analyses.</p>
<h2 id="lazy-data-types"><a href="#lazy-data-types" class="header-link">Lazy Data Types<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper shows us how to define a lazy vector. <span class="Agda"><a href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a></span> <code>a c n</code> is a vector of <code>n</code> elements of type <code>a</code>, where the cost of forcing each subsequent tail is <code>c</code>:</p>
<pre class="Agda"><a id="4346" class="Symbol">{-#</a> <a id="4350" class="Keyword">NO_POSITIVITY_CHECK</a> <a id="4370" class="Symbol">#-}</a>
<a id="4374" class="Keyword">data</a> <a id="VecL"></a><a id="4379" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4384" class="Symbol">(</a><a id="4385" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4387" class="Symbol">:</a> <a id="4389" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="4392" class="Symbol">)</a> <a id="4394" class="Symbol">(</a><a id="4395" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4397" class="Symbol">:</a> <a id="4399" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4400" class="Symbol">)</a> <a id="4402" class="Symbol">:</a> <a id="4404" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4406" class="Symbol">→</a> <a id="4408" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="4412" class="Keyword">where</a>
  <a id="VecL.[]"></a><a id="4420" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="4423" class="Symbol">:</a> <a id="4425" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4430" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4432" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4434" class="Number">0</a>
  <a id="VecL._∷_"></a><a id="4438" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">_∷_</a> <a id="4442" class="Symbol">:</a> <a id="4444" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4446" class="Symbol">→</a> <a id="4448" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4454" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4456" class="Symbol">(</a><a id="4457" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4462" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4464" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4466" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="4467" class="Symbol">)</a> <a id="4469" class="Symbol">→</a> <a id="4471" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4476" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4478" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4480" class="Symbol">(</a><a id="4481" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4485" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="4486" class="Symbol">)</a>

<a id="4489" class="Keyword">infixr</a> <a id="4496" class="Number">5</a> <a id="4498" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">_∷_</a>
</pre>
<p>Let’s try to write <span class="Agda"><a href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a></span> for <span class="Agda"><a href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a></span>. We’re going to need a helper function, which delays a computation by artificially inflating its number of steps:</p>
<pre class="Agda"><a id="4678" class="Keyword">abstract</a>
  <a id="wait"></a><a id="4689" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="4694" class="Symbol">:</a> <a id="4696" class="Symbol">{</a><a id="4697" href="blog/complexity-analysis/index.html#4697" class="Bound">n</a> <a id="4699" class="Symbol">:</a> <a id="4701" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4702" class="Symbol">}</a> <a id="4704" class="Symbol">→</a> <a id="4706" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4712" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="4714" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="4716" class="Symbol">→</a> <a id="4718" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4724" class="Symbol">(</a><a id="4725" href="blog/complexity-analysis/index.html#4697" class="Bound">n</a> <a id="4727" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="4729" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a><a id="4730" class="Symbol">)</a> <a id="4732" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="4736" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="4741" href="blog/complexity-analysis/index.html#4741" class="Bound">m</a> <a id="4743" class="Symbol">=</a> <a id="4745" href="blog/complexity-analysis/index.html#4741" class="Bound">m</a>
</pre>
<p>(the paper follows its own rules and ensures that we call <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> every time we <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span>, thus it comes with an extra <span class="Agda"><a href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a></span> in the type of <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span>. It gets confusing, so we’ll use this version instead.)</p>
<p>Unfortunately, the paper also plays fast and loose with its math. It’s fine, because the math is right, but the code presented in the paper doesn’t typecheck in Agda. As a workaround, we need to enable rewriting:</p>
<pre class="Agda"><a id="5196" class="Keyword">open</a> <a id="5201" class="Keyword">import</a> <a id="5208" href="Agda.Builtin.Equality.Rewrite.html" class="Module">Agda.Builtin.Equality.Rewrite</a>
<a id="5238" class="Symbol">{-#</a> <a id="5242" class="Keyword">REWRITE</a> <a id="5250" href="Data.Nat.Properties.html#12854" class="Function">+-suc</a> <a id="5256" href="Data.Nat.Properties.html#13218" class="Function">+-identityʳ</a> <a id="5268" class="Symbol">#-}</a>
</pre>
<p>We’ll also need to be able to lift equalities over the <code>Thunk</code> time bounds:</p>
<pre class="Agda"><a id="cast"></a><a id="5358" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5363" class="Symbol">:</a> <a id="5365" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="5367" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="5369" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="5371" class="Symbol">→</a> <a id="5373" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5379" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="5381" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5383" class="Symbol">→</a> <a id="5385" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5391" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="5393" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="5395" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5400" href="blog/complexity-analysis/index.html#5400" class="Bound">eq</a> <a id="5403" href="blog/complexity-analysis/index.html#5403" class="Bound">x</a> <a id="5405" class="Keyword">rewrite</a> <a id="5413" href="blog/complexity-analysis/index.html#5400" class="Bound">eq</a> <a id="5416" class="Symbol">=</a> <a id="5418" href="blog/complexity-analysis/index.html#5403" class="Bound">x</a>
</pre>
<p>Finally, we can write <span class="Agda"><a href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a></span>:</p>
<pre class="Agda"><a id="fmap"></a><a id="5467" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a>
  <a id="5474" class="Symbol">:</a> <a id="5476" class="Symbol">{</a><a id="5477" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a> <a id="5479" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5482" class="Symbol">:</a> <a id="5484" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5485" class="Symbol">}</a>
  <a id="5489" class="Symbol">→</a> <a id="5491" class="Symbol">(</a><a id="5492" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5494" class="Symbol">→</a> <a id="5496" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5502" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5505" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="5506" class="Symbol">)</a>
  <a id="5510" class="Symbol">→</a> <a id="5512" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="5517" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5519" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a> <a id="5521" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
  <a id="5525" class="Symbol">→</a> <a id="5527" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5533" class="Symbol">(</a><a id="5534" class="Number">2</a> <a id="5536" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="5538" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a><a id="5540" class="Symbol">)</a> <a id="5542" class="Symbol">(</a><a id="5543" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="5548" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a> <a id="5550" class="Symbol">(</a><a id="5551" class="Number">2</a> <a id="5553" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="5555" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5558" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="5560" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a><a id="5561" class="Symbol">)</a> <a id="5563" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="5564" class="Symbol">)</a>
<a id="5566" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5571" href="blog/complexity-analysis/index.html#5571" class="Bound">f</a> <a id="5573" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="5576" class="Symbol">=</a> <a id="5578" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="5583" class="Symbol">(</a><a id="5584" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="5589" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a><a id="5591" class="Symbol">)</a>
<a id="5593" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5598" class="Symbol">{</a><a id="5599" class="Argument">c</a> <a id="5601" class="Symbol">=</a> <a id="5603" href="blog/complexity-analysis/index.html#5603" class="Bound">c</a><a id="5604" class="Symbol">}</a> <a id="5606" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a> <a id="5608" class="Symbol">(</a><a id="5609" href="blog/complexity-analysis/index.html#5609" class="Bound">x</a> <a id="5611" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="5613" href="blog/complexity-analysis/index.html#5613" class="Bound">xs</a><a id="5615" class="Symbol">)</a>
          <a id="5627" class="Symbol">=</a> <a id="5629" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="5631" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a> <a id="5633" href="blog/complexity-analysis/index.html#5609" class="Bound">x</a>
  <a id="5637" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="5641" class="Symbol">\</a><a id="5642" href="blog/complexity-analysis/index.html#5642" class="Bound">x&#39;</a> <a id="5645" class="Symbol">→</a> <a id="5647" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="5649" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="5654" class="Symbol">(</a><a id="5655" href="blog/complexity-analysis/index.html#5642" class="Bound">x&#39;</a> <a id="5658" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="5660" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5665" class="Symbol">(</a><a id="5666" href="Data.Nat.Properties.html#13395" class="Function">+-comm</a> <a id="5673" href="blog/complexity-analysis/index.html#5603" class="Bound">c</a> <a id="5675" class="Symbol">_)</a> <a id="5678" class="Symbol">(</a><a id="5679" href="blog/complexity-analysis/index.html#5613" class="Bound">xs</a> <a id="5682" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="5686" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5691" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a><a id="5692" class="Symbol">))</a>
</pre>
<p>This took me about an hour to write; I’m not convinced the approach here is as “lightweight” as claimed. Of particular challenge was figuring out the actual time bounds on this thing. The problem is that we usually reason about asymptotics via Big-O notation, which ignores all of these constant factors. What would be nicer is the hypothetical type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> {c fc <span class="op">:</span> ℕ}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  → (a → <span class="dt">Thunk</span> (<span class="dt">O</span> fc) b)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  → <span class="dt">VecL</span> a c n</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  → <span class="dt">Thunk</span> (<span class="dt">O</span> c) (<span class="dt">VecL</span> b (<span class="dt">O</span> (fc <span class="op">+</span> c)) n)</span></code></pre></div>
<p>where every thunk is now parameterized by <code>O x</code> saying our asymptotics are bounded by <code>x</code>. We’ll see about fleshing this idea out later. For now, we can power through on the paper, and write vector insertion. Let’s assume we have a constant time comparison function for <span class="Agda"><a href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a></span>:</p>
<pre class="Agda"><a id="6455" class="Keyword">postulate</a>
  <a id="_&lt;=_"></a><a id="6467" href="blog/complexity-analysis/index.html#6467" class="Postulate Operator">_&lt;=_</a> <a id="6472" class="Symbol">:</a> <a id="6474" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6476" class="Symbol">→</a> <a id="6478" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6480" class="Symbol">→</a> <a id="6482" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6488" class="Number">1</a> <a id="6490" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
</pre>
<p>First things first, we need another waiting function to inflate the times on every tail:</p>
<pre class="Agda"><a id="waitL"></a><a id="6594" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a>
    <a id="6604" class="Symbol">:</a> <a id="6606" class="Symbol">{</a><a id="6607" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a> <a id="6610" class="Symbol">:</a> <a id="6612" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6613" class="Symbol">}</a> <a id="6615" class="Symbol">{</a><a id="6616" href="blog/complexity-analysis/index.html#6616" class="Bound">c</a> <a id="6618" class="Symbol">:</a> <a id="6620" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6621" class="Symbol">}</a>
    <a id="6627" class="Symbol">→</a> <a id="6629" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="6634" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6636" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a> <a id="6639" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
    <a id="6645" class="Symbol">→</a> <a id="6647" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6653" class="Number">1</a> <a id="6655" class="Symbol">(</a><a id="6656" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="6661" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6663" class="Symbol">(</a><a id="6664" class="Number">2</a> <a id="6666" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="6668" href="blog/complexity-analysis/index.html#6616" class="Bound">c</a> <a id="6670" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="6672" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a><a id="6674" class="Symbol">)</a> <a id="6676" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="6677" class="Symbol">)</a>
<a id="6679" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6685" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="6688" class="Symbol">=</a> <a id="6690" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6692" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6697" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a>
<a id="6700" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6706" class="Symbol">(</a><a id="6707" href="blog/complexity-analysis/index.html#6707" class="Bound">x</a> <a id="6709" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="6711" href="blog/complexity-analysis/index.html#6711" class="Bound">xs</a><a id="6713" class="Symbol">)</a> <a id="6715" class="Symbol">=</a> <a id="6717" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6719" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6724" class="Symbol">(</a><a id="6725" href="blog/complexity-analysis/index.html#6707" class="Bound">x</a> <a id="6727" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="6729" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="6734" class="Symbol">(</a><a id="6735" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6741" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="6745" href="blog/complexity-analysis/index.html#6711" class="Bound">xs</a><a id="6747" class="Symbol">))</a>
</pre>
<p>and a helper version of <span class="Agda"><a href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a></span> which accounts in <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span>:</p>
<pre class="Agda"><a id="if_then_else_"></a><a id="6841" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a> <a id="6855" class="Symbol">:</a> <a id="6857" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="6862" class="Symbol">→</a> <a id="6864" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6866" class="Symbol">→</a> <a id="6868" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6870" class="Symbol">→</a> <a id="6872" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6878" class="Number">1</a> <a id="6880" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="6882" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="6885" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6891" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="6896" href="blog/complexity-analysis/index.html#6896" class="Bound">t</a> <a id="6898" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="6903" href="blog/complexity-analysis/index.html#6903" class="Bound">f</a> <a id="6905" class="Symbol">=</a> <a id="6907" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6909" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6914" href="blog/complexity-analysis/index.html#6903" class="Bound">f</a>
<a id="6916" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="6919" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="6925" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="6930" href="blog/complexity-analysis/index.html#6930" class="Bound">t</a> <a id="6932" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="6937" href="blog/complexity-analysis/index.html#6937" class="Bound">f</a> <a id="6939" class="Symbol">=</a> <a id="6941" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6943" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6948" href="blog/complexity-analysis/index.html#6930" class="Bound">t</a>
<a id="6950" class="Keyword">infixr</a> <a id="6957" class="Number">2</a> <a id="6959" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a>
</pre>
<p>we can thus write vector insertion:</p>
<pre class="Agda"><a id="insert"></a><a id="7019" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a>
    <a id="7030" class="Symbol">:</a> <a id="7032" class="Symbol">{</a><a id="7033" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a> <a id="7035" class="Symbol">:</a> <a id="7037" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="7038" class="Symbol">}</a>
    <a id="7044" class="Symbol">→</a> <a id="7046" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
    <a id="7052" class="Symbol">→</a> <a id="7054" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7059" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7061" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a> <a id="7063" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
    <a id="7069" class="Symbol">→</a> <a id="7071" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7077" class="Number">4</a> <a id="7079" class="Symbol">(</a><a id="7080" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7085" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7087" class="Symbol">(</a><a id="7088" class="Number">4</a> <a id="7090" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7092" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a><a id="7093" class="Symbol">)</a> <a id="7095" class="Symbol">(</a><a id="7096" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7100" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7101" class="Symbol">))</a>
<a id="7104" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7111" href="blog/complexity-analysis/index.html#7111" class="Bound">x</a> <a id="7113" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="7116" class="Symbol">=</a> <a id="7118" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7123" class="Symbol">(</a><a id="7124" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7129" class="Symbol">(</a><a id="7130" href="blog/complexity-analysis/index.html#7111" class="Bound">x</a> <a id="7132" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7134" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7139" class="Symbol">(</a><a id="7140" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7145" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a><a id="7147" class="Symbol">)))</a>
<a id="7151" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7158" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7160" class="Symbol">(</a><a id="7161" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7163" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7165" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7167" class="Symbol">)</a>
         <a id="7178" class="Symbol">=</a> <a id="7180" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7182" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7184" href="blog/complexity-analysis/index.html#6467" class="Postulate Operator">&lt;=</a> <a id="7187" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a>
  <a id="7191" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="7195" class="Symbol">\</a><a id="7196" href="blog/complexity-analysis/index.html#7196" class="Bound">b</a> <a id="7198" class="Symbol">→</a> <a id="7200" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7202" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="7205" href="blog/complexity-analysis/index.html#7196" class="Bound">b</a> <a id="7207" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="7212" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7214" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7216" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7221" class="Symbol">(</a><a id="7222" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="7228" class="Symbol">(</a><a id="7229" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7231" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7233" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7235" class="Symbol">))</a>
                  <a id="7256" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="7261" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7263" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7265" class="Symbol">(</a><a id="7266" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7273" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7275" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="7279" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7281" class="Symbol">)</a>
</pre>
<p>The obvious followup to <span class="Agda"><a href="blog/complexity-analysis/index.html#7019" class="Function">insert</a></span> is insertion <span class="Agda"><a href="blog/complexity-analysis/index.html#7410" class="Function">sort</a></span>:</p>
<pre class="Agda"><a id="7361" class="Keyword">open</a> <a id="7366" class="Keyword">import</a> <a id="7373" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="7382" class="Keyword">using</a> <a id="7388" class="Symbol">(</a><a id="7389" href="Data.Vec.Base.html#998" class="Datatype">Vec</a><a id="7392" class="Symbol">;</a> <a id="7394" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="7396" class="Symbol">;</a> <a id="7398" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">_∷_</a><a id="7401" class="Symbol">;</a> <a id="7403" href="Data.Vec.Base.html#1546" class="Function">tail</a><a id="7407" class="Symbol">)</a>

<a id="sort"></a><a id="7410" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7415" class="Symbol">:</a> <a id="7417" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="7421" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7423" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="7425" class="Symbol">→</a> <a id="7427" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7433" class="Symbol">(</a><a id="7434" class="Number">1</a> <a id="7436" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7438" class="Number">5</a> <a id="7440" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="7442" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7443" class="Symbol">)</a> <a id="7445" class="Symbol">(</a><a id="7446" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7451" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7453" class="Symbol">(</a><a id="7454" class="Number">4</a> <a id="7456" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="7458" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7459" class="Symbol">)</a> <a id="7461" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7462" class="Symbol">)</a>
<a id="7464" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7469" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="7472" class="Symbol">=</a> <a id="7474" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7476" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7481" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a>
<a id="7484" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7489" class="Symbol">(</a><a id="7490" href="blog/complexity-analysis/index.html#7490" class="Bound">x</a> <a id="7492" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="7494" href="blog/complexity-analysis/index.html#7494" class="Bound">xs</a><a id="7496" class="Symbol">)</a> <a id="7498" class="Symbol">=</a> <a id="7500" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7502" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7509" href="blog/complexity-analysis/index.html#7490" class="Bound">x</a> <a id="7511" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="7515" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7520" href="blog/complexity-analysis/index.html#7494" class="Bound">xs</a>
</pre>
<p>This thing looks linear, but insertion sort is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,</span> so what gives? The thing to notice is that the cost of each <em>tail</em> is linear, but we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> tails, so forcing the whole thing indeed works out to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span> We can now show <span class="Agda"><a href="blog/complexity-analysis/index.html#7804" class="Function">head</a></span> runs in constant time:</p>
<pre class="Agda"><a id="head"></a><a id="7804" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="7809" class="Symbol">:</a> <a id="7811" class="Symbol">{</a><a id="7812" href="blog/complexity-analysis/index.html#7812" class="Bound">c</a> <a id="7814" class="Symbol">:</a> <a id="7816" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="7817" class="Symbol">}</a> <a id="7819" class="Symbol">→</a> <a id="7821" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7826" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7828" href="blog/complexity-analysis/index.html#7812" class="Bound">c</a> <a id="7830" class="Symbol">(</a><a id="7831" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7835" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7836" class="Symbol">)</a> <a id="7838" class="Symbol">→</a> <a id="7840" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7846" class="Number">1</a> <a id="7848" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="7850" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="7855" class="Symbol">(</a><a id="7856" href="blog/complexity-analysis/index.html#7856" class="Bound">x</a> <a id="7858" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7860" class="Symbol">_)</a> <a id="7863" class="Symbol">=</a> <a id="7865" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7867" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7872" href="blog/complexity-analysis/index.html#7856" class="Bound">x</a>
</pre>
<p>and that we can find the <span class="Agda"><a href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a></span> element in linear time:</p>
<pre class="Agda"><a id="minimum"></a><a id="7951" href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a> <a id="7959" class="Symbol">:</a> <a id="7961" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="7965" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7967" class="Symbol">(</a><a id="7968" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7972" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7973" class="Symbol">)</a> <a id="7975" class="Symbol">→</a> <a id="7977" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7983" class="Symbol">(</a><a id="7984" class="Number">8</a> <a id="7986" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="7988" class="Number">5</a> <a id="7990" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="7992" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7993" class="Symbol">)</a> <a id="7995" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="7997" href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a> <a id="8005" href="blog/complexity-analysis/index.html#8005" class="Bound">xs</a> <a id="8008" class="Symbol">=</a> <a id="8010" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8012" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="8017" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8021" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="8026" href="blog/complexity-analysis/index.html#8005" class="Bound">xs</a>
</pre>
<p>Interestingly, Agda can figure out the bounds on <span class="Agda"><a href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a></span> by itself, but not any of our other functions.</p>
<p>The paper goes on to show that we can define <span class="Agda"><a href="blog/complexity-analysis/index.html#8264" class="Function">last</a></span>, and then get a quadratic-time <code>maximum</code> using it:</p>
<pre class="Agda"><a id="last"></a><a id="8264" href="blog/complexity-analysis/index.html#8264" class="Function">last</a> <a id="8269" class="Symbol">:</a> <a id="8271" class="Symbol">{</a><a id="8272" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a> <a id="8274" class="Symbol">:</a> <a id="8276" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="8277" class="Symbol">}</a> <a id="8279" class="Symbol">→</a> <a id="8281" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="8286" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8288" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a> <a id="8290" class="Symbol">(</a><a id="8291" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8295" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="8296" class="Symbol">)</a> <a id="8298" class="Symbol">→</a> <a id="8300" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="8306" class="Symbol">(</a><a id="8307" class="Number">1</a> <a id="8309" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8311" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8315" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8317" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="8319" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8323" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a><a id="8324" class="Symbol">)</a> <a id="8326" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="8328" href="blog/complexity-analysis/index.html#8264" class="Function">last</a> <a id="8333" class="Symbol">(</a><a id="8334" href="blog/complexity-analysis/index.html#8334" class="Bound">x</a> <a id="8336" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="8338" href="blog/complexity-analysis/index.html#8338" class="Bound">xs</a><a id="8340" class="Symbol">)</a> <a id="8342" class="Symbol">=</a> <a id="8344" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8346" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8352" href="blog/complexity-analysis/index.html#8334" class="Bound">x</a> <a id="8354" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8358" href="blog/complexity-analysis/index.html#8338" class="Bound">xs</a>
  <a id="8363" class="Keyword">where</a>
    <a id="8373" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8379" class="Symbol">:</a> <a id="8381" class="Symbol">{</a><a id="8382" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a> <a id="8384" class="Symbol">:</a> <a id="8386" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="8387" class="Symbol">}</a> <a id="8389" class="Symbol">→</a> <a id="8391" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8393" class="Symbol">→</a> <a id="8395" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="8400" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8402" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a> <a id="8404" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8406" class="Symbol">→</a> <a id="8408" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="8414" class="Symbol">(</a><a id="8415" class="Number">1</a> <a id="8417" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8419" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8421" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="8423" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8427" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a><a id="8428" class="Symbol">)</a> <a id="8430" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
    <a id="8436" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8442" href="blog/complexity-analysis/index.html#8442" class="Bound">a</a> <a id="8444" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="8447" class="Symbol">=</a> <a id="8449" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8451" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="8456" href="blog/complexity-analysis/index.html#8442" class="Bound">a</a>
    <a id="8462" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8468" class="Symbol">_</a> <a id="8470" class="Symbol">(</a><a id="8471" href="blog/complexity-analysis/index.html#8471" class="Bound">x</a> <a id="8473" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="8475" href="blog/complexity-analysis/index.html#8475" class="Bound">xs</a><a id="8477" class="Symbol">)</a> <a id="8479" class="Symbol">=</a> <a id="8481" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8483" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8489" href="blog/complexity-analysis/index.html#8471" class="Bound">x</a> <a id="8491" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8495" href="blog/complexity-analysis/index.html#8475" class="Bound">xs</a>
</pre>
<p>Trying to define <code>maximum</code> makes Agda spin, probably because of one of my rewrite rules. But here’s what it should be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> <span class="op">:</span> <span class="dt">Vec</span> a (suc n) → <span class="dt">Thunk</span> (<span class="dv">13</span> <span class="op">+</span> <span class="dv">14</span> <span class="op">*</span> n <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> n <span class="op">^</span> <span class="dv">2</span>) a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> xs <span class="ot">=</span> <span class="op">!</span> <span class="fu">last</span> <span class="op">=&lt;&lt;</span> <span class="fu">sort</span> xs</span></code></pre></div>
<p>The paper goes on to say some thinks about partially evaluating thunks, and then shows its use to measure some popular libraries. But I’m more interested in making the experience better.</p>
<h2 id="extra-curricular-big-o"><a href="#extra-curricular-big-o" class="header-link">Extra-curricular Big O<span class="header-link-emoji">🔗</span></a></h2>
<p>Clearly this is all too much work. When we do complexity analysis by hand, we are primarily concerned with <em>complexity classes,</em> not exact numbers of steps. How hard would it be to generalize all of this so that <code>Thunk</code> takes a function bounding the runtime necessary to produce its value?</p>
<p>First, a quick refresher on what big-O means. A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">f : \mathbb{N} \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> is said to be in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">g : \mathbb{N} \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> iff:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∃</mi><mo stretchy="false">(</mo><mi>C</mi><mi>k</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>n</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo>⋅</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\exists (C k : \mathbb{N}). \forall (n : \mathbb{N}, k \leq n). f(n) \leq C \cdot g(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span><span class="mord">.∀</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>That is, there is some point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> at which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> stays above <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</span> This is the formal definition, but in practice we usually play rather fast and loose with our notation. For example, we say “quicksort is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> in the length of the list”, or “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot\log{m})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mclose">)</span></span></span></span> , where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the size of the first argument.”</p>
<p>We need to do a bit of elaboration here to turn these informal statements into a formal claim. In both cases, there should are implicit binders inside the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(-)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">−</span><span class="mclose">)</span></span></span></span>,</span> binding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> in the first, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> in the second. These functions then get instantiated with the actual sizes of the lists. It’s a subtle point, but it needs to be kept in mind.</p>
<p>The other question is how the hell do we generalize that definition to multiple variables? Easy! We replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n : \mathbb{N}, k \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> with a vector of natural numbers, subject to the constraint that they’re <em>all</em> bigger than <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.</span></p>
<p>OK, let’s write some code. We can give the definition of <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>:</p>
<pre class="Agda"><a id="10468" class="Keyword">open</a> <a id="10473" class="Keyword">import</a> <a id="10480" href="Data.Vec.Relation.Unary.All.html" class="Module">Data.Vec.Relation.Unary.All</a>
    <a id="10512" class="Keyword">using</a> <a id="10518" class="Symbol">(</a><a id="10519" href="Data.Vec.Relation.Unary.All.html#1073" class="Datatype">All</a><a id="10522" class="Symbol">;</a> <a id="10524" href="Data.Vec.Relation.Unary.All.html#1165" class="InductiveConstructor Operator">_∷_</a><a id="10527" class="Symbol">;</a> <a id="10529" href="Data.Vec.Relation.Unary.All.html#1148" class="InductiveConstructor">[]</a><a id="10531" class="Symbol">)</a>
    <a id="10537" class="Keyword">renaming</a> <a id="10546" class="Symbol">(</a><a id="10547" href="Data.Vec.Relation.Unary.All.html#1447" class="Function">tail</a> <a id="10552" class="Symbol">to</a> <a id="10555" class="Function">tailAll</a><a id="10562" class="Symbol">)</a>

<a id="10565" class="Keyword">record</a> <a id="O"></a><a id="10572" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="10574" class="Symbol">{</a><a id="10575" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a> <a id="10580" class="Symbol">:</a> <a id="10582" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10583" class="Symbol">}</a> <a id="10585" class="Symbol">(</a><a id="10586" href="blog/complexity-analysis/index.html#10586" class="Bound">g</a> <a id="10588" class="Symbol">:</a> <a id="10590" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="10594" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10596" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a>  <a id="10602" class="Symbol">→</a> <a id="10604" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10605" class="Symbol">)</a> <a id="10607" class="Symbol">:</a> <a id="10609" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="10613" class="Keyword">where</a>
  <a id="10621" class="Keyword">field</a>
    <a id="O.f"></a><a id="10631" href="blog/complexity-analysis/index.html#10631" class="Field">f</a> <a id="10633" class="Symbol">:</a> <a id="10635" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="10639" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10641" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a> <a id="10646" class="Symbol">→</a> <a id="10648" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
    <a id="O.C"></a><a id="10654" href="blog/complexity-analysis/index.html#10654" class="Field">C</a> <a id="10656" class="Symbol">:</a> <a id="10658" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
    <a id="O.k"></a><a id="10664" href="blog/complexity-analysis/index.html#10664" class="Field">k</a> <a id="10666" class="Symbol">:</a> <a id="10668" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
    <a id="O.def"></a><a id="10674" href="blog/complexity-analysis/index.html#10674" class="Field">def</a> <a id="10678" class="Symbol">:</a> <a id="10680" class="Symbol">(</a><a id="10681" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10683" class="Symbol">:</a> <a id="10685" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="10689" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10691" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a><a id="10695" class="Symbol">)</a> <a id="10697" class="Symbol">→</a> <a id="10699" href="Data.Vec.Relation.Unary.All.html#1073" class="Datatype">All</a> <a id="10703" class="Symbol">(</a><a id="10704" href="blog/complexity-analysis/index.html#10664" class="Field">k</a> <a id="10706" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤_</a><a id="10708" class="Symbol">)</a> <a id="10710" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10712" class="Symbol">→</a> <a id="10714" href="blog/complexity-analysis/index.html#10631" class="Field">f</a> <a id="10716" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10718" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="10720" href="blog/complexity-analysis/index.html#10654" class="Field">C</a> <a id="10722" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="10724" href="blog/complexity-analysis/index.html#10586" class="Bound">g</a> <a id="10726" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a>
</pre>
<p>The generality of <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> is a bit annoying for the common case of being a function over one variable, so we can introduce a helper function <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span>:</p>
<pre class="Agda"><a id="hoist"></a><a id="10895" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10901" class="Symbol">:</a> <a id="10903" class="Symbol">{</a><a id="10904" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10906" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a> <a id="10908" class="Symbol">:</a> <a id="10910" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="10913" class="Symbol">}</a> <a id="10915" class="Symbol">→</a> <a id="10917" class="Symbol">(</a><a id="10918" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10920" class="Symbol">→</a> <a id="10922" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a><a id="10923" class="Symbol">)</a> <a id="10925" class="Symbol">→</a> <a id="10927" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="10931" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10933" class="Number">1</a> <a id="10935" class="Symbol">→</a> <a id="10937" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a>
<a id="10939" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10945" href="blog/complexity-analysis/index.html#10945" class="Bound">f</a> <a id="10947" class="Symbol">(</a><a id="10948" href="blog/complexity-analysis/index.html#10948" class="Bound">x</a> <a id="10950" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10952" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10954" class="Symbol">)</a> <a id="10956" class="Symbol">=</a> <a id="10958" href="blog/complexity-analysis/index.html#10945" class="Bound">f</a> <a id="10960" href="blog/complexity-analysis/index.html#10948" class="Bound">x</a>

<a id="O&#39;"></a><a id="10963" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="10966" class="Symbol">:</a> <a id="10968" class="Symbol">(</a><a id="10969" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="10971" class="Symbol">→</a> <a id="10973" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="10974" class="Symbol">)</a> <a id="10976" class="Symbol">→</a> <a id="10978" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="10982" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="10985" href="blog/complexity-analysis/index.html#10985" class="Bound">f</a> <a id="10987" class="Symbol">=</a> <a id="10989" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="10991" class="Symbol">(</a><a id="10992" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10998" href="blog/complexity-analysis/index.html#10985" class="Bound">f</a><a id="10999" class="Symbol">)</a>
</pre>
<p>We can trivially lift any function <code>f</code> into <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> <code>f</code>:</p>
<pre class="Agda"><a id="O-build"></a><a id="11071" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11079" class="Symbol">:</a> <a id="11081" class="Symbol">{</a><a id="11082" href="blog/complexity-analysis/index.html#11082" class="Bound">vars</a> <a id="11087" class="Symbol">:</a> <a id="11089" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11090" class="Symbol">}</a> <a id="11092" class="Symbol">→</a> <a id="11094" class="Symbol">(</a><a id="11095" href="blog/complexity-analysis/index.html#11095" class="Bound">f</a> <a id="11097" class="Symbol">:</a> <a id="11099" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="11103" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11105" href="blog/complexity-analysis/index.html#11082" class="Bound">vars</a> <a id="11110" class="Symbol">→</a> <a id="11112" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11113" class="Symbol">)</a> <a id="11115" class="Symbol">→</a> <a id="11117" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11119" href="blog/complexity-analysis/index.html#11095" class="Bound">f</a>
<a id="11121" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11129" href="blog/complexity-analysis/index.html#11129" class="Bound">f</a> <a id="11131" class="Symbol">.</a><a id="11132" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11136" class="Symbol">=</a> <a id="11138" href="blog/complexity-analysis/index.html#11129" class="Bound">f</a>
<a id="11140" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11148" href="blog/complexity-analysis/index.html#11148" class="Bound">f</a> <a id="11150" class="Symbol">.</a><a id="11151" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11155" class="Symbol">=</a> <a id="11157" class="Number">1</a>
<a id="11159" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11167" href="blog/complexity-analysis/index.html#11167" class="Bound">f</a> <a id="11169" class="Symbol">.</a><a id="11170" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11174" class="Symbol">=</a> <a id="11176" class="Number">0</a>
<a id="11178" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11186" href="blog/complexity-analysis/index.html#11186" class="Bound">f</a> <a id="11188" class="Symbol">.</a><a id="11189" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11195" href="blog/complexity-analysis/index.html#11195" class="Bound">n</a> <a id="11197" href="blog/complexity-analysis/index.html#11197" class="Bound">x</a> <a id="11199" class="Symbol">=</a> <a id="11201" href="Data.Nat.Properties.html#4565" class="Function">≤-refl</a>
</pre>
<p>and also trivially weaken an <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> into using more variables:</p>
<pre class="Agda"><a id="O-weaken"></a><a id="11285" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11294" class="Symbol">:</a> <a id="11296" class="Symbol">∀</a> <a id="11298" class="Symbol">{</a><a id="11299" href="blog/complexity-analysis/index.html#11299" class="Bound">vars</a><a id="11303" class="Symbol">}</a> <a id="11305" class="Symbol">{</a><a id="11306" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11308" class="Symbol">:</a> <a id="11310" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="11314" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="11316" href="blog/complexity-analysis/index.html#11299" class="Bound">vars</a> <a id="11321" class="Symbol">→</a> <a id="11323" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11324" class="Symbol">}</a> <a id="11326" class="Symbol">→</a> <a id="11328" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11330" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11332" class="Symbol">→</a> <a id="11334" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11336" class="Symbol">(</a><a id="11337" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11339" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="11341" href="Data.Vec.Base.html#1546" class="Function">tail</a><a id="11345" class="Symbol">)</a>
<a id="11347" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11356" href="blog/complexity-analysis/index.html#11356" class="Bound">o</a> <a id="11358" class="Symbol">.</a><a id="11359" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11363" class="Symbol">=</a> <a id="11365" href="blog/complexity-analysis/index.html#11356" class="Bound">o</a> <a id="11367" class="Symbol">.</a><a id="11368" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11372" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="11374" href="Data.Vec.Base.html#1546" class="Function">tail</a>
<a id="11379" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11388" href="blog/complexity-analysis/index.html#11388" class="Bound">o</a> <a id="11390" class="Symbol">.</a><a id="11391" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11395" class="Symbol">=</a> <a id="11397" href="blog/complexity-analysis/index.html#11388" class="Bound">o</a> <a id="11399" class="Symbol">.</a><a id="11400" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a>
<a id="11404" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11413" href="blog/complexity-analysis/index.html#11413" class="Bound">o</a> <a id="11415" class="Symbol">.</a><a id="11416" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11420" class="Symbol">=</a> <a id="11422" href="blog/complexity-analysis/index.html#11413" class="Bound">o</a> <a id="11424" class="Symbol">.</a><a id="11425" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a>
<a id="11429" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11438" href="blog/complexity-analysis/index.html#11438" class="Bound">o</a> <a id="11440" class="Symbol">.</a><a id="11441" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11447" class="Symbol">(_</a> <a id="11450" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="11452" href="blog/complexity-analysis/index.html#11452" class="Bound">x</a><a id="11453" class="Symbol">)</a> <a id="11455" class="Symbol">(_</a> <a id="11458" href="Data.Vec.Relation.Unary.All.html#1165" class="InductiveConstructor Operator">∷</a> <a id="11460" href="blog/complexity-analysis/index.html#11460" class="Bound">eq</a><a id="11462" class="Symbol">)</a> <a id="11464" class="Symbol">=</a> <a id="11466" href="blog/complexity-analysis/index.html#11438" class="Bound">o</a> <a id="11468" class="Symbol">.</a><a id="11469" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11475" href="blog/complexity-analysis/index.html#11452" class="Bound">x</a> <a id="11477" href="blog/complexity-analysis/index.html#11460" class="Bound">eq</a>
</pre>
<p>More interestingly, we can lift a given <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span> into a higher power, witnessing the fact that eg, something of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is also <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>:</span></p>
<pre class="Agda"><a id="O-^-suc"></a><a id="11632" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11640" class="Symbol">:</a> <a id="11642" class="Symbol">{</a><a id="11643" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a> <a id="11645" class="Symbol">:</a> <a id="11647" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="11648" class="Symbol">}</a> <a id="11650" class="Symbol">→</a> <a id="11652" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="11655" class="Symbol">(</a><a id="11656" href="Data.Nat.Base.html#3471" class="Function Operator">_^</a> <a id="11659" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a><a id="11660" class="Symbol">)</a> <a id="11662" class="Symbol">→</a> <a id="11664" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="11667" class="Symbol">(</a><a id="11668" href="Data.Nat.Base.html#3471" class="Function Operator">_^</a> <a id="11671" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11675" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a><a id="11676" class="Symbol">)</a>
<a id="11678" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11686" href="blog/complexity-analysis/index.html#11686" class="Bound">o</a> <a id="11688" class="Symbol">.</a><a id="11689" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11693" class="Symbol">=</a> <a id="11695" href="blog/complexity-analysis/index.html#11686" class="Bound">o</a> <a id="11697" class="Symbol">.</a><a id="11698" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a>
<a id="11702" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11710" href="blog/complexity-analysis/index.html#11710" class="Bound">o</a> <a id="11712" class="Symbol">.</a><a id="11713" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11717" class="Symbol">=</a> <a id="11719" href="blog/complexity-analysis/index.html#11710" class="Bound">o</a> <a id="11721" class="Symbol">.</a><a id="11722" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a>
<a id="11726" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11734" href="blog/complexity-analysis/index.html#11734" class="Bound">o</a> <a id="11736" class="Symbol">.</a><a id="11737" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11741" class="Symbol">=</a> <a id="11743" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11747" class="Symbol">(</a><a id="11748" href="blog/complexity-analysis/index.html#11734" class="Bound">o</a> <a id="11750" class="Symbol">.</a><a id="11751" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a><a id="11754" class="Symbol">)</a>
<a id="11756" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11764" class="Symbol">{</a><a id="11765" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11766" class="Symbol">}</a> <a id="11768" href="blog/complexity-analysis/index.html#11768" class="Bound">o</a> <a id="11770" class="Symbol">.</a><a id="11771" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11777" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a><a id="11779" class="Symbol">@(</a><a id="11781" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11783" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="11785" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="11787" class="Symbol">)</a> <a id="11789" href="blog/complexity-analysis/index.html#11789" class="Bound">ps</a><a id="11791" class="Symbol">@(</a><a id="11793" href="Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="11797" href="blog/complexity-analysis/index.html#11797" class="Bound">px</a> <a id="11800" href="Data.Vec.Relation.Unary.All.html#1165" class="InductiveConstructor Operator">∷</a> <a id="11802" href="Data.Vec.Relation.Unary.All.html#1148" class="InductiveConstructor">[]</a><a id="11804" class="Symbol">)</a> <a id="11806" class="Symbol">=</a>
  <a id="11810" href="Relation.Binary.Reasoning.Base.Triple.html#3010" class="Function Operator">begin</a>
    <a id="11820" href="blog/complexity-analysis/index.html#10631" class="Function">f</a> <a id="11822" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a>               <span class="reasoning-step"><span class="as-written Function"><a id="11839" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="11842" href="blog/complexity-analysis/index.html#10674" class="Function">def</a> <a id="11846" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a> <a id="11849" class="Symbol">(</a><a id="11850" href="Data.Nat.Properties.html#7182" class="Function">≤-step</a> <a id="11857" href="blog/complexity-analysis/index.html#11797" class="Bound">px</a> <a id="11860" href="Data.Vec.Relation.Unary.All.html#1165" class="InductiveConstructor Operator">∷</a> <a id="11862" href="Data.Vec.Relation.Unary.All.html#1148" class="InductiveConstructor">[]</a><a id="11864" class="Symbol">)</a> <a id="11866" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a></span><span class="alternate Function">≤</span></span>
    <a id="11872" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11874" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11876" class="Symbol">(</a><a id="11877" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11879" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="11881" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11882" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="11891" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">≤⟨</a> <a id="11894" href="Data.Nat.Properties.html#25321" class="Function">*-monoˡ-≤</a> <a id="11904" class="Symbol">(</a><a id="11905" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11907" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="11909" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11910" class="Symbol">)</a> <a id="11912" class="Symbol">(</a><a id="11913" href="Data.Nat.Properties.html#26034" class="Function">m≤m*n</a> <a id="11919" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11921" class="Symbol">(</a><a id="11922" href="Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="11926" href="Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="11929" class="Symbol">))</a> <a id="11932" href="Relation.Binary.Reasoning.Base.Triple.html#3745" class="Function">⟩</a></span><span class="alternate Function">≤</span></span>
    <a id="11938" class="Symbol">(</a><a id="11939" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11941" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11943" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a><a id="11944" class="Symbol">)</a> <a id="11946" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11948" class="Symbol">(</a><a id="11949" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11951" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="11953" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11954" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function"><a id="11957" href="Relation.Binary.Reasoning.Base.Triple.html#4518" class="Function">≡⟨</a> <a id="11960" href="Data.Nat.Properties.html#21046" class="Function">*-assoc</a> <a id="11968" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11970" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11972" class="Symbol">(</a><a id="11973" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11975" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="11977" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11978" class="Symbol">)</a> <a id="11980" href="Relation.Binary.Reasoning.Base.Triple.html#4518" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="11986" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11988" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11990" class="Symbol">(</a><a id="11991" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11993" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="11995" class="Symbol">(</a><a id="11996" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11998" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12000" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="12001" class="Symbol">))</a>
  <a id="12006" href="Relation.Binary.Reasoning.Base.Triple.html#5119" class="Function Operator">∎</a>
  <a id="12010" class="Keyword">where</a>
    <a id="12020" class="Keyword">open</a> <a id="12025" href="blog/complexity-analysis/index.html#10572" class="Module">O</a> <a id="12027" href="blog/complexity-analysis/index.html#11768" class="Bound">o</a>
    <a id="12033" class="Keyword">open</a> <a id="12038" href="Data.Nat.Properties.html#12478" class="Module">≤-Reasoning</a>
</pre>
<p>However, the challenge is and has always been to simplify the construction of <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> bounds. Thus, we’d like the ability to remove low-order terms from <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>s. We can do this by eliminating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> whenever there is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">n^{k&#39;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9425em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> term around with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">k \leq k&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>:</span></p>
<pre class="Agda"><a id="12328" class="Keyword">postulate</a>
  <a id="O-drop-low"></a><a id="12340" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a>
    <a id="12355" class="Symbol">:</a> <a id="12357" class="Symbol">{</a><a id="12358" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12360" href="blog/complexity-analysis/index.html#12360" class="Bound">x</a> <a id="12362" href="blog/complexity-analysis/index.html#12362" class="Bound">y</a> <a id="12364" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12366" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a> <a id="12369" class="Symbol">:</a> <a id="12371" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12372" class="Symbol">}</a>
    <a id="12378" class="Symbol">→</a> <a id="12380" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12382" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="12384" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a>
    <a id="12391" class="Symbol">→</a> <a id="12393" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12396" class="Symbol">(\</a><a id="12398" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12400" class="Symbol">→</a> <a id="12402" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12404" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12406" href="blog/complexity-analysis/index.html#12360" class="Bound">x</a> <a id="12408" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="12410" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12412" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12414" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12416" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12418" href="blog/complexity-analysis/index.html#12362" class="Bound">y</a> <a id="12420" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="12422" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12424" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12426" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a><a id="12428" class="Symbol">)</a>
    <a id="12434" class="Symbol">→</a> <a id="12436" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12439" class="Symbol">(\</a><a id="12441" href="blog/complexity-analysis/index.html#12441" class="Bound">n</a> <a id="12443" class="Symbol">→</a> <a id="12445" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12447" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12449" href="blog/complexity-analysis/index.html#12441" class="Bound">n</a> <a id="12451" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12453" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a><a id="12455" class="Symbol">)</a>
</pre>
<p>The <code>z</code> variable here lets us compose <span class="Agda"><a href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a></span> terms, by subsequently instantiating</p>
<p>As a special case, we can eliminate constant terms via <span class="Agda"><a href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a></span> by first expanding constant terms to be coefficients of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">n^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>:</span></p>
<pre class="Agda"><a id="O-drop-1"></a><a id="12701" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a>
  <a id="12712" class="Symbol">:</a> <a id="12714" class="Symbol">{</a><a id="12715" href="blog/complexity-analysis/index.html#12715" class="Bound">x</a> <a id="12717" href="blog/complexity-analysis/index.html#12717" class="Bound">y</a> <a id="12719" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a> <a id="12721" class="Symbol">:</a> <a id="12723" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="12724" class="Symbol">}</a>
  <a id="12728" class="Symbol">→</a> <a id="12730" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12733" class="Symbol">(\</a><a id="12735" href="blog/complexity-analysis/index.html#12735" class="Bound">n</a> <a id="12737" class="Symbol">→</a> <a id="12739" href="blog/complexity-analysis/index.html#12715" class="Bound">x</a> <a id="12741" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12743" href="blog/complexity-analysis/index.html#12717" class="Bound">y</a> <a id="12745" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="12747" href="blog/complexity-analysis/index.html#12735" class="Bound">n</a> <a id="12749" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12751" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a><a id="12752" class="Symbol">)</a>
  <a id="12756" class="Symbol">→</a> <a id="12758" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12761" class="Symbol">(\</a><a id="12763" href="blog/complexity-analysis/index.html#12763" class="Bound">n</a> <a id="12765" class="Symbol">→</a> <a id="12767" href="blog/complexity-analysis/index.html#12763" class="Bound">n</a> <a id="12769" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="12771" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a><a id="12772" class="Symbol">)</a>
<a id="12774" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="12783" class="Symbol">{</a><a id="12784" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12785" class="Symbol">}</a> <a id="12787" class="Symbol">{</a><a id="12788" href="blog/complexity-analysis/index.html#12788" class="Bound">y</a><a id="12789" class="Symbol">}</a> <a id="12791" class="Symbol">{</a><a id="12792" href="blog/complexity-analysis/index.html#12792" class="Bound">k</a><a id="12793" class="Symbol">}</a> <a id="12795" href="blog/complexity-analysis/index.html#12795" class="Bound">o</a> <a id="12797" class="Keyword">rewrite</a> <a id="12805" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="12809" class="Symbol">(</a><a id="12810" href="Data.Nat.Properties.html#20010" class="Function">*-identityʳ</a> <a id="12822" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12823" class="Symbol">)</a> <a id="12825" class="Symbol">=</a>
  <a id="12829" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a> <a id="12840" class="Symbol">{</a><a id="12841" class="Number">0</a><a id="12842" class="Symbol">}</a> <a id="12844" class="Symbol">{</a><a id="12845" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12846" class="Symbol">}</a> <a id="12848" class="Symbol">{</a><a id="12849" href="blog/complexity-analysis/index.html#12788" class="Bound">y</a><a id="12850" class="Symbol">}</a> <a id="12852" class="Symbol">{</a><a id="12853" class="Argument">k</a> <a id="12855" class="Symbol">=</a> <a id="12857" class="Number">0</a><a id="12858" class="Symbol">}</a> <a id="12860" class="Symbol">{</a><a id="12861" href="blog/complexity-analysis/index.html#12792" class="Bound">k</a><a id="12862" class="Symbol">}</a> <a id="12864" href="Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a> <a id="12868" href="blog/complexity-analysis/index.html#12795" class="Bound">o</a>
</pre>
<p>With these functions, we can now easily construct <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span> values for arbitrary one-variable functions:</p>
<pre class="Agda"><a id="12987" href="blog/complexity-analysis/index.html#12987" class="Function">_</a> <a id="12989" class="Symbol">:</a> <a id="12991" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12994" class="Symbol">(</a><a id="12995" href="Data.Nat.Base.html#3471" class="Function Operator">_^</a> <a id="12998" class="Number">1</a><a id="12999" class="Symbol">)</a>
<a id="13001" class="Symbol">_</a> <a id="13003" class="Symbol">=</a> <a id="13005" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="13014" class="Symbol">{</a><a id="13015" class="Number">4</a><a id="13016" class="Symbol">}</a> <a id="13018" class="Symbol">{</a><a id="13019" class="Number">5</a><a id="13020" class="Symbol">}</a> <a id="13022" class="Symbol">{</a><a id="13023" class="Number">1</a><a id="13024" class="Symbol">}</a> <a id="13026" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="13028" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="13036" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="13038" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13044" class="Symbol">\</a><a id="13045" href="blog/complexity-analysis/index.html#13045" class="Bound">n</a> <a id="13047" class="Symbol">→</a> <a id="13049" class="Number">4</a> <a id="13051" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="13053" class="Number">5</a> <a id="13055" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="13057" href="blog/complexity-analysis/index.html#13045" class="Bound">n</a> <a id="13059" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="13061" class="Number">1</a>

<a id="13064" href="blog/complexity-analysis/index.html#13064" class="Function">_</a> <a id="13066" class="Symbol">:</a> <a id="13068" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="13071" class="Symbol">(</a><a id="13072" href="Data.Nat.Base.html#3471" class="Function Operator">_^</a> <a id="13075" class="Number">2</a><a id="13076" class="Symbol">)</a>
<a id="13078" class="Symbol">_</a> <a id="13080" class="Symbol">=</a> <a id="13082" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="13091" class="Symbol">{</a><a id="13092" class="Number">4</a><a id="13093" class="Symbol">}</a> <a id="13095" class="Symbol">{</a><a id="13096" class="Number">1</a><a id="13097" class="Symbol">}</a> <a id="13099" class="Symbol">{</a><a id="13100" class="Number">2</a><a id="13101" class="Symbol">}</a>
  <a id="13105" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="13107" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a> <a id="13118" class="Symbol">{</a><a id="13119" class="Number">4</a><a id="13120" class="Symbol">}</a> <a id="13122" class="Symbol">{</a><a id="13123" class="Number">5</a><a id="13124" class="Symbol">}</a> <a id="13126" class="Symbol">{</a><a id="13127" class="Number">3</a><a id="13128" class="Symbol">}</a> <a id="13130" class="Symbol">{</a><a id="13131" class="Number">1</a><a id="13132" class="Symbol">}</a> <a id="13134" class="Symbol">{</a><a id="13135" class="Number">2</a><a id="13136" class="Symbol">}</a> <a id="13138" class="Symbol">(</a><a id="13139" href="Data.Nat.Base.html#1600" class="InductiveConstructor">s≤s</a> <a id="13143" href="Data.Nat.Base.html#1558" class="InductiveConstructor">z≤n</a><a id="13146" class="Symbol">)</a>
  <a id="13150" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="13152" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="13160" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="13162" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13168" class="Symbol">\</a><a id="13169" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13171" class="Symbol">→</a> <a id="13173" class="Number">4</a> <a id="13175" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="13177" class="Number">5</a> <a id="13179" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="13181" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13183" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="13185" class="Number">1</a> <a id="13187" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="13189" class="Number">3</a> <a id="13191" href="Agda.Builtin.Nat.html#528" class="Primitive Operator">*</a> <a id="13193" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13195" href="Data.Nat.Base.html#3471" class="Function Operator">^</a> <a id="13197" class="Number">2</a>
</pre>
<p>Finally, we just need to build a version of <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> that is adequately lifted over the same functions we use for <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>:</p>
<pre class="Agda"><a id="13341" class="Keyword">abstract</a>
  <a id="OThunk"></a><a id="13352" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13359" class="Symbol">:</a> <a id="13361" class="Symbol">{</a><a id="13362" href="blog/complexity-analysis/index.html#13362" class="Bound">vars</a> <a id="13367" class="Symbol">:</a> <a id="13369" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13370" class="Symbol">}</a> <a id="13372" class="Symbol">→</a> <a id="13374" class="Symbol">(</a><a id="13375" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="13379" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="13381" href="blog/complexity-analysis/index.html#13362" class="Bound">vars</a> <a id="13386" class="Symbol">→</a> <a id="13388" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13389" class="Symbol">)</a> <a id="13391" class="Symbol">→</a> <a id="13393" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="13397" class="Symbol">→</a> <a id="13399" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="13405" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13412" class="Symbol">_</a> <a id="13414" href="blog/complexity-analysis/index.html#13414" class="Bound">a</a> <a id="13416" class="Symbol">=</a> <a id="13418" href="blog/complexity-analysis/index.html#13414" class="Bound">a</a>

  <a id="OThunk&#39;"></a><a id="13423" href="blog/complexity-analysis/index.html#13423" class="Function">OThunk&#39;</a> <a id="13431" class="Symbol">:</a> <a id="13433" class="Symbol">(</a><a id="13434" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="13436" class="Symbol">→</a> <a id="13438" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13439" class="Symbol">)</a> <a id="13441" class="Symbol">→</a> <a id="13443" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="13447" class="Symbol">→</a> <a id="13449" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="13455" href="blog/complexity-analysis/index.html#13423" class="Function">OThunk&#39;</a> <a id="13463" href="blog/complexity-analysis/index.html#13463" class="Bound">f</a> <a id="13465" class="Symbol">=</a> <a id="13467" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13474" class="Symbol">(</a><a id="13475" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13481" href="blog/complexity-analysis/index.html#13463" class="Bound">f</a><a id="13482" class="Symbol">)</a>
</pre>
<p>The <span class="Agda"><a href="blog/complexity-analysis/index.html#13586" class="Function">limit</a></span> function can be used to lift a <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> into an <span class="Agda"><a href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a></span>:</p>
<pre class="Agda">  <a id="limit"></a><a id="13586" href="blog/complexity-analysis/index.html#13586" class="Function">limit</a>
    <a id="13596" class="Symbol">:</a> <a id="13598" class="Symbol">{</a><a id="13599" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a> <a id="13604" class="Symbol">:</a> <a id="13606" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13607" class="Symbol">}</a> <a id="13609" class="Symbol">{</a><a id="13610" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a> <a id="13612" class="Symbol">:</a> <a id="13614" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="13618" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="13620" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a> <a id="13625" class="Symbol">→</a> <a id="13627" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="13628" class="Symbol">}</a> <a id="13630" class="Symbol">{</a><a id="13631" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a> <a id="13633" class="Symbol">:</a> <a id="13635" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="13638" class="Symbol">}</a>
    <a id="13644" class="Symbol">→</a> <a id="13646" class="Symbol">(</a><a id="13647" href="blog/complexity-analysis/index.html#13647" class="Bound">v</a> <a id="13649" class="Symbol">:</a> <a id="13651" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="13655" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="13657" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a><a id="13661" class="Symbol">)</a>
    <a id="13667" class="Symbol">→</a> <a id="13669" class="Symbol">(</a><a id="13670" href="blog/complexity-analysis/index.html#13670" class="Bound">o</a> <a id="13672" class="Symbol">:</a> <a id="13674" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="13676" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a><a id="13677" class="Symbol">)</a>
    <a id="13683" class="Symbol">→</a> <a id="13685" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="13691" class="Symbol">(</a><a id="13692" href="blog/complexity-analysis/index.html#13670" class="Bound">o</a> <a id="13694" class="Symbol">.</a><a id="13695" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="13699" href="blog/complexity-analysis/index.html#13647" class="Bound">v</a><a id="13700" class="Symbol">)</a> <a id="13702" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a> <a id="13704" class="Symbol">→</a> <a id="13706" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13713" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a> <a id="13715" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a>
  <a id="13719" href="blog/complexity-analysis/index.html#13586" class="Function">limit</a> <a id="13725" class="Symbol">_</a> <a id="13727" class="Symbol">_</a> <a id="13729" href="blog/complexity-analysis/index.html#13729" class="Bound">x</a> <a id="13731" class="Symbol">=</a> <a id="13733" href="blog/complexity-analysis/index.html#13729" class="Bound">x</a>
</pre>
<p>and we can now give an asymptotic bound over <span class="Agda"><a href="blog/complexity-analysis/index.html#7410" class="Function">sort</a></span>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>o2 <span class="op">:</span> <span class="dt">O&#39;</span> (_<span class="op">^</span> <span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>o2 <span class="ot">=</span> <span class="dt">O</span><span class="op">-</span><span class="fu">drop</span><span class="op">-</span><span class="dv">1</span> {<span class="dv">1</span>} {<span class="dv">5</span>} {<span class="dv">1</span>} <span class="op">$</span> <span class="dt">O</span><span class="op">-</span>build <span class="op">$</span> hoist \n <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">*</span> n</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>linearHeadSort <span class="op">:</span> <span class="dt">Vec</span> a n → <span class="dt">OThunk&#39;</span> (_<span class="op">^</span> <span class="dv">1</span>) (<span class="dt">VecL</span> a (<span class="dv">4</span> <span class="op">*</span> n) n)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>linearHeadSort {n <span class="ot">=</span> n} v <span class="ot">=</span> limit (n ∷ []) o2 <span class="op">$</span> <span class="fu">sort</span> v</span></code></pre></div>
<h2 id="conclusions"><a href="#conclusions" class="header-link">Conclusions<span class="header-link-emoji">🔗</span></a></h2>
<p>I’m traveling right now, and ran out of internet on publication day, which means I don’t have a copy of the paper in front of me as I write this (foolish!) Overall, the paper is slightly interesting, though I don’t think there’s anything especially novel here. Sticking the runtime behavior into the type is pretty much babby’s first example of graded monads, and we don’t even get asymptotics out of it! Instead we need to push big polynomials around, and explicitly call <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span> to make different branches work out.</p>
<p>The <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> stuff I’ve presented here alleviates a few of those problems; as it allows us to relatively-easily throw away the polynomials and just work with the highest order terms. A probably better approach would be to throw away the functions, and use a canonical normalizing-form to express the asymptotes. Then we could define a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\lub</mtext></mstyle></mrow><annotation encoding="application/x-tex">\lub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\lub</span></span></span></span></span> operator over <span class="Agda"><a href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a></span>s, and define:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>_<span class="op">&gt;&gt;=</span>_ <span class="op">:</span> <span class="dt">OThunk</span> f a → (a → <span class="dt">OThunk</span> g b) → <span class="dt">OThunk</span> (f ⊔ g) b</span></code></pre></div>
<p>to let us work compositionally in the land of big O.</p>
<p>My biggest takeaway here is that the techniques described in this paper are probably not powerful enough to be used in anger. Or, at least, not if you actually want to get any work done. Between the monads, polynomials, and waiting, the experience could use a lot of TLC.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: A Very Elementary Introduction to Sheaves</title>
      <id>blog/sheafs/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/sheafs/index.html'/>
      <published>2022-02-27</published>
      <updated>2022-02-27</updated>

      <content type="html">
        <![CDATA[
        <pre class="Agda"><a id="179" class="Symbol">{-#</a> <a id="183" class="Keyword">OPTIONS</a> <a id="191" class="Pragma">--type-in-type</a> <a id="206" class="Symbol">#-}</a>

<a id="211" class="Keyword">module</a> <a id="218" href="blog/sheafs/index.html" class="Module">blog.sheafs</a> <a id="230" class="Keyword">where</a>

<a id="237" class="Keyword">open</a> <a id="242" class="Keyword">import</a> <a id="249" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="262" class="Keyword">hiding</a> <a id="269" class="Symbol">(</a><a id="270" href="Data.Integer.Base.html#2189" class="Datatype Operator">_&lt;_</a><a id="273" class="Symbol">)</a>
<a id="275" class="Keyword">open</a> <a id="280" class="Keyword">import</a> <a id="287" href="Data.Integer.Properties.html" class="Module">Data.Integer.Properties</a>
              <a id="325" class="Keyword">using</a> <a id="331" class="Symbol">(</a><a id="332" href="Data.Integer.Properties.html#43999" class="Function">*-zeroˡ</a><a id="339" class="Symbol">;</a> <a id="341" href="Data.Integer.Properties.html#2839" class="Function">≤-reflexive</a><a id="352" class="Symbol">;</a> <a id="354" href="Data.Integer.Properties.html#3004" class="Function">≤-trans</a><a id="361" class="Symbol">)</a>
<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="384" class="Keyword">hiding</a> <a id="391" class="Symbol">(</a><a id="392" href="Data.Vec.Base.html#3807" class="Function">restrict</a><a id="400" class="Symbol">;</a> <a id="402" href="Data.Vec.Base.html#7774" class="Function">reverse</a><a id="409" class="Symbol">)</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="Categories.html" class="Module">Categories</a>
<a id="434" class="Keyword">open</a> <a id="439" class="Keyword">import</a> <a id="446" href="Category.LIN.html" class="Module">Category.LIN</a>
<a id="459" class="Keyword">open</a> <a id="464" class="Keyword">import</a> <a id="471" href="Category.SET.html" class="Module">Category.SET</a>
<a id="484" class="Keyword">open</a> <a id="489" class="Keyword">import</a> <a id="496" href="Category.AGRP.html" class="Module">Category.AGRP</a>
<a id="510" class="Keyword">open</a> <a id="515" class="Keyword">import</a> <a id="522" href="Category.MyFunctor.html" class="Module">Category.MyFunctor</a>
<a id="541" class="Keyword">import</a> <a id="548" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="586" class="Symbol">as</a> <a id="589" class="Module">Eq</a>

<a id="593" class="Keyword">open</a> <a id="598" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="601" class="Keyword">using</a> <a id="607" class="Symbol">(</a><a id="608" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="611" class="Symbol">;</a> <a id="613" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="617" class="Symbol">;</a> <a id="619" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="622" class="Symbol">;</a> <a id="624" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="628" class="Symbol">)</a>
<a id="630" class="Keyword">open</a> <a id="635" href="Category.LIN.html#303" class="Module">LinMap</a>
</pre>
<p>A while back I reviewed some paper (maybe codata? — too lazy to check) and came away thinking “I should learn more about presheaves.” The first paper I found is <a href="https://arxiv.org/pdf/2202.01379.pdf">A Very Elementary Introduction to Sheaves</a> by Mark Agrios, and mildly interestingly, was published less than three weeks ago.</p>
<p>The paper is called “very elementary,” and in the first sentence states it “is a very non-rigorous, loose, and extremely basic introduction to sheaves,” and it delivers on these promises. There is a section on metaphorically what a sheaf is, and then two somewhat-worked examples.</p>
<p>After reading through the paper, I feel like I have a very rough idea of what a sheaf is, and thought that this would be an excellent opportunity to flex my category theory muscles. That is, can I correctly generalize from these two examples to a solid category theoretical definition of a sheaf? I’m not sure, but this is a unique opportunity, so it’s worth a shot.</p>
<h2 id="the-metaphor"><a href="#the-metaphor" class="header-link">The Metaphor<span class="header-link-emoji">🔗</span></a></h2>
<p>The central metaphor of the paper is that a sheaf enriches some mathematical structure, much like a garden enriches a plot of dirt. There are lots of gardens you could make on a plot of dirt, and then you can harvest things from them. I guess this makes sense to the author, but it doesn’t particularly help me. I suspect this is an example of the monad tutorial fallacy in the wild: after thinking really hard about an idea for a while, the author came up with a metaphor that really works for them. But, this metaphor is more an artifact of their thinking process than it is descriptive of the idea itself. Anyway, either way, I wasn’t able to extract much meaning here.</p>
<h2 id="example-graphs"><a href="#example-graphs" class="header-link">Example: Graphs<span class="header-link-emoji">🔗</span></a></h2>
<p>We can build a (pre-?)sheaf over a graph. By playing fast and loose with our types like mathematicians are so wont to do, we can model the edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>:</mo><msub><mi>V</mi><mi>i</mi></msub><mo>→</mo><msub><mi>V</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">e_{ij} : V_i \to V_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> in a graph as an “intersection of the nodes it connects.” The paper writes <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">e_{ij} &lt; v_i, v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>.</span> I’m not super sure what that means, but I think it’s saying that given some graph <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V, E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>,</span> we can say <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>⊆</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∪</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">e_{ij} \subseteq v_i \cup v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9221em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>?</span> Except that this doesn’t typecheck, since <code>v_i</code> is an element of a set, not a set itself. I don’t know.</p>
<p>Anyway, the important thing here seems to be that there is a preorder between edges and vertices. So let’s quickly define a <code>Preorder</code>:</p>
<pre class="Agda"><a id="3005" class="Keyword">record</a> <a id="Preorder"></a><a id="3012" href="blog/sheafs/index.html#3012" class="Record">Preorder</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3027" class="Keyword">where</a>
  <a id="3035" class="Keyword">field</a>
    <a id="Preorder.Carrier"></a><a id="3045" href="blog/sheafs/index.html#3045" class="Field">Carrier</a> <a id="3053" class="Symbol">:</a> <a id="3055" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="Preorder._&lt;_"></a><a id="3063" href="blog/sheafs/index.html#3063" class="Field Operator">_&lt;_</a> <a id="3067" class="Symbol">:</a> <a id="3069" href="blog/sheafs/index.html#3045" class="Field">Carrier</a> <a id="3077" class="Symbol">→</a> <a id="3079" href="blog/sheafs/index.html#3045" class="Field">Carrier</a> <a id="3087" class="Symbol">→</a> <a id="3089" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="Preorder.&lt;-refl"></a><a id="3097" href="blog/sheafs/index.html#3097" class="Field">&lt;-refl</a> <a id="3104" class="Symbol">:</a> <a id="3106" class="Symbol">(</a><a id="3107" href="blog/sheafs/index.html#3107" class="Bound">a</a> <a id="3109" class="Symbol">:</a> <a id="3111" href="blog/sheafs/index.html#3045" class="Field">Carrier</a><a id="3118" class="Symbol">)</a> <a id="3120" class="Symbol">→</a> <a id="3122" href="blog/sheafs/index.html#3107" class="Bound">a</a> <a id="3124" href="blog/sheafs/index.html#3063" class="Field Operator">&lt;</a> <a id="3126" href="blog/sheafs/index.html#3107" class="Bound">a</a>
    <a id="Preorder.&lt;-trans"></a><a id="3132" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="3140" class="Symbol">:</a> <a id="3142" class="Symbol">{</a><a id="3143" href="blog/sheafs/index.html#3143" class="Bound">a</a> <a id="3145" href="blog/sheafs/index.html#3145" class="Bound">b</a> <a id="3147" href="blog/sheafs/index.html#3147" class="Bound">c</a> <a id="3149" class="Symbol">:</a> <a id="3151" href="blog/sheafs/index.html#3045" class="Field">Carrier</a><a id="3158" class="Symbol">}</a> <a id="3160" class="Symbol">→</a> <a id="3162" href="blog/sheafs/index.html#3143" class="Bound">a</a> <a id="3164" href="blog/sheafs/index.html#3063" class="Field Operator">&lt;</a> <a id="3166" href="blog/sheafs/index.html#3145" class="Bound">b</a> <a id="3168" class="Symbol">→</a> <a id="3170" href="blog/sheafs/index.html#3145" class="Bound">b</a> <a id="3172" href="blog/sheafs/index.html#3063" class="Field Operator">&lt;</a> <a id="3174" href="blog/sheafs/index.html#3147" class="Bound">c</a> <a id="3176" class="Symbol">→</a> <a id="3178" href="blog/sheafs/index.html#3143" class="Bound">a</a> <a id="3180" href="blog/sheafs/index.html#3063" class="Field Operator">&lt;</a> <a id="3182" href="blog/sheafs/index.html#3147" class="Bound">c</a>
</pre>
<p>and then just forget about the whole graph thing, because I am not convinced it is a meaningful presentation. Instead, we’ll cheat, and just build exactly the object we want to discuss.</p>
<pre class="Agda"><a id="3380" class="Keyword">data</a> <a id="Ex"></a><a id="3385" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a> <a id="3388" class="Symbol">:</a> <a id="3390" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3394" class="Keyword">where</a>
  <a id="Ex.v1"></a><a id="3402" href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a>  <a id="3406" class="Symbol">:</a> <a id="3408" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a>
  <a id="Ex.v2"></a><a id="3413" href="blog/sheafs/index.html#3413" class="InductiveConstructor">v2</a>  <a id="3417" class="Symbol">:</a> <a id="3419" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a>
  <a id="Ex.e12"></a><a id="3424" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="3428" class="Symbol">:</a> <a id="3430" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a>
</pre>
<p>corresponding to this rather boring graph:</p>
<div class="diagram-container">
<img src="8166794173b950645ad7163ff8e67e41a056e9f6.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>We can then build a <span class="Agda"><a href="blog/sheafs/index.html#3012" class="Record">Preorder</a></span> on <span class="Agda"><a href="blog/sheafs/index.html#3385" class="Datatype">Ex</a></span> with explicit cases for <span class="Agda"><a href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a></span> being less than its vertices:</p>
<pre class="Agda"><a id="3709" class="Keyword">data</a> <a id="Ex&lt;"></a><a id="3714" href="blog/sheafs/index.html#3714" class="Datatype">Ex&lt;</a> <a id="3718" class="Symbol">:</a> <a id="3720" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a> <a id="3723" class="Symbol">→</a> <a id="3725" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a> <a id="3728" class="Symbol">→</a> <a id="3730" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3734" class="Keyword">where</a>
  <a id="Ex&lt;.e12&lt;v1"></a><a id="3742" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a> <a id="3749" class="Symbol">:</a> <a id="3751" href="blog/sheafs/index.html#3714" class="Datatype">Ex&lt;</a> <a id="3755" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="3759" href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a>
  <a id="Ex&lt;.e12&lt;v2"></a><a id="3764" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a> <a id="3771" class="Symbol">:</a> <a id="3773" href="blog/sheafs/index.html#3714" class="Datatype">Ex&lt;</a> <a id="3777" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="3781" href="blog/sheafs/index.html#3413" class="InductiveConstructor">v2</a>
</pre>
<p>and two cases to satisfy the preorder laws:</p>
<pre class="Agda">  <a id="Ex&lt;.ex&lt;-refl"></a><a id="3840" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="3849" class="Symbol">:</a> <a id="3851" class="Symbol">(</a><a id="3852" href="blog/sheafs/index.html#3852" class="Bound">x</a> <a id="3854" class="Symbol">:</a> <a id="3856" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a><a id="3858" class="Symbol">)</a> <a id="3860" class="Symbol">→</a> <a id="3862" href="blog/sheafs/index.html#3714" class="Datatype">Ex&lt;</a> <a id="3866" href="blog/sheafs/index.html#3852" class="Bound">x</a> <a id="3868" href="blog/sheafs/index.html#3852" class="Bound">x</a>
</pre>
<p>and then mechanically hook everything up:</p>
<pre class="Agda"><a id="3922" class="Keyword">module</a> <a id="3929" href="blog/sheafs/index.html#3929" class="Module">_</a> <a id="3931" class="Keyword">where</a>
  <a id="3939" class="Keyword">open</a> <a id="3944" href="blog/sheafs/index.html#3012" class="Module">Preorder</a>
  <a id="3955" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="3967" class="Symbol">:</a> <a id="3969" href="blog/sheafs/index.html#3012" class="Record">Preorder</a>
  <a id="3980" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="3992" class="Symbol">.</a><a id="3993" href="blog/sheafs/index.html#3045" class="Field">Carrier</a> <a id="4001" class="Symbol">=</a> <a id="4003" href="blog/sheafs/index.html#3385" class="Datatype">Ex</a>
  <a id="4008" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4020" class="Symbol">.</a><a id="4021" href="blog/sheafs/index.html#3063" class="Field Operator">_&lt;_</a> <a id="4025" class="Symbol">=</a> <a id="4027" href="blog/sheafs/index.html#3714" class="Datatype">Ex&lt;</a>
  <a id="4033" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4045" class="Symbol">.</a><a id="4046" href="blog/sheafs/index.html#3097" class="Field">&lt;-refl</a> <a id="4053" class="Symbol">=</a> <a id="4055" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a>
  <a id="4066" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4078" class="Symbol">.</a><a id="4079" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="4087" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a> <a id="4094" class="Symbol">(</a><a id="4095" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4104" class="DottedPattern Symbol">.</a><a id="4105" href="blog/sheafs/index.html#3402" class="DottedPattern InductiveConstructor">v1</a><a id="4107" class="Symbol">)</a> <a id="4109" class="Symbol">=</a> <a id="4111" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a>
  <a id="4120" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4132" class="Symbol">.</a><a id="4133" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="4141" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a> <a id="4148" class="Symbol">(</a><a id="4149" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4158" class="DottedPattern Symbol">.</a><a id="4159" href="blog/sheafs/index.html#3413" class="DottedPattern InductiveConstructor">v2</a><a id="4161" class="Symbol">)</a> <a id="4163" class="Symbol">=</a> <a id="4165" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a>
  <a id="4174" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4186" class="Symbol">.</a><a id="4187" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="4195" class="Symbol">(</a><a id="4196" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4205" class="Symbol">_)</a> <a id="4208" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a> <a id="4215" class="Symbol">=</a> <a id="4217" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a>
  <a id="4226" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4238" class="Symbol">.</a><a id="4239" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="4247" class="Symbol">(</a><a id="4248" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4257" class="Symbol">_)</a> <a id="4260" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a> <a id="4267" class="Symbol">=</a> <a id="4269" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a>
  <a id="4278" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a> <a id="4290" class="Symbol">.</a><a id="4291" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="4299" class="Symbol">(</a><a id="4300" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4309" href="blog/sheafs/index.html#4309" class="Bound">x</a><a id="4310" class="Symbol">)</a> <a id="4312" class="Symbol">(</a><a id="4313" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4322" class="Symbol">_)</a> <a id="4325" class="Symbol">=</a> <a id="4327" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="4336" href="blog/sheafs/index.html#4309" class="Bound">x</a>
</pre>
<p>The paper goes on to say we have some sheaf <code>F</code>, which maps <span class="Agda"><a href="blog/sheafs/index.html#3385" class="Datatype">Ex</a></span>s to “just about anything,” this codomain being called the <em>stalk.</em> For now, let’s assume it’s to <span class="Agda"><a href="Agda.Primitive.html#326" class="Primitive">Set</a></span>.</p>
<p>Furthermore, the sheaf <code>F</code> also has a “second mechanism,” which in our example maps an edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>:</mo><msub><mi>v</mi><mi>i</mi></msub><mo>→</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">e_{ij} : v_i \to v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> to two functions:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">;</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></msub><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>F</mi><mrow><msub><mi>v</mi><mi>j</mi></msub><mo separator="true">;</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></msub><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
F_{v_i;e_{ij}} : F(v_i) \to F(e_{ij}) \\
F_{v_j;e_{ij}} : F(v_j) \to F(e_{ij})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0307em;vertical-align:-0.3473em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">;</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0307em;vertical-align:-0.3473em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mpunct mtight">;</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>This is where some of the frustration in only being given examples comes in. Why are these in the definition of a sheaf? The only thing that could possibly make any sense to me is that this comes from a more general construction:</p>
<pre class="text"><code>restrict : (x y : Ex) → x &lt; y → Stalk y → Stalk x</code></pre>
<p>which states we have a mapping from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> if and only if we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x &lt; y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span> These <code>restrict</code> things are called <em>restriction maps</em>.</p>
<p>What’s further confusing is the following point:</p>
<blockquote>
<p>Since each stalk is a vector space, it is natural to have our restriction maps be linear transformations described by matrices.</p>
</blockquote>
<p>Why linear transformations, and not just arbitrary functions? When I hear “linear transformation” I think homomorphism, or more probably, morphism in some category. Which then probably means the <code>Stalk</code> isn’t a function to <span class="Agda"><a href="Agda.Primitive.html#326" class="Primitive">Set</a></span>, it’s a mapping into a category.</p>
<p>OK, so that all seems straightforward enough. Let’s try to formalize it.</p>
<pre class="Agda"><a id="5714" class="Keyword">module</a> <a id="Sheaf"></a><a id="5721" href="blog/sheafs/index.html#5721" class="Module">Sheaf</a> <a id="5727" class="Symbol">(</a><a id="5728" href="blog/sheafs/index.html#5728" class="Bound">pre</a> <a id="5732" class="Symbol">:</a> <a id="5734" href="blog/sheafs/index.html#3012" class="Record">Preorder</a><a id="5742" class="Symbol">)</a> <a id="5744" class="Symbol">(</a><a id="5745" href="blog/sheafs/index.html#5745" class="Bound">C</a> <a id="5747" class="Symbol">:</a> <a id="5749" href="Categories.html#257" class="Record">Category</a><a id="5757" class="Symbol">)</a> <a id="5759" class="Keyword">where</a>
  <a id="5767" class="Keyword">open</a> <a id="5772" href="blog/sheafs/index.html#3012" class="Module">Preorder</a> <a id="5781" href="blog/sheafs/index.html#5728" class="Bound">pre</a>
  <a id="5787" class="Keyword">open</a> <a id="5792" href="Categories.html#257" class="Module">Category</a> <a id="5801" href="blog/sheafs/index.html#5745" class="Bound">C</a>

  <a id="5806" class="Keyword">record</a> <a id="Sheaf.Sheaf"></a><a id="5813" href="blog/sheafs/index.html#5813" class="Record">Sheaf</a> <a id="5819" class="Symbol">:</a> <a id="5821" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="5825" class="Keyword">where</a>
    <a id="5835" class="Keyword">field</a>
      <a id="Sheaf.Sheaf.Stalk"></a><a id="5847" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="5853" class="Symbol">:</a> <a id="5855" href="blog/sheafs/index.html#3045" class="Function">Carrier</a> <a id="5863" class="Symbol">→</a> <a id="5865" href="Categories.html#362" class="Field">Obj</a>
      <a id="Sheaf.Sheaf.restrict"></a><a id="5875" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="5884" class="Symbol">:</a> <a id="5886" class="Symbol">{</a><a id="5887" href="blog/sheafs/index.html#5887" class="Bound">x</a> <a id="5889" href="blog/sheafs/index.html#5889" class="Bound">y</a> <a id="5891" class="Symbol">:</a> <a id="5893" href="blog/sheafs/index.html#3045" class="Function">Carrier</a><a id="5900" class="Symbol">}</a> <a id="5902" class="Symbol">→</a> <a id="5904" href="blog/sheafs/index.html#5887" class="Bound">x</a> <a id="5906" href="blog/sheafs/index.html#3063" class="Function Operator">&lt;</a> <a id="5908" href="blog/sheafs/index.html#5889" class="Bound">y</a> <a id="5910" class="Symbol">→</a> <a id="5912" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="5918" href="blog/sheafs/index.html#5889" class="Bound">y</a> <a id="5920" href="Categories.html#376" class="Field Operator">~&gt;</a> <a id="5923" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="5929" href="blog/sheafs/index.html#5887" class="Bound">x</a>
</pre>
<p>which seems reasonable. The paper now gives us a specific sheaf, with <span class="Agda"><a href="Data.Vec.Base.html#3807" class="Function">restrict</a></span> <span class="Agda"><a href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a></span> being the linear map encoded by the matrix:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
1 &amp; -1 \\
0 &amp; 2
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>which we can write as a morphism in <span class="Agda"><a href="Category.LIN.html#591" class="Function">LIN</a></span> (the category of linear algebra, with objects as vector spaces, and morphisms as linear maps):</p>
<!--
<pre class="Agda"><a id="6292" class="Keyword">module</a> <a id="6299" href="blog.sheafs.html#6299" class="Module">_</a> <a id="6301" class="Keyword">where</a>
  <a id="6309" class="Keyword">open</a> <a id="6314" href="Categories.html#257" class="Module">Category</a> <a id="6323" href="Category.LIN.html#591" class="Function">LIN</a>
  <a id="6329" class="Keyword">open</a> <a id="6334" href="blog.sheafs.html#5721" class="Module">Sheaf</a> <a id="6340" href="blog.sheafs.html#3955" class="Function">ex-preorder</a> <a id="6352" href="Category.LIN.html#591" class="Function">LIN</a>
  <a id="6358" class="Keyword">open</a> <a id="6363" href="blog.sheafs.html#5813" class="Module">Sheaf.Sheaf</a>

  <a id="6378" class="Keyword">postulate</a>
    <a id="6392" href="blog.sheafs.html#6392" class="Postulate">trustMe</a> <a id="6400" class="Symbol">:</a> <a id="6402" class="Symbol">∀</a> <a id="6404" class="Symbol">{</a><a id="6405" href="blog.sheafs.html#6405" class="Bound">A</a> <a id="6407" class="Symbol">:</a> <a id="6409" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6412" class="Symbol">}</a> <a id="6414" class="Symbol">{</a><a id="6415" href="blog.sheafs.html#6415" class="Bound">a</a> <a id="6417" href="blog.sheafs.html#6417" class="Bound">b</a> <a id="6419" class="Symbol">:</a> <a id="6421" href="blog.sheafs.html#6405" class="Bound">A</a><a id="6422" class="Symbol">}</a> <a id="6424" class="Symbol">→</a> <a id="6426" href="blog.sheafs.html#6415" class="Bound">a</a> <a id="6428" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6430" href="blog.sheafs.html#6417" class="Bound">b</a>
    <a id="6436" href="blog.sheafs.html#6436" class="Postulate">sorry</a> <a id="6442" class="Symbol">:</a> <a id="6444" class="Symbol">∀</a> <a id="6446" class="Symbol">{</a><a id="6447" href="blog.sheafs.html#6447" class="Bound">A</a> <a id="6449" class="Symbol">:</a> <a id="6451" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="6454" class="Symbol">}</a> <a id="6456" class="Symbol">→</a> <a id="6458" href="blog.sheafs.html#6447" class="Bound">A</a>
</pre>-->
<pre class="Agda">  <a id="6475" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a> <a id="6483" class="Symbol">:</a> <a id="6485" class="Number">2</a> <a id="6487" href="Categories.html#376" class="Function Operator">~&gt;</a> <a id="6490" class="Number">2</a>
  <a id="6494" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a> <a id="6502" class="Symbol">.</a><a id="6503" href="Category.LIN.html#344" class="Field">linmap</a> <a id="6510" class="Symbol">(</a><a id="6511" href="blog/sheafs/index.html#6511" class="Bound">x</a> <a id="6513" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="6515" href="blog/sheafs/index.html#6515" class="Bound">y</a> <a id="6517" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="6519" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="6521" class="Symbol">)</a> <a id="6523" class="Symbol">=</a>
    <a id="6529" class="Symbol">(</a><a id="6530" href="blog/sheafs/index.html#6511" class="Bound">x</a> <a id="6532" href="Data.Integer.Base.html#5023" class="Function Operator">-</a> <a id="6534" href="blog/sheafs/index.html#6515" class="Bound">y</a><a id="6535" class="Symbol">)</a>   <a id="6539" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a>
    <a id="6545" class="Symbol">(</a><a id="6546" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="6548" class="Number">2</a> <a id="6550" href="Data.Integer.Base.html#5169" class="Function Operator">*</a> <a id="6552" href="blog/sheafs/index.html#6515" class="Bound">y</a><a id="6553" class="Symbol">)</a> <a id="6555" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a>
             <a id="6570" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="6575" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a> <a id="6583" class="Symbol">.</a><a id="6584" href="Category.LIN.html#375" class="Field">preserves-+</a> <a id="6596" href="blog/sheafs/index.html#6596" class="Bound">u</a> <a id="6598" href="blog/sheafs/index.html#6598" class="Bound">v</a> <a id="6600" class="Symbol">=</a> <a id="6602" href="blog/sheafs/index.html#6392" class="Postulate">trustMe</a>
  <a id="6612" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a> <a id="6620" class="Symbol">.</a><a id="6621" href="Category.LIN.html#478" class="Field">preserves-*</a> <a id="6633" href="blog/sheafs/index.html#6633" class="Bound">a</a> <a id="6635" href="blog/sheafs/index.html#6635" class="Bound">v</a> <a id="6637" class="Symbol">=</a> <a id="6639" href="blog/sheafs/index.html#6392" class="Postulate">trustMe</a>
</pre>
<p>and <span class="Agda"><a href="Data.Vec.Base.html#3807" class="Function">restrict</a></span> <span class="Agda"><a href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a></span> being the linear map encoded by the matrix:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
3 &amp; 1 &amp; -1 \\
2 &amp; 0 &amp; 2
\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>written as:</p>
<pre class="Agda">  <a id="6815" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a> <a id="6823" class="Symbol">:</a> <a id="6825" class="Number">3</a> <a id="6827" href="Categories.html#376" class="Function Operator">~&gt;</a> <a id="6830" class="Number">2</a>
  <a id="6834" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a> <a id="6842" class="Symbol">.</a><a id="6843" href="Category.LIN.html#344" class="Field">linmap</a> <a id="6850" class="Symbol">(</a><a id="6851" href="blog/sheafs/index.html#6851" class="Bound">x</a> <a id="6853" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="6855" href="blog/sheafs/index.html#6855" class="Bound">y</a> <a id="6857" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="6859" href="blog/sheafs/index.html#6859" class="Bound">z</a> <a id="6861" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="6863" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="6865" class="Symbol">)</a> <a id="6867" class="Symbol">=</a>
    <a id="6873" class="Symbol">(</a><a id="6874" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="6876" class="Number">3</a> <a id="6878" href="Data.Integer.Base.html#5169" class="Function Operator">*</a> <a id="6880" href="blog/sheafs/index.html#6851" class="Bound">x</a> <a id="6882" href="Data.Integer.Base.html#4844" class="Function Operator">+</a> <a id="6884" href="blog/sheafs/index.html#6855" class="Bound">y</a> <a id="6886" href="Data.Integer.Base.html#5023" class="Function Operator">-</a> <a id="6888" href="blog/sheafs/index.html#6859" class="Bound">z</a><a id="6889" class="Symbol">)</a>   <a id="6893" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a>
    <a id="6899" class="Symbol">(</a><a id="6900" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="6902" class="Number">2</a> <a id="6904" href="Data.Integer.Base.html#5169" class="Function Operator">*</a> <a id="6906" href="blog/sheafs/index.html#6851" class="Bound">x</a> <a id="6908" href="Data.Integer.Base.html#4844" class="Function Operator">+</a> <a id="6910" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="6912" class="Number">2</a> <a id="6914" href="Data.Integer.Base.html#5169" class="Function Operator">*</a> <a id="6916" href="blog/sheafs/index.html#6859" class="Bound">z</a><a id="6917" class="Symbol">)</a> <a id="6919" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a>
                       <a id="6944" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="6949" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a> <a id="6957" class="Symbol">.</a><a id="6958" href="Category.LIN.html#375" class="Field">preserves-+</a> <a id="6970" href="blog/sheafs/index.html#6970" class="Bound">u</a> <a id="6972" href="blog/sheafs/index.html#6972" class="Bound">v</a> <a id="6974" class="Symbol">=</a> <a id="6976" href="blog/sheafs/index.html#6392" class="Postulate">trustMe</a>
  <a id="6986" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a> <a id="6994" class="Symbol">.</a><a id="6995" href="Category.LIN.html#478" class="Field">preserves-*</a> <a id="7007" href="blog/sheafs/index.html#7007" class="Bound">a</a> <a id="7009" href="blog/sheafs/index.html#7009" class="Bound">v</a> <a id="7011" class="Symbol">=</a> <a id="7013" href="blog/sheafs/index.html#6392" class="Postulate">trustMe</a>
</pre>
<p>Thus, we can finally build the example <code>Sheaf</code>:</p>
<pre class="Agda">  <a id="7081" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7084" class="Symbol">:</a> <a id="7086" href="blog/sheafs/index.html#5813" class="Record">Sheaf</a>
  <a id="7094" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7097" class="Symbol">.</a><a id="7098" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="7104" href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a>  <a id="7108" class="Symbol">=</a> <a id="7110" class="Number">2</a>
  <a id="7114" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7117" class="Symbol">.</a><a id="7118" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="7124" href="blog/sheafs/index.html#3413" class="InductiveConstructor">v2</a>  <a id="7128" class="Symbol">=</a> <a id="7130" class="Number">3</a>
  <a id="7134" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7137" class="Symbol">.</a><a id="7138" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="7144" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="7148" class="Symbol">=</a> <a id="7150" class="Number">2</a>
  <a id="7154" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7157" class="Symbol">.</a><a id="7158" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="7167" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a> <a id="7174" class="Symbol">=</a> <a id="7176" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a>
  <a id="7186" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7189" class="Symbol">.</a><a id="7190" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="7199" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a> <a id="7206" class="Symbol">=</a> <a id="7208" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a>
  <a id="7218" href="blog/sheafs/index.html#7081" class="Function">ex</a> <a id="7221" class="Symbol">.</a><a id="7222" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="7231" class="Symbol">(</a><a id="7232" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="7241" href="blog/sheafs/index.html#7241" class="Bound">z</a><a id="7242" class="Symbol">)</a> <a id="7244" class="Symbol">=</a> <a id="7246" href="Categories.html#648" class="Function">id</a>
</pre>
<p>What’s with the <span class="Agda"><a href="blog/sheafs/index.html#5847" class="Field">Stalk</a></span> of <span class="Agda"><a href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a></span> being 2, you might ask? Remember, the stalk is an object in some category, in this case <span class="Agda"><a href="Category.LIN.html#591" class="Function">LIN</a></span>. Objects in <span class="Agda"><a href="Category.LIN.html#591" class="Function">LIN</a></span> are natural numbers, corresponding to the length of vectors.</p>
<h3 id="sections-and-global-sections"><a href="#sections-and-global-sections" class="header-link">Sections and Global Sections<span class="header-link-emoji">🔗</span></a></h3>
<p>Here’s where our categorical generalization of the paper goes a bit haywire. The paper defines a <em>section</em> as picking an element from each <span class="Agda"><a href="blog/sheafs/index.html#5847" class="Field">Stalk</a></span> of the sheaf. He picks, for example:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>v</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
2 \\ 1
\end{bmatrix}
\in \text{Stalk } v1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>v</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
3 \\ -1 \\ 0
\end{bmatrix}
\in \text{Stalk } v2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.6667em" height="0.016em" style="width:0.6667em" viewBox="0 0 666.67 16" preserveAspectRatio="xMinYMin"><path d="M319 0 H403 V16 H319z M319 0 H403 V16 H319z"></path></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.6667em" height="0.016em" style="width:0.6667em" viewBox="0 0 666.67 16" preserveAspectRatio="xMinYMin"><path d="M263 0 H347 V16 H263z M263 0 H347 V16 H263z"></path></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">2</span></span></span></span></span></p>
<p>and</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>e</mi><mn>12</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
1 \\ -1
\end{bmatrix}
\in \text{Stalk } e12
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal">e</span><span class="mord">12</span></span></span></span></span></p>
<p>which is all fine and dandy, except that when we categorize, our objects no longer have internal structure. Fortunately, we can use “generalized elements,” a.k.a., morphisms out of the <span class="Agda"><a href="Categories.html#2711" class="Function">terminal</a></span> object.</p>
<!--
<pre class="Agda"><a id="8144" class="Keyword">module</a> <a id="BadSections"></a><a id="8151" href="blog.sheafs.html#8151" class="Module">BadSections</a>
         <a id="8172" class="Symbol">{</a><a id="8173" href="blog.sheafs.html#8173" class="Bound">pre</a> <a id="8177" class="Symbol">:</a> <a id="8179" href="blog.sheafs.html#3012" class="Record">Preorder</a><a id="8187" class="Symbol">}</a>
         <a id="8198" class="Symbol">{</a><a id="8199" href="blog.sheafs.html#8199" class="Bound">C</a> <a id="8201" class="Symbol">:</a> <a id="8203" href="Categories.html#257" class="Record">Category</a><a id="8211" class="Symbol">}</a>
         <a id="8222" class="Symbol">(</a><a id="8223" href="blog.sheafs.html#8223" class="Bound">term</a> <a id="8228" class="Symbol">:</a> <a id="8230" href="Categories.html#2671" class="Record">HasTerminal</a> <a id="8242" href="blog.sheafs.html#8199" class="Bound">C</a><a id="8243" class="Symbol">)</a>
         <a id="8254" class="Symbol">(</a><a id="8255" href="blog.sheafs.html#8255" class="Bound">sheaf</a> <a id="8261" class="Symbol">:</a> <a id="8263" href="blog.sheafs.html#5813" class="Record">Sheaf.Sheaf</a> <a id="8275" href="blog.sheafs.html#8173" class="Bound">pre</a> <a id="8279" href="blog.sheafs.html#8199" class="Bound">C</a><a id="8280" class="Symbol">)</a> <a id="8282" class="Keyword">where</a>
  <a id="8290" class="Keyword">open</a> <a id="8295" href="Categories.html#2671" class="Module">HasTerminal</a> <a id="8307" href="blog.sheafs.html#8223" class="Bound">term</a>
  <a id="8314" class="Keyword">open</a> <a id="8319" href="blog.sheafs.html#3012" class="Module">Preorder</a> <a id="8328" href="blog.sheafs.html#8173" class="Bound">pre</a>
  <a id="8334" class="Keyword">open</a> <a id="8339" href="blog.sheafs.html#5813" class="Module">Sheaf.Sheaf</a> <a id="8351" href="blog.sheafs.html#8255" class="Bound">sheaf</a>
  <a id="8359" class="Keyword">open</a> <a id="8364" href="Categories.html#257" class="Module">Category</a> <a id="8373" href="blog.sheafs.html#8199" class="Bound">C</a>
</pre>-->
<pre class="Agda">  <a id="BadSections.Section"></a><a id="8390" href="blog/sheafs/index.html#8390" class="Function">Section</a> <a id="8398" class="Symbol">:</a> <a id="8400" href="blog/sheafs/index.html#3045" class="Function">Carrier</a> <a id="8408" class="Symbol">→</a> <a id="8410" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="8416" href="blog/sheafs/index.html#8390" class="Function">Section</a> <a id="8424" href="blog/sheafs/index.html#8424" class="Bound">c</a> <a id="8426" class="Symbol">=</a> <a id="8428" href="Categories.html#2711" class="Function">terminal</a> <a id="8437" href="Categories.html#376" class="Function Operator">~&gt;</a> <a id="8440" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="8446" href="blog/sheafs/index.html#8424" class="Bound">c</a>
</pre>
<p>That is, a <span class="Agda"><a href="blog/sheafs/index.html#8390" class="Function">Section</a></span> is a mapping from every element in the <span class="Agda"><a href="blog/sheafs/index.html#3012" class="Record">Preorder</a></span> to a generalized element of its <span class="Agda"><a href="blog/sheafs/index.html#5847" class="Field">Stalk</a></span>. We can evaluate a <span class="Agda"><a href="blog/sheafs/index.html#8390" class="Function">Section</a></span> by checking the commutativity of all <span class="Agda"><a href="Data.Vec.Base.html#3807" class="Function">restrict</a></span>s. That is, we’d like the following diagram to commute:</p>
<div class="diagram-container">
<img src="0680ae3cf1615f7e2348b22ea86fd926ed0e9144.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>Doing this in Agda is hard because it wants lots of dumb arithmetic proofs, so instead we’ll make ourselves content with some by-hand math:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mo>∘</mo><mi>S</mi><mi>v</mi><mn>1</mn><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo mathvariant="normal">≠</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">
r \circ S v1
=  \begin{bmatrix}
      1 &amp; -1 \\
      0 &amp; 2
    \end{bmatrix}
    \begin{bmatrix}
      2 \\ 1
    \end{bmatrix}
=  \begin{bmatrix}
      1 \\
      2
    \end{bmatrix}
\neq
    \begin{bmatrix}
    1 \\ -1
    \end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>So, our chosen <span class="Agda"><a href="blog/sheafs/index.html#8390" class="Function">Section</a></span> doesn’t commute. That is, it doesn’t respect the global equalities, thus it is not a <em>global section.</em> Sounds like something worth formalizing:</p>
<pre class="Agda">  <a id="9588" class="Keyword">record</a> <a id="BadSections.GlobalSection"></a><a id="9595" href="blog/sheafs/index.html#9595" class="Record">GlobalSection</a> <a id="9609" class="Symbol">:</a> <a id="9611" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="9615" class="Keyword">where</a>
    <a id="9625" class="Keyword">field</a>
      <a id="BadSections.GlobalSection.section"></a><a id="9637" href="blog/sheafs/index.html#9637" class="Field">section</a> <a id="9645" class="Symbol">:</a> <a id="9647" class="Symbol">forall</a> <a id="9654" class="Symbol">(</a><a id="9655" href="blog/sheafs/index.html#9655" class="Bound">c</a> <a id="9657" class="Symbol">:</a> <a id="9659" href="blog/sheafs/index.html#3045" class="Function">Carrier</a><a id="9666" class="Symbol">)</a> <a id="9668" class="Symbol">→</a> <a id="9670" href="blog/sheafs/index.html#8390" class="Function">Section</a> <a id="9678" href="blog/sheafs/index.html#9655" class="Bound">c</a>
      <a id="BadSections.GlobalSection.commutes"></a><a id="9686" href="blog/sheafs/index.html#9686" class="Field">commutes</a>
        <a id="9703" class="Symbol">:</a> <a id="9705" class="Symbol">{</a><a id="9706" href="blog/sheafs/index.html#9706" class="Bound">x</a> <a id="9708" href="blog/sheafs/index.html#9708" class="Bound">y</a> <a id="9710" class="Symbol">:</a> <a id="9712" href="blog/sheafs/index.html#3045" class="Function">Carrier</a><a id="9719" class="Symbol">}</a>
        <a id="9729" class="Symbol">→</a> <a id="9731" class="Symbol">(</a><a id="9732" href="blog/sheafs/index.html#9732" class="Bound">x&lt;y</a> <a id="9736" class="Symbol">:</a> <a id="9738" href="blog/sheafs/index.html#9706" class="Bound">x</a> <a id="9740" href="blog/sheafs/index.html#3063" class="Function Operator">&lt;</a> <a id="9742" href="blog/sheafs/index.html#9708" class="Bound">y</a><a id="9743" class="Symbol">)</a>
        <a id="9753" class="Symbol">→</a> <a id="9755" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="9764" href="blog/sheafs/index.html#9732" class="Bound">x&lt;y</a> <a id="9768" href="Categories.html#676" class="Function Operator">∘</a> <a id="9770" href="blog/sheafs/index.html#9637" class="Field">section</a> <a id="9778" href="blog/sheafs/index.html#9708" class="Bound">y</a> <a id="9780" href="Categories.html#450" class="Function Operator">≈</a> <a id="9782" href="blog/sheafs/index.html#9637" class="Field">section</a> <a id="9790" href="blog/sheafs/index.html#9706" class="Bound">x</a>
</pre>
<p>All that’s left is to find a <span class="Agda"><a href="blog/sheafs/index.html#9595" class="Record">GlobalSection</a></span> of our weird graph category:</p>
<!--
<pre class="Agda"><a id="9888" class="Keyword">module</a> <a id="BadEx"></a><a id="9895" href="blog.sheafs.html#9895" class="Module">BadEx</a> <a id="9901" class="Keyword">where</a>
  <a id="9909" class="Keyword">open</a> <a id="9914" href="blog.sheafs.html#3012" class="Module">Preorder</a>
  <a id="9925" class="Keyword">open</a> <a id="9930" href="Categories.html#257" class="Module">Category</a> <a id="9939" href="Category.LIN.html#591" class="Function">LIN</a>
  <a id="9945" class="Keyword">open</a> <a id="9950" href="blog.sheafs.html#5721" class="Module">Sheaf</a> <a id="9956" href="blog.sheafs.html#3955" class="Function">ex-preorder</a> <a id="9968" href="Category.LIN.html#591" class="Function">LIN</a>
  <a id="9974" class="Keyword">open</a> <a id="9979" href="blog.sheafs.html#5813" class="Module">Sheaf.Sheaf</a>
</pre>-->
<p>Unfortunately, this formalization doesn’t quite work out; there are no interesting arrows out of <span class="Agda"><a href="Categories.html#2711" class="Function">terminal</a></span>:</p>
<pre class="Agda">  <a id="BadEx.boring-arrows"></a><a id="10123" href="blog/sheafs/index.html#10123" class="Function">boring-arrows</a>
      <a id="10143" class="Symbol">:</a> <a id="10145" class="Symbol">(</a><a id="10146" href="blog/sheafs/index.html#10146" class="Bound">f</a> <a id="10148" class="Symbol">:</a> <a id="10150" class="Number">0</a> <a id="10152" href="Categories.html#376" class="Function Operator">~&gt;</a> <a id="10155" class="Number">1</a><a id="10156" class="Symbol">)</a>
      <a id="10164" class="Symbol">→</a> <a id="10166" class="Symbol">(</a><a id="10167" href="blog/sheafs/index.html#10167" class="Bound">x</a> <a id="10169" class="Symbol">:</a> <a id="10171" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="10175" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a> <a id="10177" class="Number">0</a><a id="10178" class="Symbol">)</a>
      <a id="10186" class="Symbol">→</a> <a id="10188" href="blog/sheafs/index.html#10146" class="Bound">f</a> <a id="10190" class="Symbol">.</a><a id="10191" href="Category.LIN.html#344" class="Field">linmap</a> <a id="10198" href="blog/sheafs/index.html#10167" class="Bound">x</a> <a id="10200" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="10202" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10204" class="Number">0</a> <a id="10206" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10208" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="10213" href="blog/sheafs/index.html#10123" class="Function">boring-arrows</a> <a id="10227" href="blog/sheafs/index.html#10227" class="Bound">f</a> <a id="10229" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="10232" class="Keyword">with</a> <a id="10237" href="blog/sheafs/index.html#10227" class="Bound">f</a> <a id="10239" class="Symbol">.</a><a id="10240" href="Category.LIN.html#344" class="Field">linmap</a> <a id="10247" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="10250" class="Keyword">in</a> <a id="10253" class="Argument">eq</a>
  <a id="10258" class="Symbol">...</a> <a id="10262" class="Symbol">|</a> <a id="10264" href="blog/sheafs/index.html#10264" class="Bound">x</a> <a id="10266" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10268" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="10271" class="Keyword">rewrite</a> <a id="10279" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="10283" href="blog/sheafs/index.html#10253" class="Bound">eq</a> <a id="10286" class="Symbol">=</a>
    <a id="10292" href="Relation.Binary.PropositionalEquality.Core.html#2806" class="Function Operator">begin</a>
      <a id="10304" class="Bound">f</a> <a id="10306" class="Symbol">.</a><a id="10307" href="Category.LIN.html#344" class="Field">linmap</a> <a id="10314" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>                 <a id="10333" href="Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="10343" class="Bound">f</a> <a id="10345" class="Symbol">.</a><a id="10346" href="Category.LIN.html#344" class="Field">linmap</a> <a id="10353" class="Symbol">(</a><a id="10354" href="Data.Vec.Base.html#2580" class="Function">map</a> <a id="10358" class="Symbol">(</a><a id="10359" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10361" class="Number">0</a> <a id="10363" href="Data.Integer.Base.html#5169" class="Function Operator">*_</a><a id="10365" class="Symbol">)</a> <a id="10367" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10369" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function"><a id="10372" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="10375" class="Bound">f</a> <a id="10377" class="Symbol">.</a><a id="10378" href="Category.LIN.html#478" class="Field">preserves-*</a> <a id="10390" class="Symbol">(</a><a id="10391" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10393" class="Number">0</a><a id="10394" class="Symbol">)</a> <a id="10396" class="Symbol">_</a> <a id="10398" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="10406" href="Data.Vec.Base.html#2580" class="Function">map</a> <a id="10410" class="Symbol">(</a><a id="10411" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10413" class="Number">0</a> <a id="10415" href="Data.Integer.Base.html#5169" class="Function Operator">*_</a><a id="10417" class="Symbol">)</a> <a id="10419" class="Symbol">(</a><a id="10420" class="Bound">f</a> <a id="10422" class="Symbol">.</a><a id="10423" href="Category.LIN.html#344" class="Field">linmap</a> <a id="10430" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10432" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function"><a id="10435" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="10438" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="10443" class="Symbol">(</a><a id="10444" href="Data.Vec.Base.html#2580" class="Function">map</a> <a id="10448" class="Symbol">(</a><a id="10449" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10451" class="Number">0</a> <a id="10453" href="Data.Integer.Base.html#5169" class="Function Operator">*_</a><a id="10455" class="Symbol">))</a> <a id="10458" href="blog/sheafs/index.html#10253" class="Bound">eq</a> <a id="10461" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="10469" href="Data.Vec.Base.html#2580" class="Function">map</a> <a id="10473" class="Symbol">(</a><a id="10474" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10476" class="Number">0</a> <a id="10478" href="Data.Integer.Base.html#5169" class="Function Operator">*_</a><a id="10480" class="Symbol">)</a> <a id="10482" class="Symbol">(</a><a id="10483" href="blog/sheafs/index.html#10264" class="Bound">x</a> <a id="10485" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10487" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10489" class="Symbol">)</a>        <a id="10498" href="Relation.Binary.PropositionalEquality.Core.html#2864" class="Function Operator">≡⟨⟩</a>
      <a id="10508" class="Symbol">(</a><a id="10509" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="10511" class="Number">0</a> <a id="10513" href="Data.Integer.Base.html#5169" class="Function Operator">*</a> <a id="10515" href="blog/sheafs/index.html#10264" class="Bound">x</a><a id="10516" class="Symbol">)</a> <a id="10518" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10520" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>               <span class="reasoning-step"><span class="as-written Function"><a id="10537" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">≡⟨</a> <a id="10540" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="10545" class="Symbol">(</a><a id="10546" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">_∷</a> <a id="10549" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="10551" class="Symbol">)</a> <a id="10553" class="Symbol">(</a><a id="10554" href="Data.Integer.Properties.html#43999" class="Function">*-zeroˡ</a> <a id="10562" href="Data.Integer.Base.html#1444" class="InductiveConstructor">+0</a><a id="10564" class="Symbol">)</a> <a id="10566" href="Relation.Binary.PropositionalEquality.Core.html#2923" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="10574" href="Data.Integer.Base.html#1444" class="InductiveConstructor">+0</a> <a id="10577" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="10579" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
    <a id="10586" href="Relation.Binary.PropositionalEquality.Core.html#3105" class="Function Operator">∎</a>
    <a id="10592" class="Keyword">where</a> <a id="10598" class="Keyword">open</a> <a id="10603" href="Relation.Binary.PropositionalEquality.Core.html#2708" class="Module">Eq.≡-Reasoning</a>
</pre>
<p>So, that’s no good. We’ve modeled <span class="Agda"><a href="blog/sheafs/index.html#8390" class="Function">Section</a></span> incorrectly, as the generalized element approach doesn’t work, since we are unable to follow the example.</p>
<p>What are some other ways to go from an <span class="Agda"><a href="Categories.html#362" class="Field">Obj</a></span> to a <span class="Agda"><a href="Agda.Primitive.html#326" class="Primitive">Set</a></span>? Maybe we could try modeling this as a functor to <span class="Agda"><a href="Category.SET.html#216" class="Function">SET</a></span> instead:</p>
<!--
<pre class="Agda"><a id="10933" class="Keyword">module</a> <a id="10940" href="blog.sheafs.html#10940" class="Module">_</a> <a id="10942" class="Keyword">where</a>
  <a id="10950" class="Keyword">open</a> <a id="10955" href="Category.MyFunctor.html#93" class="Module Operator">_=&gt;_</a>
  <a id="10962" class="Keyword">open</a> <a id="10967" class="Keyword">import</a> <a id="10974" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="11012" class="Keyword">using</a> <a id="11018" class="Symbol">(</a><a id="11019" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="11023" class="Symbol">)</a>
</pre>-->
<pre class="Agda">  <a id="11040" href="blog/sheafs/index.html#11040" class="Function">ex-func</a> <a id="11048" class="Symbol">:</a> <a id="11050" href="Category.LIN.html#591" class="Function">LIN</a> <a id="11054" href="Category.MyFunctor.html#93" class="Record Operator">=&gt;</a> <a id="11057" href="Category.SET.html#216" class="Function">SET</a>
  <a id="11063" href="blog/sheafs/index.html#11040" class="Function">ex-func</a> <a id="11071" class="Symbol">.</a><a id="11072" href="Category.MyFunctor.html#152" class="Field">F-Obj</a> <a id="11078" href="blog/sheafs/index.html#11078" class="Bound">x</a> <a id="11080" class="Symbol">=</a> <a id="11082" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="11086" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a> <a id="11088" href="blog/sheafs/index.html#11078" class="Bound">x</a>
  <a id="11092" href="blog/sheafs/index.html#11040" class="Function">ex-func</a> <a id="11100" class="Symbol">.</a><a id="11101" href="Category.MyFunctor.html#178" class="Field">F-map</a> <a id="11107" href="blog/sheafs/index.html#11107" class="Bound">f</a> <a id="11109" class="Symbol">=</a> <a id="11111" href="blog/sheafs/index.html#11107" class="Bound">f</a> <a id="11113" class="Symbol">.</a><a id="11114" href="Category.LIN.html#344" class="Field">linmap</a>
  <a id="11123" href="blog/sheafs/index.html#11040" class="Function">ex-func</a> <a id="11131" class="Symbol">.</a><a id="11132" href="Category.MyFunctor.html#245" class="Field">F-map-id</a> <a id="11141" class="Symbol">_</a> <a id="11143" class="Symbol">_</a> <a id="11145" class="Symbol">=</a> <a id="11147" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="11154" href="blog/sheafs/index.html#11040" class="Function">ex-func</a> <a id="11162" class="Symbol">.</a><a id="11163" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="11171" href="blog/sheafs/index.html#11171" class="Bound">g</a> <a id="11173" href="blog/sheafs/index.html#11173" class="Bound">f</a> <a id="11175" href="blog/sheafs/index.html#11175" class="Bound">a</a> <a id="11177" class="Symbol">=</a> <a id="11179" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>And we can try again with <code>Section</code>s:</p>
<p>and then we can say a <code>Section</code> is an element of the action of <span class="Agda"><a href="blog/sheafs/index.html#11418" class="Bound">Func</a></span>:</p>
<!--
<pre class="Agda"><a id="11316" class="Keyword">import</a> <a id="11323" href="Category.MyFunctor.html" class="Module">Category.MyFunctor</a>
<a id="11342" class="Keyword">module</a> <a id="Sections"></a><a id="11349" href="blog.sheafs.html#11349" class="Module">Sections</a>
         <a id="11367" class="Symbol">{</a><a id="11368" href="blog.sheafs.html#11368" class="Bound">pre</a> <a id="11372" class="Symbol">:</a> <a id="11374" href="blog.sheafs.html#3012" class="Record">Preorder</a><a id="11382" class="Symbol">}</a>
         <a id="11393" class="Symbol">{</a><a id="11394" href="blog.sheafs.html#11394" class="Bound">C</a> <a id="11396" class="Symbol">:</a> <a id="11398" href="Categories.html#257" class="Record">Category</a><a id="11406" class="Symbol">}</a>
         <a id="11417" class="Symbol">(</a><a id="11418" href="blog.sheafs.html#11418" class="Bound">Func</a> <a id="11423" class="Symbol">:</a> <a id="11425" href="blog.sheafs.html#11394" class="Bound">C</a> <a id="11427" href="Category.MyFunctor.html#93" class="Record Operator">Category.MyFunctor.=&gt;</a> <a id="11449" href="Category.SET.html#216" class="Function">SET</a><a id="11452" class="Symbol">)</a>
         <a id="11463" class="Symbol">(</a><a id="11464" href="blog.sheafs.html#11464" class="Bound">sheaf</a> <a id="11470" class="Symbol">:</a> <a id="11472" href="blog.sheafs.html#5813" class="Record">Sheaf.Sheaf</a> <a id="11484" href="blog.sheafs.html#11368" class="Bound">pre</a> <a id="11488" href="blog.sheafs.html#11394" class="Bound">C</a><a id="11489" class="Symbol">)</a> <a id="11491" class="Keyword">where</a>
  <a id="11499" class="Keyword">open</a> <a id="11504" href="blog.sheafs.html#3012" class="Module">Preorder</a> <a id="11513" href="blog.sheafs.html#11368" class="Bound">pre</a>
  <a id="11519" class="Keyword">open</a> <a id="11524" href="blog.sheafs.html#5813" class="Module">Sheaf.Sheaf</a> <a id="11536" href="blog.sheafs.html#11464" class="Bound">sheaf</a>
  <a id="11544" class="Keyword">open</a> <a id="11549" href="Category.MyFunctor.html#93" class="Module Operator">Category.MyFunctor._=&gt;_</a> <a id="11573" href="blog.sheafs.html#11418" class="Bound">Func</a>
  <a id="11580" class="Keyword">open</a> <a id="11585" href="Categories.html#257" class="Module">Category</a> <a id="11594" href="Category.SET.html#216" class="Function">SET</a>
  <a id="11600" class="Keyword">open</a> <a id="11605" class="Keyword">import</a> <a id="11612" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="11650" class="Keyword">using</a> <a id="11656" class="Symbol">(</a><a id="11657" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="11660" class="Symbol">)</a>
</pre>-->
<pre class="Agda">  <a id="Sections.Section"></a><a id="11677" href="blog/sheafs/index.html#11677" class="Function">Section</a> <a id="11685" class="Symbol">:</a> <a id="11687" href="blog/sheafs/index.html#3045" class="Function">Carrier</a> <a id="11695" class="Symbol">→</a> <a id="11697" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="11703" href="blog/sheafs/index.html#11677" class="Function">Section</a> <a id="11711" href="blog/sheafs/index.html#11711" class="Bound">c</a> <a id="11713" class="Symbol">=</a> <a id="11715" href="Category.MyFunctor.html#152" class="Function">F-Obj</a> <a id="11721" class="Symbol">(</a><a id="11722" href="blog/sheafs/index.html#5847" class="Field">Stalk</a> <a id="11728" href="blog/sheafs/index.html#11711" class="Bound">c</a><a id="11729" class="Symbol">)</a>
</pre>
<p>and a <code>GlobalSection</code>, which recall, is a globally-coherent assignment of sections:</p>
<pre class="Agda">  <a id="11827" class="Keyword">record</a> <a id="Sections.GlobalSection"></a><a id="11834" href="blog/sheafs/index.html#11834" class="Record">GlobalSection</a> <a id="11848" class="Symbol">:</a> <a id="11850" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11854" class="Keyword">where</a>
    <a id="11864" class="Keyword">field</a>
      <a id="Sections.GlobalSection.section"></a><a id="11876" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="11884" class="Symbol">:</a> <a id="11886" class="Symbol">forall</a> <a id="11893" class="Symbol">(</a><a id="11894" href="blog/sheafs/index.html#11894" class="Bound">c</a> <a id="11896" class="Symbol">:</a> <a id="11898" href="blog/sheafs/index.html#3045" class="Function">Carrier</a><a id="11905" class="Symbol">)</a> <a id="11907" class="Symbol">→</a> <a id="11909" href="blog/sheafs/index.html#11677" class="Function">Section</a> <a id="11917" href="blog/sheafs/index.html#11894" class="Bound">c</a>
      <a id="Sections.GlobalSection.commutes"></a><a id="11925" href="blog/sheafs/index.html#11925" class="Field">commutes</a>
        <a id="11942" class="Symbol">:</a> <a id="11944" class="Symbol">{</a><a id="11945" href="blog/sheafs/index.html#11945" class="Bound">x</a> <a id="11947" href="blog/sheafs/index.html#11947" class="Bound">y</a> <a id="11949" class="Symbol">:</a> <a id="11951" href="blog/sheafs/index.html#3045" class="Function">Carrier</a><a id="11958" class="Symbol">}</a>
        <a id="11968" class="Symbol">→</a> <a id="11970" class="Symbol">(</a><a id="11971" href="blog/sheafs/index.html#11971" class="Bound">x&lt;y</a> <a id="11975" class="Symbol">:</a> <a id="11977" href="blog/sheafs/index.html#11945" class="Bound">x</a> <a id="11979" href="blog/sheafs/index.html#3063" class="Function Operator">&lt;</a> <a id="11981" href="blog/sheafs/index.html#11947" class="Bound">y</a><a id="11982" class="Symbol">)</a>
        <a id="11992" class="Symbol">→</a> <a id="11994" href="Category.MyFunctor.html#178" class="Function">F-map</a> <a id="12000" class="Symbol">(</a><a id="12001" href="blog/sheafs/index.html#5875" class="Field">restrict</a> <a id="12010" href="blog/sheafs/index.html#11971" class="Bound">x&lt;y</a><a id="12013" class="Symbol">)</a> <a id="12015" class="Symbol">(</a><a id="12016" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="12024" href="blog/sheafs/index.html#11947" class="Bound">y</a><a id="12025" class="Symbol">)</a> <a id="12027" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="12029" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="12037" href="blog/sheafs/index.html#11945" class="Bound">x</a>
</pre>
<!--
<pre class="Agda"><a id="12053" class="Keyword">module</a> <a id="GoodEx"></a><a id="12060" href="blog.sheafs.html#12060" class="Module">GoodEx</a> <a id="12067" class="Keyword">where</a>
  <a id="12075" class="Keyword">open</a> <a id="12080" href="blog.sheafs.html#5721" class="Module">Sheaf</a> <a id="12086" href="blog.sheafs.html#3955" class="Function">ex-preorder</a> <a id="12098" href="Category.LIN.html#591" class="Function">LIN</a>
  <a id="12104" class="Keyword">open</a> <a id="12109" href="blog.sheafs.html#5813" class="Module">Sheaf.Sheaf</a> <a id="12121" href="blog.sheafs.html#7081" class="Function">ex</a>
  <a id="12126" class="Keyword">open</a> <a id="12131" href="blog.sheafs.html#11349" class="Module">Sections</a> <a id="12140" href="blog.sheafs.html#11040" class="Function">ex-func</a> <a id="12148" href="blog.sheafs.html#7081" class="Function">ex</a>
  <a id="12153" class="Keyword">open</a> <a id="12158" href="blog.sheafs.html#11834" class="Module">GlobalSection</a>
  <a id="12174" class="Keyword">open</a> <a id="12179" href="Category.MyFunctor.html#93" class="Module Operator">Category.MyFunctor._=&gt;_</a> <a id="12203" href="blog.sheafs.html#11040" class="Function">ex-func</a>
</pre>-->
<pre class="Agda">  <a id="GoodEx.soln"></a><a id="12226" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12231" class="Symbol">:</a> <a id="12233" href="blog/sheafs/index.html#11834" class="Record">GlobalSection</a>
  <a id="12249" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12254" class="Symbol">.</a><a id="12255" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="12263" href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a> <a id="12266" class="Symbol">=</a> <a id="12268" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12270" class="Number">2</a> <a id="12272" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12274" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12276" class="Number">1</a> <a id="12278" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12280" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="12285" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12290" class="Symbol">.</a><a id="12291" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="12299" href="blog/sheafs/index.html#3413" class="InductiveConstructor">v2</a> <a id="12302" class="Symbol">=</a> <a id="12304" href="Agda.Builtin.Int.html#291" class="InductiveConstructor Operator">-[1+</a> <a id="12309" class="Number">1</a> <a id="12311" href="Agda.Builtin.Int.html#291" class="InductiveConstructor Operator">]</a> <a id="12313" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12315" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12317" class="Number">10</a> <a id="12320" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12322" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12324" class="Number">3</a> <a id="12326" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12328" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="12333" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12338" class="Symbol">.</a><a id="12339" href="blog/sheafs/index.html#11876" class="Field">section</a> <a id="12347" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="12351" class="Symbol">=</a> <a id="12353" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12355" class="Number">1</a> <a id="12357" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12359" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">+</a> <a id="12361" class="Number">2</a> <a id="12363" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="12365" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a>
  <a id="12370" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12375" class="Symbol">.</a><a id="12376" href="blog/sheafs/index.html#11925" class="Field">commutes</a> <a id="12385" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a> <a id="12392" class="Symbol">=</a> <a id="12394" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="12401" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12406" class="Symbol">.</a><a id="12407" href="blog/sheafs/index.html#11925" class="Field">commutes</a> <a id="12416" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a> <a id="12423" class="Symbol">=</a> <a id="12425" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="12432" href="blog/sheafs/index.html#12226" class="Function">soln</a> <a id="12437" class="Symbol">.</a><a id="12438" href="blog/sheafs/index.html#11925" class="Field">commutes</a> <a id="12447" class="Symbol">(</a><a id="12448" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="12457" class="Symbol">_)</a> <a id="12460" class="Symbol">=</a> <a id="12462" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>Sure enough, this was a global section:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>v</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
2 \\ 1
\end{bmatrix}
\in \text{Stalk } v1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>10</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>v</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
-2 \\ 10 \\ 3
\end{bmatrix}
\in \text{Stalk } v2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.6667em" height="0.016em" style="width:0.6667em" viewBox="0 0 666.67 16" preserveAspectRatio="xMinYMin"><path d="M319 0 H403 V16 H319z M319 0 H403 V16 H319z"></path></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">2</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">10</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.6667em" height="0.016em" style="width:0.6667em" viewBox="0 0 666.67 16" preserveAspectRatio="xMinYMin"><path d="M263 0 H347 V16 H263z M263 0 H347 V16 H263z"></path></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord">2</span></span></span></span></span></p>
<p>and</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>∈</mo><mtext>Stalk </mtext><mi>e</mi><mn>12</mn></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
1 \\ 2
\end{bmatrix}
\in \text{Stalk } e12
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">Stalk </span></span><span class="mord mathnormal">e</span><span class="mord">12</span></span></span></span></span></p>
<h2 id="example-continuous-intervals"><a href="#example-continuous-intervals" class="header-link">Example: Continuous Intervals<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper presents a second example as well. Maybe it’s just that I’m less well-versed in the subject matter, but this example feels significantly more incoherent than the first. I tried to work through it, and the formalization above was sufficiently powerful to do what I needed, but I didn’t understand the example or what it was trying to accomplish. There was some Abelian group stuff that never actually got used.</p>
<p>Rather than clean this section up, I’m instead going to spend the time before my publication deadline writing about what I learned about pre-sheafs after hitting the wall, and asking for help.</p>
<h2 id="extracuricular-presheafs"><a href="#extracuricular-presheafs" class="header-link">Extracuricular Presheafs<span class="header-link-emoji">🔗</span></a></h2>
<p>So let’s talk about what all of this sheaf business above is trying to do. The ever helpful Reed Mullanix came to my rescue with a few helpful intuitions. To paraphrase him (if there are any mistakes in the following, they are my mistakes, not his):</p>
<blockquote>
<p>Think about a sensor network. You have some physical space, with a series of sensors attached in specific places. Maybe you have a microphone in the hallway, and a camera at the front door, and a thermometer in the bedroom. Each of these sensors is <em>locally correct</em>, that is, we can be reasonably sure that if the thermometer says 37C, it is in fact 37C.</p>
<p>A presheaf is a mapping from this collection of sensors to a world in which we can reason about the total space. For example, we might want to get an idea of what’s going on in the basement, where we have no sensors, but which is part of our house nevertheless.</p>
<p>And a global section over that presheaf is a globally consistent take on the system. It’s some mapping into the hypothesis space that <em>agrees with all of the measurements.</em> If we know it’s 37C in the bedroom, we’re probably not going to see snow in the front-door camera.</p>
</blockquote>
<p>Okay, so what’s all this preorder stuff about? I think it’s actually just a poor man’s category. We can lift any preorder into a category by considering the <code>&lt;</code> relationship to be a morphism:</p>
<pre class="Agda"><a id="14770" class="Keyword">module</a> <a id="PreorderToCategory"></a><a id="14777" href="blog/sheafs/index.html#14777" class="Module">PreorderToCategory</a> <a id="14796" class="Symbol">(</a><a id="14797" href="blog/sheafs/index.html#14797" class="Bound">P</a> <a id="14799" class="Symbol">:</a> <a id="14801" href="blog/sheafs/index.html#3012" class="Record">Preorder</a><a id="14809" class="Symbol">)</a> <a id="14811" class="Keyword">where</a>
  <a id="14819" class="Keyword">open</a> <a id="14824" href="blog/sheafs/index.html#3012" class="Module">Preorder</a> <a id="14833" href="blog/sheafs/index.html#14797" class="Bound">P</a>
  <a id="14837" class="Keyword">open</a> <a id="14842" href="Categories.html#257" class="Module">Category</a>

  <a id="14854" class="Keyword">open</a> <a id="14859" class="Keyword">import</a> <a id="14866" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="14876" class="Keyword">using</a> <a id="14882" class="Symbol">(</a><a id="14883" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="14884" class="Symbol">;</a> <a id="14886" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="14888" class="Symbol">)</a>

  <a id="PreorderToCategory.cat"></a><a id="14893" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14897" class="Symbol">:</a> <a id="14899" href="Categories.html#257" class="Record">Category</a>
  <a id="14910" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14914" class="Symbol">.</a><a id="14915" href="Categories.html#362" class="Field">Obj</a> <a id="14919" class="Symbol">=</a> <a id="14921" href="blog/sheafs/index.html#3045" class="Field">Carrier</a>
  <a id="14931" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14935" class="Symbol">.</a><a id="14936" href="Categories.html#376" class="Field Operator">_~&gt;_</a> <a id="14941" class="Symbol">=</a> <a id="14943" href="blog/sheafs/index.html#3063" class="Field Operator">_&lt;_</a>
  <a id="14949" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14953" class="Symbol">.</a><a id="14954" href="Categories.html#450" class="Field Operator">_≈_</a> <a id="14958" href="blog/sheafs/index.html#14958" class="Bound">f</a> <a id="14960" href="blog/sheafs/index.html#14960" class="Bound">g</a> <a id="14962" class="Symbol">=</a> <a id="14964" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="14968" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14972" class="Symbol">.</a><a id="14973" href="Categories.html#565" class="Field">≈-equiv</a> <a id="14981" class="Symbol">=</a> <a id="14983" href="blog/sheafs/index.html#6436" class="Postulate">sorry</a>
  <a id="14991" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="14995" class="Symbol">.</a><a id="14996" href="Categories.html#648" class="Field">id</a> <a id="14999" class="Symbol">{</a><a id="15000" class="Argument">A</a> <a id="15002" class="Symbol">=</a> <a id="15004" href="blog/sheafs/index.html#15004" class="Bound">A</a><a id="15005" class="Symbol">}</a> <a id="15007" class="Symbol">=</a> <a id="15009" href="blog/sheafs/index.html#3097" class="Field">&lt;-refl</a> <a id="15016" href="blog/sheafs/index.html#15004" class="Bound">A</a>
  <a id="15020" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="15024" class="Symbol">.</a><a id="15025" href="Categories.html#676" class="Field Operator">_∘_</a> <a id="15029" href="blog/sheafs/index.html#15029" class="Bound">g</a> <a id="15031" href="blog/sheafs/index.html#15031" class="Bound">f</a> <a id="15033" class="Symbol">=</a> <a id="15035" href="blog/sheafs/index.html#3132" class="Field">&lt;-trans</a> <a id="15043" href="blog/sheafs/index.html#15031" class="Bound">f</a> <a id="15045" href="blog/sheafs/index.html#15029" class="Bound">g</a>
  <a id="15049" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="15053" class="Symbol">.</a><a id="15054" href="Categories.html#728" class="Field">∘-cong</a> <a id="15061" class="Symbol">=</a> <a id="15063" class="Symbol">λ</a> <a id="15065" href="blog/sheafs/index.html#15065" class="Bound">_</a> <a id="15067" href="blog/sheafs/index.html#15067" class="Bound">_</a> <a id="15069" class="Symbol">→</a> <a id="15071" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
  <a id="15076" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="15080" class="Symbol">.</a><a id="15081" href="Categories.html#864" class="Field">id-r</a> <a id="15086" href="blog/sheafs/index.html#15086" class="Bound">f</a> <a id="15088" class="Symbol">=</a> <a id="15090" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
  <a id="15095" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="15099" class="Symbol">.</a><a id="15100" href="Categories.html#913" class="Field">id-l</a> <a id="15105" href="blog/sheafs/index.html#15105" class="Bound">f</a> <a id="15107" class="Symbol">=</a> <a id="15109" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
  <a id="15114" href="blog/sheafs/index.html#14893" class="Function">cat</a> <a id="15118" class="Symbol">.</a><a id="15119" href="Categories.html#962" class="Field">∘-assoc</a> <a id="15127" href="blog/sheafs/index.html#15127" class="Bound">h</a> <a id="15129" href="blog/sheafs/index.html#15129" class="Bound">g</a> <a id="15131" href="blog/sheafs/index.html#15131" class="Bound">f</a> <a id="15133" class="Symbol">=</a> <a id="15135" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre>
<p>and now that we have a <span class="Agda"><a href="Categories.html#257" class="Record">Category</a></span>, we can avoid the whole <span class="Agda"><a href="blog/sheafs/index.html#5721" class="Module">Sheaf</a></span> / <span class="Agda"><a href="blog/sheafs/index.html#9595" class="Record">GlobalSection</a></span> by giving a functor into <span class="Agda"><a href="Category.SET.html#216" class="Function">SET</a></span>. Well, almost, because <span class="Agda"><a href="Data.Vec.Base.html#3807" class="Function">restrict</a></span> goes the opposite direction. So instead, we can build an opposite category:</p>
<pre class="Agda"><a id="15408" class="Keyword">module</a> <a id="Op"></a><a id="15415" href="blog/sheafs/index.html#15415" class="Module">Op</a> <a id="15418" class="Symbol">(</a><a id="15419" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15421" class="Symbol">:</a> <a id="15423" href="Categories.html#257" class="Record">Category</a><a id="15431" class="Symbol">)</a> <a id="15433" class="Keyword">where</a>
  <a id="15441" class="Keyword">open</a> <a id="15446" href="Categories.html#257" class="Module">Category</a>

  <a id="15458" class="Keyword">data</a> <a id="Op.OpArr"></a><a id="15463" href="blog/sheafs/index.html#15463" class="Datatype">OpArr</a> <a id="15469" class="Symbol">:</a> <a id="15471" href="Categories.html#362" class="Field">Obj</a> <a id="15475" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15477" class="Symbol">→</a> <a id="15479" href="Categories.html#362" class="Field">Obj</a> <a id="15483" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15485" class="Symbol">→</a> <a id="15487" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="15491" class="Keyword">where</a>
    <a id="Op.OpArr.reverse"></a><a id="15501" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15509" class="Symbol">:</a> <a id="15511" class="Symbol">{</a><a id="15512" href="blog/sheafs/index.html#15512" class="Bound">X</a> <a id="15514" href="blog/sheafs/index.html#15514" class="Bound">Y</a> <a id="15516" class="Symbol">:</a> <a id="15518" href="Categories.html#362" class="Field">Obj</a> <a id="15522" href="blog/sheafs/index.html#15419" class="Bound">C</a><a id="15523" class="Symbol">}</a> <a id="15525" class="Symbol">→</a> <a id="15527" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15529" href="Categories.html#1998" class="Function Operator">[</a> <a id="15531" href="blog/sheafs/index.html#15512" class="Bound">X</a> <a id="15533" href="Categories.html#1998" class="Function Operator">,</a> <a id="15535" href="blog/sheafs/index.html#15514" class="Bound">Y</a> <a id="15537" href="Categories.html#1998" class="Function Operator">]</a> <a id="15539" class="Symbol">→</a> <a id="15541" href="blog/sheafs/index.html#15463" class="Datatype">OpArr</a> <a id="15547" href="blog/sheafs/index.html#15514" class="Bound">Y</a> <a id="15549" href="blog/sheafs/index.html#15512" class="Bound">X</a>

  <a id="Op.op"></a><a id="15554" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15557" class="Symbol">:</a> <a id="15559" href="Categories.html#257" class="Record">Category</a>
  <a id="15570" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15573" class="Symbol">.</a><a id="15574" href="Categories.html#362" class="Field">Obj</a> <a id="15578" class="Symbol">=</a> <a id="15580" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15582" class="Symbol">.</a><a id="15583" href="Categories.html#362" class="Field">Obj</a>
  <a id="15589" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15592" class="Symbol">.</a><a id="15593" href="Categories.html#376" class="Field Operator">_~&gt;_</a> <a id="15598" class="Symbol">=</a> <a id="15600" href="blog/sheafs/index.html#15463" class="Datatype">OpArr</a>
  <a id="15608" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15611" class="Symbol">.</a><a id="15612" href="Categories.html#450" class="Field Operator">_≈_</a> <a id="15616" class="Symbol">(</a><a id="15617" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15625" href="blog/sheafs/index.html#15625" class="Bound">f</a><a id="15626" class="Symbol">)</a> <a id="15628" class="Symbol">(</a><a id="15629" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15637" href="blog/sheafs/index.html#15637" class="Bound">g</a><a id="15638" class="Symbol">)</a> <a id="15640" class="Symbol">=</a> <a id="15642" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15644" class="Symbol">.</a><a id="15645" href="Categories.html#450" class="Field Operator">_≈_</a> <a id="15649" href="blog/sheafs/index.html#15625" class="Bound">f</a> <a id="15651" href="blog/sheafs/index.html#15637" class="Bound">g</a>
  <a id="15655" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15658" class="Symbol">.</a><a id="15659" href="Categories.html#565" class="Field">≈-equiv</a> <a id="15667" class="Symbol">{</a><a id="15668" href="blog/sheafs/index.html#15668" class="Bound">A</a><a id="15669" class="Symbol">}</a> <a id="15671" class="Symbol">{</a><a id="15672" href="blog/sheafs/index.html#15672" class="Bound">B</a><a id="15673" class="Symbol">}</a> <a id="15675" class="Symbol">=</a> <a id="15677" href="blog/sheafs/index.html#6436" class="Postulate">sorry</a>
  <a id="15685" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15688" class="Symbol">.</a><a id="15689" href="Categories.html#648" class="Field">id</a> <a id="15692" class="Symbol">=</a> <a id="15694" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15702" class="Symbol">(</a><a id="15703" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15705" class="Symbol">.</a><a id="15706" href="Categories.html#648" class="Field">id</a><a id="15708" class="Symbol">)</a>
  <a id="15712" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15715" class="Symbol">.</a><a id="15716" href="Categories.html#676" class="Field Operator">_∘_</a> <a id="15720" class="Symbol">(</a><a id="15721" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15729" href="blog/sheafs/index.html#15729" class="Bound">g</a><a id="15730" class="Symbol">)</a> <a id="15732" class="Symbol">(</a><a id="15733" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15741" href="blog/sheafs/index.html#15741" class="Bound">f</a><a id="15742" class="Symbol">)</a> <a id="15744" class="Symbol">=</a> <a id="15746" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15754" class="Symbol">(</a><a id="15755" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15757" class="Symbol">.</a><a id="15758" href="Categories.html#676" class="Field Operator">_∘_</a> <a id="15762" href="blog/sheafs/index.html#15741" class="Bound">f</a> <a id="15764" href="blog/sheafs/index.html#15729" class="Bound">g</a><a id="15765" class="Symbol">)</a>
  <a id="15769" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15772" class="Symbol">.</a><a id="15773" href="Categories.html#728" class="Field">∘-cong</a> <a id="15780" class="Symbol">=</a> <a id="15782" href="blog/sheafs/index.html#6436" class="Postulate">sorry</a>
  <a id="15790" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15793" class="Symbol">.</a><a id="15794" href="Categories.html#864" class="Field">id-r</a> <a id="15799" class="Symbol">(</a><a id="15800" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15808" href="blog/sheafs/index.html#15808" class="Bound">f</a><a id="15809" class="Symbol">)</a> <a id="15811" class="Symbol">=</a> <a id="15813" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15815" class="Symbol">.</a><a id="15816" href="Categories.html#913" class="Field">id-l</a> <a id="15821" href="blog/sheafs/index.html#15808" class="Bound">f</a>
  <a id="15825" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15828" class="Symbol">.</a><a id="15829" href="Categories.html#913" class="Field">id-l</a> <a id="15834" class="Symbol">(</a><a id="15835" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15843" href="blog/sheafs/index.html#15843" class="Bound">f</a><a id="15844" class="Symbol">)</a> <a id="15846" class="Symbol">=</a> <a id="15848" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15850" class="Symbol">.</a><a id="15851" href="Categories.html#864" class="Field">id-r</a> <a id="15856" href="blog/sheafs/index.html#15843" class="Bound">f</a>
  <a id="15860" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="15863" class="Symbol">.</a><a id="15864" href="Categories.html#962" class="Field">∘-assoc</a> <a id="15872" class="Symbol">(</a><a id="15873" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15881" href="blog/sheafs/index.html#15881" class="Bound">h</a><a id="15882" class="Symbol">)</a> <a id="15884" class="Symbol">(</a><a id="15885" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15893" href="blog/sheafs/index.html#15893" class="Bound">g</a><a id="15894" class="Symbol">)</a> <a id="15896" class="Symbol">(</a><a id="15897" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="15905" href="blog/sheafs/index.html#15905" class="Bound">f</a><a id="15906" class="Symbol">)</a> <a id="15908" class="Symbol">=</a>
    <a id="15914" href="Categories.html#1389" class="Function">setoid</a> <a id="15921" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15923" class="Symbol">.</a><a id="15924" href="Relation.Binary.Bundles.html#1132" class="Field">isEquivalence</a>
             <a id="15951" class="Symbol">.</a><a id="15952" href="Relation.Binary.Structures.html#1594" class="Field">S.IsEquivalence.sym</a> <a id="15972" class="Symbol">(</a><a id="15973" href="blog/sheafs/index.html#15419" class="Bound">C</a> <a id="15975" class="Symbol">.</a><a id="15976" href="Categories.html#962" class="Field">∘-assoc</a> <a id="15984" href="blog/sheafs/index.html#15905" class="Bound">f</a> <a id="15986" href="blog/sheafs/index.html#15893" class="Bound">g</a> <a id="15988" href="blog/sheafs/index.html#15881" class="Bound">h</a><a id="15989" class="Symbol">)</a>
    <a id="15995" class="Keyword">where</a>
      <a id="16007" class="Keyword">open</a> <a id="16012" class="Keyword">import</a> <a id="16019" href="Relation.Binary.Bundles.html" class="Module">Relation.Binary.Bundles</a> <a id="16043" class="Keyword">using</a> <a id="16049" class="Symbol">(</a><a id="16050" href="Relation.Binary.Bundles.html#1009" class="Record">Setoid</a><a id="16056" class="Symbol">)</a>
      <a id="16064" class="Keyword">open</a> <a id="16069" href="Relation.Binary.Bundles.html#1009" class="Module">Setoid</a> <a id="16076" class="Keyword">using</a> <a id="16082" class="Symbol">(</a><a id="16083" href="Relation.Binary.Bundles.html#1132" class="Field">isEquivalence</a><a id="16096" class="Symbol">)</a>
      <a id="16104" class="Keyword">import</a> <a id="16111" href="Relation.Binary.Structures.html" class="Module">Relation.Binary.Structures</a> <a id="16138" class="Symbol">as</a> <a id="16141" class="Module">S</a>
</pre>
<p>Now, we can express a presheaf as a functor:</p>
<pre class="Agda"><a id="16198" class="Keyword">module</a> <a id="16205" href="blog/sheafs/index.html#16205" class="Module">_</a> <a id="16207" class="Keyword">where</a>
  <a id="16215" class="Keyword">open</a> <a id="16220" class="Keyword">import</a> <a id="16227" href="Category.MyFunctor.html" class="Module">Category.MyFunctor</a>
  <a id="16248" class="Keyword">open</a> <a id="16253" href="blog/sheafs/index.html#15415" class="Module">Op</a>

  <a id="16259" href="blog/sheafs/index.html#16259" class="Function">Presheaf</a> <a id="16268" class="Symbol">:</a> <a id="16270" href="Categories.html#257" class="Record">Category</a> <a id="16279" class="Symbol">→</a> <a id="16281" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="16287" href="blog/sheafs/index.html#16259" class="Function">Presheaf</a> <a id="16296" href="blog/sheafs/index.html#16296" class="Bound">C</a> <a id="16298" class="Symbol">=</a> <a id="16300" href="blog/sheafs/index.html#15554" class="Function">op</a> <a id="16303" href="blog/sheafs/index.html#16296" class="Bound">C</a> <a id="16305" href="Category.MyFunctor.html#93" class="Record Operator">=&gt;</a> <a id="16308" href="Category.SET.html#216" class="Function">SET</a>
</pre>
<p>or our specific example from earlier:</p>
<pre class="Agda"><a id="16360" class="Keyword">module</a> <a id="16367" href="blog/sheafs/index.html#16367" class="Module">_</a> <a id="16369" class="Keyword">where</a>
  <a id="16377" class="Keyword">open</a> <a id="16382" href="blog/sheafs/index.html#14777" class="Module">PreorderToCategory</a> <a id="16401" href="blog/sheafs/index.html#3955" class="Function">ex-preorder</a>
  <a id="16415" class="Keyword">open</a> <a id="16420" href="Category.MyFunctor.html#93" class="Module Operator">_=&gt;_</a>
  <a id="16427" class="Keyword">open</a> <a id="16432" class="Keyword">import</a> <a id="16439" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="16448" class="Keyword">using</a> <a id="16454" class="Symbol">(</a><a id="16455" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="16456" class="Symbol">)</a>
  <a id="16460" class="Keyword">open</a> <a id="16465" href="blog/sheafs/index.html#15415" class="Module">Op</a>

  <a id="16471" href="blog/sheafs/index.html#16471" class="Function">Z</a> <a id="16473" class="Symbol">:</a> <a id="16475" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="16477" class="Symbol">→</a> <a id="16479" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="16485" href="blog/sheafs/index.html#16471" class="Function">Z</a> <a id="16487" class="Symbol">=</a> <a id="16489" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="16493" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a>

  <a id="16498" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16502" class="Symbol">:</a> <a id="16504" href="blog/sheafs/index.html#16259" class="Function">Presheaf</a> <a id="16513" href="blog/sheafs/index.html#14893" class="Function">cat</a>
  <a id="16519" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16523" class="Symbol">.</a><a id="16524" href="Category.MyFunctor.html#152" class="Field">F-Obj</a> <a id="16530" href="blog/sheafs/index.html#3402" class="InductiveConstructor">v1</a> <a id="16533" class="Symbol">=</a> <a id="16535" href="blog/sheafs/index.html#16471" class="Function">Z</a> <a id="16537" class="Number">2</a>
  <a id="16541" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16545" class="Symbol">.</a><a id="16546" href="Category.MyFunctor.html#152" class="Field">F-Obj</a> <a id="16552" href="blog/sheafs/index.html#3413" class="InductiveConstructor">v2</a> <a id="16555" class="Symbol">=</a> <a id="16557" href="blog/sheafs/index.html#16471" class="Function">Z</a> <a id="16559" class="Number">3</a>
  <a id="16563" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16567" class="Symbol">.</a><a id="16568" href="Category.MyFunctor.html#152" class="Field">F-Obj</a> <a id="16574" href="blog/sheafs/index.html#3424" class="InductiveConstructor">e12</a> <a id="16578" class="Symbol">=</a> <a id="16580" href="blog/sheafs/index.html#16471" class="Function">Z</a> <a id="16582" class="Number">2</a>
  <a id="16586" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16590" class="Symbol">.</a><a id="16591" href="Category.MyFunctor.html#178" class="Field">F-map</a> <a id="16597" class="Symbol">(</a><a id="16598" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16606" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a><a id="16612" class="Symbol">)</a> <a id="16614" class="Symbol">=</a> <a id="16616" href="blog/sheafs/index.html#6475" class="Function">e12~&gt;v1</a> <a id="16624" class="Symbol">.</a><a id="16625" href="Category.LIN.html#344" class="Field">linmap</a>
  <a id="16634" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16638" class="Symbol">.</a><a id="16639" href="Category.MyFunctor.html#178" class="Field">F-map</a> <a id="16645" class="Symbol">(</a><a id="16646" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16654" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a><a id="16660" class="Symbol">)</a> <a id="16662" class="Symbol">=</a> <a id="16664" href="blog/sheafs/index.html#6815" class="Function">e12~&gt;v2</a> <a id="16672" class="Symbol">.</a><a id="16673" href="Category.LIN.html#344" class="Field">linmap</a>
  <a id="16682" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16686" class="Symbol">.</a><a id="16687" href="Category.MyFunctor.html#178" class="Field">F-map</a> <a id="16693" class="Symbol">(</a><a id="16694" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16702" class="Symbol">(</a><a id="16703" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="16712" class="Symbol">_))</a> <a id="16716" href="blog/sheafs/index.html#16716" class="Bound">a</a> <a id="16718" class="Symbol">=</a> <a id="16720" href="blog/sheafs/index.html#16716" class="Bound">a</a>
  <a id="16724" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16728" class="Symbol">.</a><a id="16729" href="Category.MyFunctor.html#245" class="Field">F-map-id</a> <a id="16738" href="blog/sheafs/index.html#16738" class="Bound">A</a> <a id="16740" href="blog/sheafs/index.html#16740" class="Bound">a</a> <a id="16742" class="Symbol">=</a> <a id="16744" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="16751" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16755" class="Symbol">.</a><a id="16756" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="16764" class="Symbol">(</a><a id="16765" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16773" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a><a id="16779" class="Symbol">)</a> <a id="16781" class="Symbol">(</a><a id="16782" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16790" class="Symbol">(</a><a id="16791" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="16800" class="Symbol">_))</a> <a id="16804" href="blog/sheafs/index.html#16804" class="Bound">a</a> <a id="16806" class="Symbol">=</a> <a id="16808" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="16815" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16819" class="Symbol">.</a><a id="16820" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="16828" class="Symbol">(</a><a id="16829" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16837" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a><a id="16843" class="Symbol">)</a> <a id="16845" class="Symbol">(</a><a id="16846" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16854" class="Symbol">(</a><a id="16855" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="16864" class="Symbol">_))</a> <a id="16868" href="blog/sheafs/index.html#16868" class="Bound">a</a> <a id="16870" class="Symbol">=</a> <a id="16872" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="16879" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16883" class="Symbol">.</a><a id="16884" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="16892" class="Symbol">(</a><a id="16893" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16901" class="Symbol">(</a><a id="16902" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="16911" class="Symbol">_))</a> <a id="16915" class="Symbol">(</a><a id="16916" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16924" href="blog/sheafs/index.html#3742" class="InductiveConstructor">e12&lt;v1</a><a id="16930" class="Symbol">)</a> <a id="16932" href="blog/sheafs/index.html#16932" class="Bound">a</a> <a id="16934" class="Symbol">=</a> <a id="16936" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="16943" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="16947" class="Symbol">.</a><a id="16948" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="16956" class="Symbol">(</a><a id="16957" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16965" class="Symbol">(</a><a id="16966" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="16975" class="Symbol">_))</a> <a id="16979" class="Symbol">(</a><a id="16980" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="16988" href="blog/sheafs/index.html#3764" class="InductiveConstructor">e12&lt;v2</a><a id="16994" class="Symbol">)</a> <a id="16996" href="blog/sheafs/index.html#16996" class="Bound">a</a> <a id="16998" class="Symbol">=</a> <a id="17000" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="17007" href="blog/sheafs/index.html#16498" class="Function">ex&#39;</a> <a id="17011" class="Symbol">.</a><a id="17012" href="Category.MyFunctor.html#354" class="Field">F-map-∘</a> <a id="17020" class="Symbol">(</a><a id="17021" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="17029" class="Symbol">(</a><a id="17030" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="17039" class="Symbol">_))</a> <a id="17043" class="Symbol">(</a><a id="17044" href="blog/sheafs/index.html#15501" class="InductiveConstructor">reverse</a> <a id="17052" class="Symbol">(</a><a id="17053" href="blog/sheafs/index.html#3840" class="InductiveConstructor">ex&lt;-refl</a> <a id="17062" class="Symbol">_))</a> <a id="17066" href="blog/sheafs/index.html#17066" class="Bound">a</a>
    <a id="17072" class="Symbol">=</a> <a id="17074" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>which leaves only the question of what a <code>GlobalSection</code> is under this representation.</p>
<p>I got stumped on this one for a while too, but again, Reed to the rescue, who points out that in our preorder, <code>&lt;</code> corresponds to a “smaller” space. Thus, we want to find a mapping out of the biggest space, which corresponds to a top element in the order, or a terminal object in the category. The terminal object is going to be the “total space” in consideration (in our sensor example, eg.) and the functor laws will ensure consistency.</p>
<pre class="Agda"><a id="GlobalSection"></a><a id="17617" href="blog/sheafs/index.html#17617" class="Function">GlobalSection</a>
    <a id="17635" class="Symbol">:</a> <a id="17637" class="Symbol">{</a><a id="17638" href="blog/sheafs/index.html#17638" class="Bound">C</a> <a id="17640" class="Symbol">:</a> <a id="17642" href="Categories.html#257" class="Record">Category</a><a id="17650" class="Symbol">}</a>
    <a id="17656" class="Symbol">→</a> <a id="17658" class="Symbol">(</a><a id="17659" href="blog/sheafs/index.html#17659" class="Bound">pre</a> <a id="17663" class="Symbol">:</a> <a id="17665" href="blog/sheafs/index.html#16259" class="Function">Presheaf</a> <a id="17674" href="blog/sheafs/index.html#17638" class="Bound">C</a><a id="17675" class="Symbol">)</a>
    <a id="17681" class="Symbol">→</a> <a id="17683" class="Symbol">(</a><a id="17684" href="blog/sheafs/index.html#17684" class="Bound">t</a> <a id="17686" class="Symbol">:</a> <a id="17688" href="Categories.html#2671" class="Record">HasTerminal</a> <a id="17700" href="blog/sheafs/index.html#17638" class="Bound">C</a><a id="17701" class="Symbol">)</a>
    <a id="17707" class="Symbol">→</a> <a id="17709" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="17713" href="blog/sheafs/index.html#17617" class="Function">GlobalSection</a> <a id="17727" href="blog/sheafs/index.html#17727" class="Bound">pre</a> <a id="17731" href="blog/sheafs/index.html#17731" class="Bound">t</a> <a id="17733" class="Symbol">=</a>
  <a id="17737" href="blog/sheafs/index.html#17727" class="Bound">pre</a> <a id="17741" class="Symbol">.</a><a id="17742" href="Category.MyFunctor.html#152" class="Field">_=&gt;_.F-Obj</a> <a id="17753" class="Symbol">(</a><a id="17754" href="blog/sheafs/index.html#17731" class="Bound">t</a> <a id="17756" class="Symbol">.</a><a id="17757" href="Categories.html#2711" class="Field">HasTerminal.terminal</a><a id="17777" class="Symbol">)</a>
</pre>
<p>Unfortunately, this is a problem for our worked example — we don’t <em>have</em> a terminal object! But that’s OK, it’s easy to trivially construct one by just adding a top:</p>
<div class="diagram-container">
<img src="a653552eb5e4b4f16d6c852c2162bdb0805104fd.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>and by picking an object in <span class="Agda"><a href="Category.SET.html#216" class="Function">SET</a></span> to map it to for our presheaf. There are some interesting choices here; we could just pick <span class="Agda"><a href="Agda.Builtin.Unit.html#164" class="Record">⊤</a></span>, which is interesting in how boring a choice it is. Such a thing trivially satisfies all of the requirements, but it doesn’t tell us much about the world. This is the metaphorical equivalent of explaining our sensors’ readings as “anything is possible!”</p>
<p>More interestingly, we could pick <code>F-Obj terminal</code> to be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">Z</mi><mn>2</mn></msup><mo>×</mo><msup><mi mathvariant="double-struck">Z</mi><mn>3</mn></msup><mo>×</mo><msup><mi mathvariant="double-struck">Z</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{Z}^2 × \mathbb{Z}^3 × \mathbb{Z}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,</span> corresponding to the product of <code>F-Obj v1</code>, <code>F-Obj v2</code> and <code>F-Obj e12</code>. We can satisfy the functor laws by projecting from the <code>F-Obj term</code> down to one of its components. And, best of all, it gives us a place to stick the values from our worked example.</p>
<p>I’d love to code this up in more detail, but unfortunately I’m out of time. That’s the flaw of trying to get through one paper a week, the deadline is strict whether you’re ready for it or not.</p>
<p>This whole post is a literate Agda file.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Automatic Ring Solving</title>
      <id>blog/ring-solving/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/ring-solving/index.html'/>
      <published>2022-02-16</published>
      <updated>2022-02-16</updated>

      <content type="html">
        <![CDATA[
        <p>Today’s sorta-review is of <a href="https://github.com/oisdk/agda-ring-solver-report/blob/master/report.pdf">Automatically and Efficiently Illustrating Polynomial Equations in Agda</a> by <a href="https://doisinkidney.com/">Donnacha Oisin Kidney</a>. I say it’s sorta a review because I had to write some annoying proofs recently, and discovered that Agda has a ring solver that automates annoying proofs. For example, it can solve things like <code>(a + b) * (a + b) = a^2 + 2*a*b + b^2</code>, which is rather amazing if you think about it. I got curious about how this is possible, and came across AaEIPEiA, quickly skimmed it for the rough approach, and then decided to write my own ring solver. As a result, this post is certainly inspired by AaEIPiA, but my implementation is extremely naive compared to the one presented in the paper. Kidney’s paper is very good, and I apologize for not doing it justice here.</p>
<p>So, some background. Agda lets you write types that correspond to equalities, and values of those types are proofs of those equalities. For example, we can write the following type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span>x <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> ≡ <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span></code></pre></div>
<p>You probably wouldn’t write this for its own sake, but it might come up as a lemma of something else you’re trying to prove. However, actually proving this equality is a huge amount of busywork, that takes forever, and isn’t actually interesting because we all know that this equality holds. For example, the proof might look something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ≡⟨ *-+-distrib <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x <span class="dv">1</span> ⟩</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> <span class="ot">((</span>x + <span class="dv">1</span><span class="ot">)</span> * x + φ<span class="ot">))</span> $ *-1-id-r <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> ⟩</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> φ + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-comm <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x ⟩</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    x * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> φ + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-+-distrib x x <span class="dv">1</span> ⟩</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x + x * <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  ≡⟨ ? ⟩</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- kill me</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  ≡⟨ ? ⟩</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  ∎</span></code></pre></div>
<p>It’s SO MUCH WORK to do <em>nothing!</em> This is not an interesting proof! A ring solver lets us reduce the above proof to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  ≡⟨ solve ⟩</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  ∎</span></code></pre></div>
<p>or, even more tersely:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  solve</span></code></pre></div>
<p>So that’s the goal here. Automate stupid, boring proofs so that we as humans can focus on the interesting bits of the problem.</p>
<h2 id="i-dont-even-know-what-a-ring-is"><a href="#i-dont-even-know-what-a-ring-is" class="header-link">I Don’t Even Know What a Ring Is<span class="header-link-emoji">🔗</span></a></h2>
<p>Why is this called a ring solver? I don’t exactly know, but a ring is some math thing. My guess is that it’s the abstract version of an algebra containing addition and multiplication, with all the usual rules.</p>
<p>And looking at it, sure enough! A ring is a set with two monoids on it, one corresponding to addition, and the other to multiplication. Importantly, we require that multiplication distributes over addition.</p>
<p>Rings technically have additive inverses, but I didn’t end up implementing (or needing them.) However, I did require commutativity of both addition and multiplication — more on this later.</p>
<p>The ring laws mean that algebra works in the way we expect arithmetic to work. We can shuffle things around, and probably all have enough experience solving these sorts of problems with pen and paper. But what’s the actual algorithm here?</p>
<h2 id="how-do-you-solve-a-ring"><a href="#how-do-you-solve-a-ring" class="header-link">How Do You Solve A Ring?<span class="header-link-emoji">🔗</span></a></h2>
<p>At first blush, this sounds like a hard problem! It feels like we need to see if there’s a way to turn some arbitrary expression into some other arbitrary expression. And that is indeed true, but it’s made easier when you realize that polynomials have a normal form as a sum of products of descending powers. For example, this is in normal form:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>The problem thus simplifies to determining if two expressions have the same normal form. Thus, we can construct a proof that each expression is equal to its normal form, and then compose those proofs together to show the unnormalized forms are equal.</p>
<p>My implementation is naive, and only works for expressions with a single variable, but I think the approach generalizes if you can find a suitable normal form for multiple variables.</p>
<p>All of this sounds like a good tack, but the hard part is convincing ourselves (and perhaps more importantly, Agda,) that the stated relationship holds. As it happens, we require three equivalent types:</p>
<ul>
<li><code>A</code>, the ring we’re actually trying to solve</li>
<li><code>Poly</code>, a syntactic representation of the ring operations</li>
<li><code>Horner</code>, the type of <code>A</code>-normal forms</li>
</ul>
<p><code>Poly</code> and <code>Horner</code> are indexed by <code>A</code>, but I’ve left that out for presentation purposes. Furthermore, they’re also both indexed by the degree of the polynomial, that is, the biggest power they contain. I’m not sure this was necessary, but it helped me make sure my math was right when I was figuring out how to multiply <code>Horner</code>s.</p>
<p>At a high level, solving a ring equality is really a statement about how <code>A</code> is related to <code>Poly</code> and <code>Horner</code>. We can construct an A-expression by substituting an <code>A</code> for all the variables in a <code>Poly</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly n <span class="ot">→</span> A <span class="ot">→</span> A</span></code></pre></div>
<p>and we can normalize any syntactic expression:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>normalize <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly n <span class="ot">→</span> Horner n</span></code></pre></div>
<p>thus we can solve a ring equation by hoisting a proof of equality of its normal forms into a proof of equality of its construction:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>solve</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>x y <span class="ot">:</span> Poly n<span class="ot">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> normalize x ≡ normalize y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> construct x a ≡ construct y a</span></code></pre></div>
<p>This approach is a bit underwhelming, since we need to explicitly construct syntactic objects (in <code>Poly</code>) corresponding to the expressions we’re trying to solve (in <code>A</code>). But this is something we can solve with Agda’s macro system, by creating the <code>Poly</code>s by inspecting the actual AST, so we’ll consider the approach good enough. Today’s post is about understanding how to do ring solving, not about how to engineer a nice user-facing interface.</p>
<p>The actual implementation of <code>solve</code> is entirely straight-forward:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>solve x y eq a <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    construct x a             ≡⟨ construct-is-normal x a ⟩</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">→</span> evaluate φ a<span class="ot">)</span> eq ⟩</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    evaluate <span class="ot">(</span>normalize y<span class="ot">)</span> a  ≡⟨ sym $ construct-is-normal y a ⟩</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    construct y a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  ∎</span></code></pre></div>
<p>given a lemma that <code>construct</code> is equal to evaluating the normal form:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>construct-is-normal</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> construct x a ≡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span></code></pre></div>
<p>The implementation of this is pretty straightforward too, requiring only that we have <code>+</code> and <code>*</code> homomorphisms between <code>Horner</code> and <code>A</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>+A-+H-homo</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>*A-*H-homo</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>These two lemmas turn out to be the hard part.</p>
<h2 id="but-first-types"><a href="#but-first-types" class="header-link">But First, Types<span class="header-link-emoji">🔗</span></a></h2>
<p>Before we get into all of that, let’s first discuss what each of the types looks like. We have <code>Poly</code>, which again, is an initial encoding of the ring algebra:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Poly <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  con <span class="ot">:</span> A <span class="ot">→</span> Poly <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  var <span class="ot">:</span> Poly <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>:+<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly m <span class="ot">→</span> Poly n <span class="ot">→</span> Poly <span class="ot">(</span>m ⊔ n<span class="ot">)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>:*<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly m <span class="ot">→</span> Poly n <span class="ot">→</span> Poly <span class="ot">(</span>m + n<span class="ot">)</span></span></code></pre></div>
<p>We can reify the meaning of <code>Poly</code> by giving a transformation into <code>A</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly N <span class="ot">→</span> A <span class="ot">→</span> A</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>construct var a <span class="ot">=</span> a</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>p :+ p2<span class="ot">)</span> a <span class="ot">=</span> construct p a +A construct p2 a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>p :* p2<span class="ot">)</span> a <span class="ot">=</span> construct p a *A construct p2 a</span></code></pre></div>
<p>Our other core type is <code>Horner</code>, which is an encoding of the Horner normal form of a polynomial:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Horner <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  PC <span class="ot">:</span> A <span class="ot">→</span> Horner <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  PX <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>suc n<span class="ot">)</span></span></code></pre></div>
<p><code>Horner</code> requires some discussion. Horner normal form isn’t the same normal form presented earlier, instead, it’s a chain of linear multiplications. For example, we earlier saw this:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>in Horner normal form, this would be written as</p>
<pre><code>0 + x * (3 + x * 5)</code></pre>
<p>The idea is we can write any polynomial inductively by nesting the bigger terms as sums inside of multiplications against <code>x</code>. We can encode the above as a <code>Horner</code> like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>PX <span class="dv">0</span> <span class="ot">(</span>PX <span class="dv">3</span> <span class="ot">(</span>PC <span class="dv">5</span><span class="ot">))</span></span></code></pre></div>
<p>and then reify the meaning of <code>Horner</code> with respect to <code>A</code> via <code>evaluate</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner n <span class="ot">→</span> A <span class="ot">→</span> A</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">(</span>PC x<span class="ot">)</span> v <span class="ot">=</span> x</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">(</span>PX x xs<span class="ot">)</span> v <span class="ot">=</span> x +A <span class="ot">(</span>v *A evaluate xs v<span class="ot">)</span></span></code></pre></div>
<h2 id="operations-on-horners"><a href="#operations-on-horners" class="header-link">Operations on Horners<span class="header-link-emoji">🔗</span></a></h2>
<p>We can define addition over <code>Horner</code> terms, which is essentially <code>zipWith (+A)</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>m ⊔ n<span class="ot">)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PC <span class="ot">(</span>x +A y<span class="ot">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> ys</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> xs</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> <span class="ot">(</span>xs +H ys<span class="ot">)</span></span></code></pre></div>
<p>We can also implement scalar transformations over <code>Horner</code>, which is exactly a monomorphic <code>fmap</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>scalMapHorner <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> A<span class="ot">)</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner m</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>scalMapHorner f <span class="ot">(</span>PC x<span class="ot">)</span> <span class="ot">=</span> PC <span class="ot">(</span>f x<span class="ot">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>scalMapHorner f <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>f x<span class="ot">)</span> <span class="ot">(</span>scalMapHorner f xs<span class="ot">)</span></span></code></pre></div>
<p>and finally, we can define multiplication over <code>Horner</code> terms:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span> y <span class="ot">=</span> scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> y</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span> <span class="ot">=</span> scalMapHorner <span class="ot">(_</span>*A y<span class="ot">)</span> <span class="ot">(</span>PX x xs<span class="ot">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> yy <span class="ot">=</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> yy +H PX #0 <span class="ot">(</span>xs *H yy<span class="ot">)</span></span></code></pre></div>
<p>The first two cases here are straightforward, just <code>scalMapHorner</code>-multiply in the constant value and go on your way. The <code>PX-PX</code> case is rather complicated however, but corresponds to the <code>*-+-distrib</code> law:</p>
<pre><code>*-+-distrib : ∀ x xs yy → (x + xs) * yy ≡ x * yy +A xs * yy</code></pre>
<p>We take advantage of the fact that we know <code>x</code> is a scalar, by immediately multiplying it in via <code>scalMapHorner</code>.</p>
<h2 id="tying-it-all-together"><a href="#tying-it-all-together" class="header-link">Tying it All Together<span class="header-link-emoji">🔗</span></a></h2>
<p>As alluded to earlier, all that’s left is to show <code>evaluate</code>-homomorphisms for <code>+H</code>/<code>+A</code> and <code>*H</code>/<code>*A</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>+A-+H-homo</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>*A-*H-homo</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>There’s nothing interesting in these proofs, it’s just three hundred ironic lines of tedious, boring proofs, of the sort that we are trying to automate away.</p>
<p>Given these, we can implement <code>construct-is-normal</code></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>construct-is-normal</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> construct x a ≡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> refl</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>construct-is-normal var a <span class="ot">=</span> refl</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>x :+ y<span class="ot">)</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> +A-+H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> refl</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>x :* y<span class="ot">)</span> a</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> *A-*H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> refl</span></code></pre></div>
<p>Nice!</p>
<p>The homomorphism proofs are left as an exercise to the reader, or you can go look at the <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">code</a> if you want to skip doing it.</p>
<h2 id="agda-woes"><a href="#agda-woes" class="header-link">Agda Woes<span class="header-link-emoji">🔗</span></a></h2>
<p>My implementation isn’t 100% complete, I still need to prove that <code>*H</code> is commutative:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>*H-comm <span class="ot">:</span> <span class="ot">∀</span> j k <span class="ot">→</span> j *H k ≡ k *H j</span></code></pre></div>
<p>which shouldn’t be hard, because it <em>is</em> commutative. Unfortunately, Agda has gone into hysterics, and won’t even typecheck the type of <code>*H-comm</code>, because it can’t figure out that <code>m + n = n + m</code> (the implicit indices on the result of <code>*H</code>). As far as I can tell, there is no easy fix here; there’s some weird <code>cong</code>-like thing for types called <code>subst</code>, but it seems to infect a program and push these weird-ass constraints everywhere.</p>
<p>This is extremely frustrating, because it’s literally the last thing to prove after 300 grueling lines of proof. And it’s also true and isn’t even hard to show. It’s just that I can’t get Agda to accept the type of the proof because it’s an idiot that doesn’t know about additive commutativity. After a few hours of fighting with getting this thing to typecheck, I just said fuck it and postulated <code>*H-comm</code>.</p>
<p>Stupid Agda.</p>
<p>If you know what I’ve done wrong to deserve this sort of hell, please let me know. It would be nice to be able to avoid problems like this in the future, or resolve them with great ease.</p>
<h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion<span class="header-link-emoji">🔗</span></a></h2>
<p>So, that’s it! Modulo a postulate, we’ve managed to implement a ring-solver by showing the equivalence of three different representations of the same data. Just to convince ourselves that it works:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>test-a <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>test-a <span class="ot">=</span> <span class="ot">(</span>var :+ con #1<span class="ot">)</span> :* <span class="ot">(</span>var :+ con #1<span class="ot">)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>test-b <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>test-b <span class="ot">=</span> var :* var :+ two :* var :+ con #1</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    two <span class="ot">=</span> con #1 :+ con #1</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>success</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>x +A #1<span class="ot">)</span> *A <span class="ot">(</span>x +A #1<span class="ot">)</span> ≡ <span class="ot">(</span>x *A x<span class="ot">)</span> +A <span class="ot">(</span>#1 +A #1<span class="ot">)</span> *A x +A #1</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>success x <span class="ot">=</span> solve test-a test-b refl x</span></code></pre></div>
<p>which Agda happily accepts!</p>
<p>I don’t exactly know offhand how to generalize this to multivariate polynomials, but I think the trick is to just find a normal form for them.</p>
<p>As usual, the code for this post is <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">available on Github.</a></p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Codata in Action</title>
      <id>blog/review-codata/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/review-codata/index.html'/>
      <published>2022-02-10</published>
      <updated>2022-02-10</updated>

      <content type="html">
        <![CDATA[
        <p>Today we’re looking at <a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf">Codata in Action</a> by Downen, Sullivan, Ariola and Peyton Jones. Please excuse my lack of any sort of theme as I review papers, I’m just picking things that seem interesting to me. This paper in particular was recommended to me by <a href="https://jonathanlorimer.dev/">Jonathan Lorimer</a> in the inaugural edition of the <a href="https://anchor.fm/cofree-coffee">Cofree Coffee Cast</a>, which is an excellent podcast that I may or may not be involved in.</p>
<p>So anyway, today we’re looking at codata. What’s that? Essentially, lazy records. By virtue of being lazy, Haskell makes the differentiation between data and codata rather hard to spot. The claim is that functional languages are big on data, object-oriented languages really like codata, and that everything you can do with one can be emulated by the other, which is useful if you’d like to compile FP to OOP, or vice versa.</p>
<p>Codata, like the name implies, have a lot of duals with regular ol’ data. The paper introduces a bunch of parallels between the two:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Data</th>
<th style="text-align: center;">Codata</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Concerned with construction</td>
<td style="text-align: center;">Concerned with destruction</td>
</tr>
<tr class="even">
<td style="text-align: center;">Define the types of constructors</td>
<td style="text-align: center;">Define the types of destructors</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Directly observable</td>
<td style="text-align: center;">Observable only via their interface</td>
</tr>
<tr class="even">
<td style="text-align: center;">Common in FP</td>
<td style="text-align: center;">Common in OOP</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Initial algebras</td>
<td style="text-align: center;">Terminal coalgebras</td>
</tr>
<tr class="even">
<td style="text-align: center;">Algebraic data structures</td>
<td style="text-align: center;">Abstract data structures</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>data</code></td>
<td style="text-align: center;"><code>class</code></td>
</tr>
</tbody>
</table>
<p>The paper’s claim is that codata is a very useful tool for doing real-world work, and that we are doing ourselves a disservice by not making it first-class:</p>
<blockquote>
<p>While codata types can be seen in the shadows behind many examples of programming—often hand-compiled away by the programmer—not many functional languages have support for them.</p>
</blockquote>
<p>That’s a particularly interesting claim; that we’re all already using codata, but it’s hidden away inside of an idiom rather than being a first-class citizen. I’m always excited to see the ghosts behind the patterns I am already using.</p>
<h2 id="examples-of-codata"><a href="#examples-of-codata" class="header-link">Examples of Codata<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper gives a big list of codata that we’re all already using without knowing it:</p>
<h3 id="churchboehmberarducci-encodings"><a href="#churchboehmberarducci-encodings" class="header-link">Church/Boehm–Berarducci encodings<span class="header-link-emoji">🔗</span></a></h3>
<p>Instead of writing</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span></span></code></pre></div>
<p>I can instead do the usual Church encoding:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  if ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>which I might express more naturally in Haskell via:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>ifThenElse <span class="dt">True</span>  t _ <span class="ot">=</span> t</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ifThenElse <span class="dt">False</span> _ f <span class="ot">=</span> f</span></code></pre></div>
<p>(I suspect this is that “hand-compiling away” that the authors were talking about)</p>
<p>However, in the codata presentation, I can recover <code>true</code> and <code>false</code> by building specific objects that fiddle with their arguments just right (using <a href>copatterns</a> from a few weeks ago):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="op">:</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dt">True</span> t _ <span class="ot">=</span> t</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="op">:</span> <span class="dt">Bool</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dt">False</span> _ f <span class="ot">=</span> f</span></code></pre></div>
<p>That’s neat, I guess!</p>
<p>As a follow-up, we can try talking about <code>Tree</code>s. Rather than the usual <code>data</code> definition:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Leaf</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Branch</span><span class="ot"> ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">walk ::</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>we can do it in codata:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  walk ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>and reconstruct the “constructors:”</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Leaf</span><span class="ot"> x ::</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>walk (<span class="dt">Leaf</span> t) mk _ <span class="ot">=</span> mk t</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Branch</span><span class="ot"> ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>walk (<span class="dt">Branch</span> l r) mk comb <span class="ot">=</span> comb (walk l mk comb) (walk r mk comb)</span></code></pre></div>
<p>The presentation in the paper hand-compiles <code>Tree!data</code> into two declarations:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">TreeVisitor</span> t a <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> visitLeaf   ::</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> visitBranch ::</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  walk ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>which is the same thing, but with better named destructors.</p>
<h3 id="demand-driven-programming-laziness"><a href="#demand-driven-programming-laziness" class="header-link">Demand-Driven Programming / Laziness<span class="header-link-emoji">🔗</span></a></h3>
<p>You know the problem. You’re programming some search, and want to have a stopping depth. Maybe you’re writing a chessai and don’t want to wait until the ends of time for the search to finish. Easy enough, right? Just add an integer that counts down whenever you recurse:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">search ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> [<span class="dt">Position</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>search <span class="dv">0</span> _ <span class="ot">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>search n as <span class="ot">=</span> <span class="co">-- do lots of work</span></span></code></pre></div>
<p>So you set <code>n</code> to something that seems reasonable, and get your moves back. But then you realize you had more time to kill, so you’d like to resume the search where you left off. But there’s no good way to do this, and starting back from the beginning would involve wasting a lot of effort. You can certainly program around it, but again, it’s hand-compiling away codata.</p>
<p>Instead, we can express the problem differently:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Rose</span> a <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> node ::</span> <span class="dt">Rose</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> children ::</span> <span class="dt">Rose</span> a <span class="ot">-&gt;</span> [<span class="dt">Rose</span> a]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Recall that codata is built-in lazy, so by repeatedly following <code>children</code> we can further explore the tree state. In OOP I guess we’d call this a generator or an iterator or something. Probably a factory of some sort.</p>
<p>But once we have <code>Rose</code> we can implement pruning:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prune ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Rose</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> <span class="dt">Rose</span> <span class="dt">Position</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>node (prune n t) <span class="ot">=</span> node t</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>children (prune <span class="dv">0</span> t) <span class="ot">=</span> []</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>children (prune n t) <span class="ot">=</span> <span class="fu">fmap</span> (prune (n <span class="op">-</span> <span class="dv">1</span>)) <span class="op">$</span> children t</span></code></pre></div>
<p>I <em>really</em> like copattern matching.</p>
<h3 id="abstract-data-types"><a href="#abstract-data-types" class="header-link">Abstract Data Types<span class="header-link-emoji">🔗</span></a></h3>
<p>You know how we have extentional and intentional definitions for sets? Like, compare:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Set</span> a <span class="ot">=</span> <span class="dt">Set</span> {<span class="ot"> unSet ::</span> [a] }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> s t <span class="ot">=</span> <span class="fu">elem</span> t <span class="op">$</span> unset s</span></code></pre></div>
<p>vs</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Set</span> a <span class="ot">=</span> <span class="dt">Set</span> {<span class="ot"> lookup ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>That latter version is the Church-encoded version. Instead we can give an interface for both sorts of sets as codata, defined by their <em>interface</em> as sets. This is everyday OOP stuff, but a little weird in FP land:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> isEmpty ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> lookup ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> insert ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> union ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>My dudes this is just an interface for how you might want to interact with a Set. We can implement the listy version from above:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">listySet ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>isEmpty (listySet ls) <span class="ot">=</span> <span class="fu">null</span> ls</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (listySet ls) a <span class="ot">=</span> <span class="fu">elem</span> a ls</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>insert (listySet ls) a <span class="ot">=</span> listSet (a <span class="op">:</span> ls)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>union (listySet ls) s <span class="ot">=</span> <span class="fu">foldr</span> insert s ls</span></code></pre></div>
<p>but we can also implement an infinitely big set akin to our functiony-version:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evensUnion ::</span> <span class="dt">Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>isEmpty (evensUnion s) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> (evensUnion s) a <span class="ot">=</span> <span class="fu">mod</span> a <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> <span class="fu">lookup</span> a s</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>insert (evensUnion s) a <span class="ot">=</span> evensUnion <span class="op">$</span> insert s a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>union (evensUnion s) s&#39; <span class="ot">=</span> evensUnion <span class="op">$</span> union s s&#39;</span></code></pre></div>
<p>This thing is a little odd, but <code>evensUnion</code> is the set of the even numbers unioned with some other set. The built-in unioning is necessary to be able to extend this thing. Maybe we might call it a decorator pattern in OOP land?</p>
<h3 id="pre-and-post-conditions"><a href="#pre-and-post-conditions" class="header-link">Pre and Post Conditions<span class="header-link-emoji">🔗</span></a></h3>
<p>One last example, using type indices to represent the state of something. The paper gives sockets:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Raw</span> <span class="op">|</span> <span class="dt">Bound</span> <span class="op">|</span> <span class="dt">Live</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Socket</span><span class="ot"> ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Socket</span> i <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> bind    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Raw</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Socket</span> <span class="dt">&#39;Bound</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> connect ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Bound</span> <span class="ot">-&gt;</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> send    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> recv    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> close   ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The type indices here ensure that we’ve bound the socket before connecting to it, and connected to it before we can send or receive.</p>
<p>Contrast this against what we can do with GADTs, which tell us how something was built, not how it can be used.</p>
<h2 id="converting-between-data-and-codata"><a href="#converting-between-data-and-codata" class="header-link">Converting Between Data and Codata<span class="header-link-emoji">🔗</span></a></h2>
<p>Unsurprisingly, data and codata are two sides of the same coin: we can compile one to the other and vice versa.</p>
<h3 id="data-to-codata"><a href="#data-to-codata" class="header-link">Data to Codata<span class="header-link-emoji">🔗</span></a></h3>
<p>Going from data to codata is giving a final encoding for the thing; as we’ve seen, this corresponds to the Boehm-Berarducci encoding. The trick is to replace the type with a function. Each data constructor corresponds to an argument of the function, the type of which is another function that returns <code>a</code>, and as arguments takes each argument to the data constructor. To tie the knot, replace the recursive bits with <code>a</code>.</p>
<p>Let’s take a look at a common type:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>We will encode this as a function, that returns some new type variable. Let’s call it <code>x</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span> <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then we need to give eliminators for each case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>elim_nil <span class="ot">-&gt;</span> elim_cons <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then replace each eliminator with a function that takes its arguments, and returns <code>x</code>. For <code>Nil</code>, there are no arguments, so it’s just:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">-&gt;</span> elim_cons <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then we do the same thing for <code>Cons :: a -&gt; List a -&gt; List a</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>of course, there is no <code>List a</code> type anymore, so we replace that with <code>x</code> too:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>And thus we have our codata-encoded list. For bonus points, we can do a little shuffling and renaming:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>which looks very similar to our old friend <code>foldr</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>In fact, a little more reshuffling shows us that <code>foldr</code> is exactly the codata transformation we’ve been looking for:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>Cool. The paper calls this transformation the “visitor pattern” which I guess makes sense; in order to call this thing we need to give instructions for what to do in every possible case.</p>
<p>This is an encoding of the type itself! But we also need codata encodings for the data constructors. The trick is to just ignore the “handlers” in the type that don’t correspond to your constructor. For example:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Nil</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Nil</span> _ nil <span class="ot">=</span> nil</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Cons</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> a</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> b</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> b</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Cons</span> <span class="fu">head</span> <span class="fu">tail</span> cons nil <span class="ot">=</span> cons nil (<span class="fu">tail</span> cons nil)</span></code></pre></div>
<p>Really, these write themselves once you have an eye for them. One way to think about it is that the handlers are “continuations” for how you want to continue. This is the dreaded CPS transformation!</p>
<h3 id="codata-to-data"><a href="#codata-to-data" class="header-link">Codata to Data<span class="header-link-emoji">🔗</span></a></h3>
<p>Let’s go the other way too. Appropriately, we can use codata streams:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>codata <span class="dt">Stream</span> a <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> head ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tail ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>I’m winging it here, but it’s more fun to figure out how to transform this than to get the information from the paper.</p>
<p>The obvious approach here is to just turn this thing directly into a record by dropping the <code>Stream a -&gt;</code> part of each field:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Stream</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> head ::</span> a</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tail ::</span> <span class="dt">Stream</span> a</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>While this works in Haskell, it doesn’t play nicely with strict languages. So, we can just lazify it by sticking each one behind a function:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Stream</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> head ::</span> () <span class="ot">-&gt;</span> a</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tail ::</span> () <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Looks good to me. But is this what the paper does? It mentions that we can <code>tabulate</code> a function, e.g., represent <code>Bool -&gt; String</code> as <code>(String, String)</code>. It doesn’t say much more than this, but we can do our own research. Peep the <code>Representable</code> class from <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html#t:Representable">adjunctions</a>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Distributive</span> f <span class="ot">=&gt;</span> <span class="dt">Representable</span> f <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> f ::</span> <span class="op">*</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  tabulate ::</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  index    ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Rep</span> f <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This thing is exactly the transformation we’re looking for; we can “represent” some structure <code>f a</code> as a function <code>Rep f -&gt; a</code>, and tabulating gets us back the thing we had in the first place.</p>
<p>So the trick here is then to determine <code>f</code> for the <code>Rep f</code> that corresponds to our <code>codata</code> structure. Presumably that thing is exactly the record we worked out above.</p>
<p>What’s interesting about this approach is that it’s exactly <a href="https://www.haskellforall.com/2012/05/scrap-your-type-classes.html">scrap-your-typeclasses.</a> And it’s exactly how typeclasses are implemented in Haskell. And last I looked, it’s the approach that Elm recommends doing instead of having typeclasses. Which makes sense why it’s annoying in Elm, because the language designers are forcing us to hand-compile our code! But I don’t need to beat that dead horse any further.</p>
<h2 id="thoughts"><a href="#thoughts" class="header-link">Thoughts<span class="header-link-emoji">🔗</span></a></h2>
<p>Something that piqued my interest is a quote from the paper:</p>
<blockquote>
<p>Functional langauges are typically rich in data types … but a paucity of codata types (usually just function types.)</p>
</blockquote>
<p>This is interesting, because functions are the only non-trivial source of contravariance in Haskell. Contravariance is the co- version of (the poorly named, IMO) covariance. Which is a strong suggestion that functions are a source of contravariance <em>because they are codata,</em> rather than contravariance being a special property of functions themselves.</p>
<p>I asked my super smart friend <a href="https://totbwf.github.io/">Reed Mullanix</a> (who also has a great podcast episode), and he said something I didn’t understand about presheafs and functors. Maybe presheafs would make a good next paper.</p>
<h2 id="conclusions"><a href="#conclusions" class="header-link">Conclusions<span class="header-link-emoji">🔗</span></a></h2>
<p>This was a helpful paper to to wrap my head around all this codata stuff that smart people in my circles keep talking about. None of it is <em>new,</em> but as a concept it helps solidify a lot of disparate facts I had rattling around in my brain. Doing this final tagless encoding of data types gives us a fast CPS thing that is quick as hell to run because it gets tail-optimized and doesn’t need to build any intermediary data structures, and gets driven by its consumer. The trade-off is that CPS stuff is a damn mind-melter.</p>
<p>At Zurihac 2018, I met some guy (whose name I can’t remember, sorry!) who was working on a new language that supported this automatic transformation between data and codata. I don’t remember anything about it, except he would just casually convert between data and codata whenever was convenient, and the compiler would do the heavy lifting of making everything work out. It was cool. I wish I knew what I was talking about.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Followup to Sorting with Bialgebras</title>
      <id>blog/bialgebra-followup/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/bialgebra-followup/index.html'/>
      <published>2022-02-08</published>
      <updated>2022-02-08</updated>

      <content type="html">
        <![CDATA[
        <p>Last week I was pretty down on the results of my <a href="/blog/bialgebras/">exploration into Sorting with Bialgebras</a>. I didn’t want to get into the habit of slamming through a paper just to not understand it, so I figured I’d take a hit on my yearly goal and spend this week getting the results up to snuff.</p>
<p>I started by really trying to wrap my head around how exactly the <code>ana . cata</code> pattern works. So I wrote out a truly massive number of trace statements, and stared at them until they made some amount of sense. Here’s what’s going on:</p>
<p><code>ana</code> takes an <code>a</code> and unfolds it into an <code>F a</code>, recursively repeating until it terminates by producing a non-inductive <code>F</code>-term. So here <code>F</code> is a <code>Sorted</code>. And then we need to give a folding function for <code>cata</code>. This fold happens in <code>Unsorted</code>, and thus has type <code>Unsorted (Sorted (Mu Unsorted)) -&gt; Sorted (Mu Unsorted)</code>. The idea here is that the <code>cata</code> uses its resulting <code>Sorted</code> to pull forward the smallest element it’s seen so far. Once the <code>cata</code> is finished, the <code>ana</code> gets a term <code>Sorted (Mu Unsorted)</code>, where the <code>Sorted</code> term is the head of the synthesized list, and the <code>Mu Unsorted</code> is the next “seed” to recurse on. This <code>Mu Unsorted</code> is one element smaller than it was last time around, so the recursion eventually terminates.</p>
<p>OK, so that’s all well and good. But what does <code>ana . para</code> do here? Same idea, except that the fold also gets a <code>Mu Unsorted</code> term, corresponding to the unsorted tail of the list — aka, before it’s been folded by <code>para</code>.</p>
<p>The paper doesn’t have much to say about <code>para</code>:</p>
<blockquote>
<p>in a paramorphism, the algebra also gets the remainder of the list. This extra parameter can be seen as a form of an as-pattern and is typically used to match on more than one element at a time or to detect that we have reached the final element.</p>
</blockquote>
<p>That’s all well and good, but it’s unclear how this can help us. The difference between <code>naiveIns</code> and <code>ins</code> is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>naiveIns</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>naiveIns <span class="dt">UNil</span> <span class="ot">=</span> <span class="dt">SNil</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">SNil</span>) <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">UNil</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>naiveIns (a <span class="op">:&gt;</span> b <span class="op">:!</span> x)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b    <span class="ot">=</span> a <span class="op">:!</span> b <span class="op">:&gt;</span> x</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b <span class="op">:!</span> a <span class="op">:&gt;</span> x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>ins</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (c, <span class="dt">Sorted</span> a x)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> c (<span class="dt">Unsorted</span> a x))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>ins <span class="dt">UNil</span> <span class="ot">=</span> <span class="dt">SNil</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>ins (a <span class="op">:&gt;</span> (x, <span class="dt">SNil</span>)) <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">Left</span> x</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>ins (a <span class="op">:&gt;</span> (x, b <span class="op">:!</span> x&#39;))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b    <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">Left</span> x</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b <span class="op">:!</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x&#39;)</span></code></pre></div>
<p>Ignore the <code>Left/Right</code> stuff. The only difference here is whether we use <code>x</code> or <code>x&#39;</code> in the last clause, where <code>x</code> is the original, unsorted tail, and <code>x&#39;</code> is the somewhat-sorted tail. It’s unclear to me how this can possibly help improve performance; we still need to have traversed the entire tail in order to find the smallest element. Maybe there’s something about laziness here, in that we shouldn’t need to rebuild the tail, but we’re going to be sharing the tail-of-tail regardless, so I don’t think this buys us anything.</p>
<p>And this squares with my confusion last week; this “caching” just doesn’t seem to do anything. In fact, the paper doesn’t even say it’s caching. All it has to say about our original <code>naiveIns</code>:</p>
<blockquote>
<p>Why have we labelled our insertion sort as naïve? This is because we are not making use of the fact that the incoming list is ordered— compare the types of <code>bub</code> and <code>naiveIns</code>. We will see how to capitalise on the type of <code>naiveIns</code> in Section 5.</p>
</blockquote>
<p>and then in section 5:</p>
<blockquote>
<p>The sole difference between sel and bub (Section 3) is in the case where a 6 b: <code>sel</code> uses the remainder of the list, supplied by the paramorphism, rather than the result computed so far. This is why <code>para sel</code> is the true selection function, and fold bub is the naïve variant, if you will.</p>
</blockquote>
<p>OK, fair, that checks out with what came out of my analysis. The <code>ana . para</code> version does use the tail of the original list, while <code>ana . cata</code> uses the version that might have already done some shuffling. But this is work we needed to do anyway, and moves us closer to a sorted list, so it seems insane to throw it away!</p>
<p>The best argument I can come up with here is that the <code>ana . para</code> version is dual to <code>cata . apo</code>, which signals whether the recursion should stop early. That one sounds genuinely useful to me, so maybe the paper does the <code>ana . para</code> thing just out of elegance.</p>
<p>Unfortunately, <code>cata . apo</code> doesn’t seem to be a performance boost in practice. In fact, both <code>cata . ana</code> and <code>ana . cata</code> perform significantly better than <code>cata . apo</code> and <code>ana . para</code>. Even more dammingly, the latter two perform better when they ignore the unique abilities that <code>apo</code> and <code>para</code> provide.</p>
<p>Some graphs are worth a million words:</p>
<center>
<img src="/images/bialgebra/o0-by-size.png">
</center>
<center>
<img src="/images/bialgebra/o0-by-algo.png">
</center>
<p>These are performance benchmarks for <code>-00</code>, using <code>Data.List.sort</code> as a control (“sort”). The big numbers on the left are the size of the input. “bubble” is the naive version of “selection.” Additionally, the graphs show the given implementations of <code>quickSort</code> and <code>treeSort</code>, as well as the two variations I was wondering about in the last post (here called <code>quickTree</code> and <code>treeQuick</code>.)</p>
<p>The results are pretty damming. In <em>all</em> cases, bubble-sort is the fastest of the algorithms presented in the paper. That’s, uh, not a good sign.</p>
<p>Furthermore, the “no caching” versions of “insertion” and “selection” both perform better than their caching variants. They are implemented by just ignoring the arguments that we get from <code>apo</code> and <code>para</code>, and simulating being <code>ana</code> and <code>cata</code> respectively. That means: whatever it is that <code>apo</code> and <code>para</code> are doing is <em>strictly worse</em> than not doing it.</p>
<p>Not a good sign.</p>
<p>But maybe this is all just a result of being run on <code>-O0</code>. Let’s try turning on optimizations and seeing what happens:</p>
<center>
<img src="/images/bialgebra/o2-by-size.png">
</center>
<center>
<img src="/images/bialgebra/o2-by-algo.png">
</center>
<p>About the same. Uh oh.</p>
<p>I don’t know what to blame this on. Maybe the constant factors are bad, or it’s a runtime thing, or I fucked up something in the implementation, or maybe the paper just doesn’t do what it claims. It’s unclear. But <a href="https://github.com/isovector/reviews/blob/d4dfc42aa2b993a6b0d536a6d96bef4e86f30f65/app/Main.hs#L19-L30">here’s my code</a>, in case you want to take a look and tell me if I screwed something up. The criterion reports are available for <a href="/graphs/bialgebra-o0.html"><code>-O0</code></a> and <a href="/graphs/bialgebra-o2.html"><code>-O2</code></a> (slightly different than in the above photos, since I had to rerun them.)</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Sorting with Bialgebras and Distributive Laws</title>
      <id>blog/bialgebras/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/bialgebras/index.html'/>
      <published>2022-02-05</published>
      <updated>2022-02-05</updated>

      <content type="html">
        <![CDATA[
        <p>Today’s paper is <a href="http://www.cs.ox.ac.uk/people/daniel.james/sorting/sorting.pdf">Sorting with Bialgebras and Distributive Laws</a> by Hinze et al. The main thrust of the paper is that many well-known sorting algorithms are categorical duals of one another! As seems to be usual for the papers I review, there’s a lot of <a href="/blog/recursion-schemes">recursion scheme</a> stuff here, so go read that first if you’re unfamiliar with it.</p>
<p>Something that’s stymied me while working through <em>Sorting with Bialgebras</em> is that whatever it is we’re doing here, it’s not observable. All sorting functions are extentionally equal — so the work being done here is necessarily below the level of equality. This doesn’t jive well with how I usually think about programming, and has made it very hard for me to see exactly what the purpose of all of this is. But I digress.</p>
<h2 id="bubblesort-and-naive-insertion-sort"><a href="#bubblesort-and-naive-insertion-sort" class="header-link">Bubblesort and Naive Insertion Sort<span class="header-link-emoji">🔗</span></a></h2>
<p>Hinze et al. begin by showing us that insertion sort and bubble sort have terse implementations:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>insertSort <span class="ot">=</span> <span class="fu">foldr</span> insert []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">selectSort ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>selectSort <span class="ot">=</span> unfoldr select</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    select ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [a])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    select [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    select as <span class="ot">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x <span class="ot">=</span> <span class="fu">minimum</span> as</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>          xs <span class="ot">=</span> delete x as</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="dt">Just</span> (x, xs)</span></code></pre></div>
<p>and that there are two dualities here, <code>foldr</code> is dual to <code>unfoldr</code>, and <code>insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code> is dual to <code>select :: Ord a =&gt; [a] -&gt; Maybe (a, [a])</code>.</p>
<p>The rest of the paper is pulling on this thread to see where it goes. As a first step, it’s noted that <code>foldr</code> and <code>unfoldr</code> are hiding a lot of interesting details, so instead we will divide the sorting problem into two halves: a catamorphism to tear down the unsorted list, and an anamorphism to build up the sorted version.</p>
<p>Begin by defining <code>Mu</code> and <code>Nu</code>, which are identical in Haskell. The intention here is that we can tear down <code>Mu</code>s, and build up <code>Nu</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="ot">=</span> <span class="dt">Mu</span> {<span class="ot"> unMu ::</span> f (<span class="dt">Mu</span> f) }</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Nu</span> f <span class="ot">=</span> <span class="dt">Nu</span> {<span class="ot"> unNu ::</span> f (<span class="dt">Nu</span> f) }</span></code></pre></div>
<p>as witnessed by <code>cata</code> and <code>ana</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>cata f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f) <span class="op">.</span> unMu</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nu</span> f</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>ana f <span class="ot">=</span> <span class="dt">Nu</span> <span class="op">.</span> <span class="fu">fmap</span> (ana f) <span class="op">.</span> f</span></code></pre></div>
<p>We’ll also need a pattern functor to talk about lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListF</span> (<span class="ot">t ::</span> <span class="dt">Tag</span>) a k <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> a <span class="op">:&gt;</span> k</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:&gt;</span></span></code></pre></div>
<p>This <code>Tag</code> thing is of my own devising, it’s a phantom type to track whether or not our list is sorted:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tag</span> <span class="ot">=</span> <span class="dt">UnsortedTag</span> <span class="op">|</span> <span class="dt">SortedTag</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Unsorted</span> <span class="ot">=</span> <span class="dt">ListF</span> <span class="dt">&#39;UnsortedTag</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Sorted</span> <span class="ot">=</span> <span class="dt">ListF</span> <span class="dt">&#39;SortedTag</span></span></code></pre></div>
<p>Note that in Haskell, nothing ensures that <code>Sorted</code> values are actually sorted! This is just some extra machinery to get more informative types.</p>
<p>With everything in place, we can now write the type of a sorting function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SortingFunc</span> a <span class="ot">=</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Mu</span> (<span class="dt">Unsorted</span> a) <span class="ot">-&gt;</span> <span class="dt">Nu</span> (<span class="dt">Sorted</span> a)</span></code></pre></div>
<p>that is, a sorting function is something that tears down an unsorted list, and builds up a sorted list in its place. Makes sense, and the extra typing helps us keep track of which bits are doing what.</p>
<p>Most of the paper stems from the fact that we can implement a <code>SortingFunc</code> in two ways. We can either:</p>
<ol type="1">
<li>write a <code>cata</code> that tears down the <code>Mu</code> by building up a <code>Nu</code> via <code>ana</code>, or</li>
<li>write an <code>ana</code> that builds up the <code>Nu</code> that tears down the <code>Mu</code> via <code>cata</code></li>
</ol>
<p>Let’s look at the first case:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">naiveInsertSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>naiveInsertSort <span class="ot">=</span> cata <span class="op">$</span> ana _</span></code></pre></div>
<p>this hole has type</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>               <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span></code></pre></div>
<p>which we can think of as having stuck an element on the front of an otherwise sorted list, and then needing to push that unsortedness one layer deeper. That does indeed sound like insertion sort: take a sorted list, and then traverse through it, sticking the unsorted element in the right place. It’s “naive” because the recursion doesn’t stop once it’s in the right place — since the remainder of the list is already sorted, it’s OK to stop.</p>
<p>The paper deals with this issue later.</p>
<p>Let’s write a function with this type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>naiveIns</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>naiveIns <span class="dt">Nil</span>                 <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">Nu</span> <span class="dt">Nil</span>)       <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Nil</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                   <span class="ot">=</span> a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                <span class="ot">=</span> b <span class="op">:&gt;</span> a <span class="op">:&gt;</span> x</span></code></pre></div>
<p>The first two cases are uninteresting. But the cons-cons case is — we need to pick whichever of the two elements is smaller, and stick it in front. In doing so, we have sorted the first element in the list, and pushed the unsortedness deeper.</p>
<p>This all makes sense to me. But I find the dual harder to think about. Instead of making a <code>cata . ana</code>, let’s go the other way with an <code>ana . cata</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bubbleSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>bubbleSort <span class="ot">=</span> ana <span class="op">$</span> cata _</span></code></pre></div>
<p>this hole now has type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span></code></pre></div>
<p>which is now an unsorted element in front of a sorted element, in front of the remainder of an unsorted list. What does it mean to be a single sorted element? Well, it must be the smallest element in the otherwise unsorted list. Thus, the smallest element in a list bubbles its way to the front.</p>
<p>On my first reading of this, I thought to myself “that sure sounds a lot like selection sort!” But upon close reading later, it’s not. Insertion sort knows where to put the smallest element it’s found, and does that in constant time. Bubble sort instead swaps adjacent elements, slowly getting the smallest element closer and closer to the front.</p>
<p>Let’s implement a function with this type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>bub</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>bub <span class="dt">Nil</span>            <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>bub (a <span class="op">:&gt;</span> <span class="dt">Nil</span>)     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Mu</span> <span class="dt">Nil</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>bub (a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b         <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Mu</span> (b <span class="op">:&gt;</span> x)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Mu</span> (a <span class="op">:&gt;</span> x)</span></code></pre></div>
<p>While <code>naiveIns</code> pushes unsorted elements inwards, <code>bub</code> pulls sorted elements outwards. But, when you look at the implementations of <code>bub</code> and <code>naiveIns</code>, they’re awfully similar! This is the main thrust of the paper — we can factor out a common core of <code>naiveIns</code> and <code>bub</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>swap</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>swap <span class="dt">Nil</span>            <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>swap (a <span class="op">:&gt;</span> <span class="dt">Nil</span>)     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Nil</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>swap (a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b          <span class="ot">=</span> a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">=</span> b <span class="op">:&gt;</span> a <span class="op">:&gt;</span> x</span></code></pre></div>
<p>It wasn’t immediately clear to me why this works, since the types of <code>bub</code> and <code>ins</code> seem to be more different than this. But when we compare them, this is mostly an artifact of the clunky fixed-point encodings:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- type of bub</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- unroll a Mu:</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- let x ~ Mu (Unsorted a)</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- let x ~ Nu (Sorted a)</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- unroll a Nu</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- type of naiveIns</span></span></code></pre></div>
<p>The only difference here is we are no longer packing <code>Mu</code>s and unpacking <code>Nu</code>s. We can pull that stuff out:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bubbleSort&#39;&#39; ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>bubbleSort&#39;&#39; <span class="ot">=</span> ana <span class="op">$</span> cata <span class="op">$</span> <span class="fu">fmap</span> <span class="dt">Mu</span> <span class="op">.</span> swap</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">naiveInsertSort&#39;&#39; ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>naiveInsertSort&#39;&#39; <span class="ot">=</span> cata <span class="op">$</span> ana <span class="op">$</span> swap <span class="op">.</span> <span class="fu">fmap</span> unNu</span></code></pre></div>
<p>and thus have shown that <code>bubbleSort&#39;&#39;</code> and <code>naiveInsertSort&#39;&#39;</code> are duals of one another.</p>
<h2 id="bialgebras"><a href="#bialgebras" class="header-link">Bialgebras<span class="header-link-emoji">🔗</span></a></h2>
<p>Allegedly, this stuff is all “just a bialgebra.” So, uh, what’s that? The authors draw a bunch of cool looking commutative diagrams that I would love to try to prove, but my attempts to do this paper in Agda were stymied by <code>Mu</code> and <code>Nu</code> being too recursive. So instead we’ll have to puzzle through it like peasants instead.</p>
<p>The universal mapping property of initial algebras (here, <code>Mu</code>) is the following:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>cata f <span class="op">.</span> <span class="dt">Mu</span> <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f)</span></code></pre></div>
<p>and dually, for terminal coalgebras (<code>Nu</code>):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>unNu <span class="op">.</span> ana f <span class="ot">=</span> <span class="fu">fmap</span> (ana f) <span class="op">.</span> f</span></code></pre></div>
<p>Let’s work on the <code>cata</code> diagram, WLOG. This UMP gives us:</p>
<pre><code>                     fmap (cata bub)
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
     Mu  |                                      |  bub
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                     cata bub</code></pre>
<p>but as we saw in <code>bubbleSort&#39;&#39;</code>, <code>bub = fmap Mu . swap</code>, thus:</p>
<pre><code>                     fmap (cata bub)
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
         |                                      |  swap
         |                                      v
     Mu  |                        Sorted (Unsorted (Mu Unsorted))
         |                                      |
         |                                      |  fmap Mu
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                     cata bub</code></pre>
<p>If we let <code>c = cata bub</code> and <code>a = Mu</code>, this diagram becomes</p>
<pre><code>                          fmap c
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
         |                                      |  swap
         |                                      v
      a  |                        Sorted (Unsorted (Mu Unsorted))
         |                                      |
         |                                      |  fmap a
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                          c</code></pre>
<p>and allgedly, this is the general shape of an <code>f</code>-<em>bialgebra</em>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">.</span> a <span class="ot">=</span> <span class="fu">fmap</span> a <span class="op">.</span> f <span class="op">.</span> <span class="fu">fmap</span> c</span></code></pre></div>
<p>where <code>a : forall x. F x -&gt; x</code> and <code>c : forall x. x -&gt; G x</code>, thus <code>f : forall x. F (G x) -&gt; G (F x)</code>. In Agda:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Bialgebra</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">{</span>F G <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">{</span>F-functor <span class="ot">:</span> Functor F<span class="ot">}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>       <span class="ot">{</span>G-functor <span class="ot">:</span> Functor G<span class="ot">}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>       <span class="ot">(</span>f <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> F <span class="ot">(</span>G X<span class="ot">)</span> <span class="ot">→</span> G <span class="ot">(</span>F X<span class="ot">))</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> F X <span class="ot">→</span> X</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> X <span class="ot">→</span> G X</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    bialgebra-proof</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>      <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>      <span class="ot">→</span> c <span class="ot">{</span>X<span class="ot">}</span> ∘ a ≡ map G-functor a ∘ f ∘ map F-functor c</span></code></pre></div>
<p>where we can build two separate <code>Bialgebra swap</code>s:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>bubbleSort <span class="ot">:</span> Bialgebra swap</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>a bubbleSort <span class="ot">=</span> cata bub</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>c bubbleSort <span class="ot">=</span> Mu</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>bialgebra-proof bubbleSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>naiveInsertSort <span class="ot">:</span> Bialgebra swap</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>a naiveInsertSort <span class="ot">=</span> unNu</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>c naiveInsertSort <span class="ot">=</span> ana bub</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>bialgebra-proof naiveInsertSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>I’m not entirely confident about this, since as said earlier, I don’t have this formalized in Agda. It’s a shame, because this looks like it would be a lot of fun to do. We’re left with a final diagram, equaqting <code>cata (ana naiveIns)</code> and <code>ana (cata bub)</code>:</p>
<pre><code>                  ?fmap (cata (ana naiveIns))?
 Unsorted (Mu Unsorted)  - - - - -&gt;  Unsorted (Nu Sorted)
          |                                      |
      Mu  |                                      |  ana naiveIns
          v           cata (ana naiveIns)        v
      Mu Unsorted  - - - - - -|| - - - - -&gt;  Nu Sorted
          |             ana (cata bub)           |
cata bub  |                                      |  unNu
          v                                      v
   Sorted (Mu Unsorted)  - - - - - -&gt;  Sorted (Nu Sorted)
                   ?fmap (ana (cata bub)?</code></pre>
<p>The morphisms surrounded by question marks aren’t given in the paper, but I’ve attempted to fill them in. The ones I’ve given complete the square, but they’re the opposite of what I’d expect from the initial algebra / terminal coalgebra UMPs. This is something to come back to, I think, but is rather annoying since Agda would just tell me the damn answer.</p>
<h2 id="paramorphisms-and-apomorphisms"><a href="#paramorphisms-and-apomorphisms" class="header-link">Paramorphisms and Apomorphisms<span class="header-link-emoji">🔗</span></a></h2>
<p>Standard recursion scheme machinery:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">para ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f (<span class="dt">Mu</span> f, a) <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>para f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> para f) <span class="op">.</span> unMu</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">apo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Either</span> (<span class="dt">Nu</span> f) a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nu</span> f</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>apo f <span class="ot">=</span> <span class="dt">Nu</span> <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> (apo f)) <span class="op">.</span> f</span></code></pre></div>
<p>The idea is that <code>para</code>s can look at all the structure that hasn’t yet been folded, while <code>apo</code>s can exit early by giving a <code>Left</code>.</p>
<h2 id="insertion-and-selection-sort"><a href="#insertion-and-selection-sort" class="header-link">Insertion and Selection Sort<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper brings us back to insertion sort. Instead of writing the naive version as a <code>cata . ana</code>, we will now try writing it as a <code>cata . apo</code>. Under this new phrasing, we get the type:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                      (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))))</span></code></pre></div>
<p>which is quite a meaningful type. Now, our type can signal that the resuling list is already sorted all the way through, or that we had to push an unsorted value inwards. As a result, <code>ins</code> looks exactly like <code>bub</code>, except that we can stop early in most cases, safe in the knowledge that we haven’t changed the sortedness of the rest of the list. The <code>b &lt; a</code> case is the only one which requires further recursion.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>ins</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                        (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>ins <span class="dt">Nil</span>                 <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>ins (a <span class="op">:&gt;</span> <span class="dt">Nu</span> <span class="dt">Nil</span>)       <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> (<span class="dt">Nu</span> <span class="dt">Nil</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>ins (a <span class="op">:&gt;</span> <span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b              <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> (<span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))  <span class="co">-- already sorted!</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x)</span></code></pre></div>
<p>Let’s think now about selection sort. Which should be an <code>ana . para</code> by duality, with the resulting type:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Unsorted</span> a ( <span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>                , <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span></code></pre></div>
<p>It’s much harder for me to parse any sort of meaning out of this type. Now our input has both all the unsorted remaining input, as well as a single term bubbling up. I actually can’t figure out how this helps us; presumably it’s something about laziness and not needing to do something with the sorted side’s unsorted tail? But I don’t know. Maybe a reader can drop a helpful comment.</p>
<p>Anyway, the paper gives us <code>sel</code> which implements the type:</p>
<pre><code>sel
    :: Ord a
    =&gt; Unsorted a ( Mu (Unsorted a)
                  , Sorted a (Mu (Unsorted a))
                  )
    -&gt; Sorted a (Mu (Unsorted a))
sel Nil                  = Nil
sel (a :&gt; (x, Nil))      = a :&gt; x
sel (a :&gt; (x, b :&gt; x&#39;))
  | a &lt;= b               = a :&gt; x
  | otherwise            = b :&gt; Mu (a :&gt; x&#39;)</code></pre>
<p>Getting an intution here as to why the <code>otherwise</code> case uses <code>x&#39;</code> instead of <code>x</code> is an exercise left to the reader, who can hopefully let me in on the secret.</p>
<p>As before, we can pull a bialgebra out of <code>ins</code> and <code>sel</code>. This time, the input side uses the <code>(,)</code>, and the output uses <code>Either</code>, and I suppose we get the best of both worlds: early stopping, and presumably whatever caching comes from <code>(,)</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>swop</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (x, <span class="dt">Sorted</span> a x)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> x (<span class="dt">Unsorted</span> a x))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>swop <span class="dt">Nil</span>                    <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>swop (a <span class="op">:&gt;</span> (x, <span class="dt">Nil</span>))        <span class="ot">=</span> a <span class="op">:&gt;</span> (<span class="dt">Left</span> x)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>swop (a <span class="op">:&gt;</span> (x, (b <span class="op">:&gt;</span> x&#39;)))</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                  <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> x</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x&#39;)</span></code></pre></div>
<p>This time our bialgebras are:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>insertSort <span class="ot">:</span> Bialgebra swop</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>a insertSort <span class="ot">=</span> apo ins</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>c insertSort <span class="ot">=</span> id &amp;&amp;&amp; unNu</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>bialgebra-proof insertSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>selectSort <span class="ot">:</span> Bialgebra swop</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>a selectSort <span class="ot">=</span> para sel</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>c selectSort <span class="ot">=</span> either id Mu</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>Bialgebra<span class="ot">.</span>bialgebra-proof selectSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<h2 id="quicksort-and-treesort"><a href="#quicksort-and-treesort" class="header-link">Quicksort and Treesort<span class="header-link-emoji">🔗</span></a></h2>
<p>Lots of the same techniques, and I’m running out of time, so we’ll go quickly. The key insight thus far is that select sort and insert sort both suck. How do we go faster than <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>?</span> Quicksort, and Treesort!</p>
<p>What’s interesting to me is I never considered Quicksort to be a tree-sorting algorithm. But of course it is; it’s recursively dividing an array in half, sorting each, and then putting them back together. But that fact is obscured by all of this “pivoting” nonsense; it’s just a <a href="https://www.youtube.com/watch#v=oaIMMclGuog">tree algorithm projected onto arrays</a>.</p>
<p>Hinze et al. present specialized versions of Quicksort and Treesort, but we’re just going to skip to the bialgebra bits:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a k <span class="ot">=</span> <span class="dt">Empty</span> <span class="op">|</span> <span class="dt">Node</span> k a k</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>sprout</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (x, <span class="dt">Tree</span> a x)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Tree</span> a (<span class="dt">Either</span> x (<span class="dt">Unsorted</span> a x))</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>sprout <span class="dt">Nil</span>                <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>sprout (a <span class="op">:&gt;</span> (x, <span class="dt">Empty</span>))  <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Left</span> x) a (<span class="dt">Left</span> x)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>sprout (a <span class="op">:&gt;</span> (x, (<span class="dt">Node</span> l b r)))</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Right</span> (a <span class="op">:&gt;</span> l)) b (<span class="dt">Left</span> r)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>             <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Left</span> l) b (<span class="dt">Right</span> (a <span class="op">:&gt;</span> r))</span></code></pre></div>
<p>This is the creation of a binary search tree. <code>Left</code> trees don’t need to be manipulated, and <code>Right</code> ones need to have the new unsorted element pushed down. The other half of the problem is to extract elements from the BST:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>wither</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Tree</span> a (x, <span class="dt">Sorted</span> a x)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> x (<span class="dt">Tree</span> a x))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>wither <span class="dt">Empty</span>                        <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>wither (<span class="dt">Node</span> (_, <span class="dt">Nil</span>) a (r, _))     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> r</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>wither (<span class="dt">Node</span> (_, b <span class="op">:&gt;</span> l&#39;) a (r, _)) <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (<span class="dt">Node</span> l&#39; a r)</span></code></pre></div>
<p>I think I understand what’s going on here. We have a tree with nodes <code>a</code> and “subtrees” <code>Sorted a x</code>, where remember, <code>x</code> ties the knot. Thus, in the first level of the tree, our root node is the pivot, and then the left “subtree” is the subtree itself, plus a view on it corresponding to the smallest element in it. That is, in <code>(x, Sorted a x)</code>, the <code>fst</code> is the tree, and the <code>snd</code> is the smallest element that has already been pulled out.</p>
<p>So, if we have a left cons, we want to return that, since it’s necessarily smaller than our root. But we continue (via <code>Right</code>) with a new tree, using the same root and right sides, letting the recursion scheme machinery reduce that into its smallest term.</p>
<p>But I must admit that I’m hand-waving on this one. I suspect better understanding would come from getting better intutions behind <code>para</code> and <code>apo</code>.</p>
<p>Let’s tie things off then, since I’ve clearly hit my limit of understanding on this paper for this week. While having a deadline is a nice forcing function to actually go through papers, it’s not always the best for deeply understanding them! Alas, something to think about for the future.</p>
<p>We’re given two implementations of <code>grow</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>grow,<span class="ot"> grow&#39; ::</span> <span class="dt">Mu</span> <span class="dt">Unsorted</span> <span class="ot">-&gt;</span> <span class="dt">Nu</span> <span class="dt">Tree</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>grow  <span class="ot">=</span> ana  <span class="op">.</span> para <span class="op">$</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> unNu) <span class="op">.</span> sprout</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>grow&#39; <span class="ot">=</span> cata <span class="op">.</span> apo  <span class="op">$</span> sprout <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> <span class="dt">Mu</span>)</span></code></pre></div>
<p>as well as two for <code>flatten</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>flatten,<span class="ot"> flatten&#39; ::</span> <span class="dt">Mu</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Nu</span> <span class="dt">Sorted</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>grow  <span class="ot">=</span> cata <span class="op">.</span> apo  <span class="op">$</span> wither <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> unNu)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>grow&#39; <span class="ot">=</span> ana  <span class="op">.</span> para <span class="op">$</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> <span class="dt">Mu</span>) <span class="op">.</span> wither</span></code></pre></div>
<p>and then finally, give us <code>quickSort</code> and <code>treeSort</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>quickSort,<span class="ot"> treeSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>quickSort <span class="ot">=</span> flatten  <span class="op">.</span> downcast <span class="op">.</span> grow</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>treeSort  <span class="ot">=</span> flatten&#39; <span class="op">.</span> downcast <span class="op">.</span> grow&#39;</span></code></pre></div>
<p>where <code>downcast</code> was given earlier as:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">downcast ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Nu</span> f <span class="ot">-&gt;</span> <span class="dt">Mu</span> f</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>downcast <span class="ot">=</span> <span class="dt">Mu</span> <span class="op">.</span> <span class="fu">fmap</span> downcast <span class="op">.</span> unNu</span></code></pre></div>
<p>This is interesting, but comes with an obvious questions: what if we intermix <code>flatten</code> with <code>grow&#39;</code>, and vice versa? Rather unexcitingly, they still sort the list, and don’t seem to have different asymptotics. As a collorary, we must thus be excited, and assume that these are two “new” sorting functions, at least, ones without names. I guess that’s not too surprising; there are probably infinite families of sorting functions.</p>
<h2 id="conclusions-notes-to-self"><a href="#conclusions-notes-to-self" class="header-link">Conclusions / Notes to Self<span class="header-link-emoji">🔗</span></a></h2>
<p>What a fun paper! I did a bad thing by jumping into Agda too quickly, hoping it would let me formalize the “this is a sorted list” stuff. But that turned out to be premature, since the <code>Sorted</code> wrapper is only ever a pair, and exists only to signal some information to the reader. Thus, I spent six hours working through the Agda stuff before realizing my deadline was coming up sooner than later.</p>
<p>Implicit in that paragraph is that I started implementing before I had read through the entire paper, which was unwise, as it meant I spent a lot of time on things that turned out to be completely unrelated. Note to self to not do this next time.</p>
<p>Also, it turns out I’m not as firm on recursion schemes as I thought! It’d be valuable for me to go through <code>para</code>s in much more depth than I have now, and to work harder at following the stuff in this paper. How do the authors keep everything straight? Do they just have more experience, or are they using better tools than I am?</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Underlining the Bugs</title>
      <id>blog/underline-bugs/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/underline-bugs/index.html'/>
      <published>2022-01-31</published>
      <updated>2022-01-31</updated>

      <content type="html">
        <![CDATA[
        <p>I had a magical Haskell experience today, and want to share the story.</p>
<p>My current big programming project is <a href="https://github.com/isovector/cornelis"><code>cornelis</code></a> — a vim plugin for interacting with Agda. The Agda compiler is really good at doing interactive programming, but until <code>cornelis</code>, all of this functionality has been locked away, only to be used by blessed emacs developers.</p>
<p>Tooling for (neo)vim has gotten really good since I last looked at it, and these days you can write plugins in a language of your choice. For anyone lucky enough to not appreciate how lovely this is, vimscript’s comparison operator checks a global flag to see if it should be case-sensitive or not. From that perspective, it’s truly a testament that <em>anyone</em> has managed to write <em>anything</em> for vim.</p>
<p>The Haskell library for talking to (neo)vim is <a href="https://github.com/neovimhaskell/nvim-hs">particularly excellent</a>, and I would strongly recommend it if you’re thinking about writing a vim plugin.</p>
<p>So anyway, the Agda compiler has this cool mode where you can send it queries about your code, and it gives back answers in JSON. For example, you might ask “what type does this thing have?” or “please case split this for me” and Agda will give you back answers. A plugin like <code>cornelis</code> or <code>agda-mode</code> (for emacs) can turn Agda’s responses into a lovely editing environment, where the computer does most of the work of programming for you.</p>
<p>Agda doesn’t actually make any changes for you, it just says things like “replace from characters 5 to 10 on line 17 with <code>foo</code>.” This is nice for editor integration, since Agda doesn’t assume anything about your editing environment.</p>
<p>Rather interestingly, Agda even does its <em>syntax</em> highlighting like this. You ask the compiler what colors things should have, and it responds. Editor plugins just need to attach that information to the buffer, and you never need to write another janky regex.</p>
<p>One of the first things I implemented in <code>cornelis</code> was this syntax highlighting. My first attempt looked something like this:</p>
<figure>
<img src="/images/underline/highlighting.png" alt="Syntax Highlighting" /><figcaption aria-hidden="true">Syntax Highlighting</figcaption>
</figure>
<p>It’s… <em>almost</em> right. But those deep yellows should extend to the end of each line! However, notice that each of the light yellows on the left of the <code>:</code>s are right. So whatever’s going wrong here is getting reset every line.</p>
<p>Looking closely at the subscript 1 on <code>f</code> gives us a clue what’s going wrong — unicode characters are throwing off the highlighting ranges! Some swearing and digging into the vim documentation shows that vim expects its highlighting ranges to be <em>byte-indexed</em> for some insane reason. Agda uses a lot of unicode, and (rightly) reports locations by their character-index, not their byte-index.</p>
<p>The solution was to get the text being highlighted, and count its actual bytes in order to fix the numbers being sent to vim. Annoying, but workable. I left a comment and went on with my day.</p>
<p>The next day, I was working on another feature, which is essentially interacting with typed-holes. The idea is you move your cursor over the hole, and then ask Agda to do something with it. But, sometimes, Agda would yell at me and say there was no hole there! Sure enough, that sometimes was when there was a unicode character earlier on the line. Same bug, same fix.</p>
<p>Then the day after that, another bug caused by this unicode length stuff. OK, three strikes and you’re out. It was time to fix this bug once and for all. Fundamentally, the issue is that Agda-offsets don’t agree with Vim-offsets, which sounds like a type error to me. It seemed hard to patch the vim API, but I controlled all of the Agda-serialization stuff, so I <a href="https://github.com/isovector/cornelis/commit/d52708164d9e1e34a3ef941235d1396bacc937f7">made a patch</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="va">+ data OffsetType = Line | File</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="va">+ newtype Offset (a :: OffsetType) = Offset Int32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="va">+   deriving stock Data</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="va">+   deriving newtype (Eq, Ord, Show, Read, FromJSON)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="va">+</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="va">+ type BufferOffset = Offset &#39;File</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="va">+ type LineOffset = Offset &#39;Line</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  data Position&#39; a = Pn</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    { srcFile :: !a</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="st">-   , posPos  :: !Int32</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="va">+   , posPos  :: !BufferOffset</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    , posLine :: !Int32</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="st">-   , posCol  :: !Int32</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="va">+   , posCol  :: !LineOffset</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>and then changed the types of the bug-fixing functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="st">- toBytes :: Text -&gt; Int -&gt; Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="va">+ toBytes :: Text -&gt; Offset a -&gt; Int</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="st">- fromBytes :: Text -&gt; Int -&gt; Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="va">+ fromBytes :: Text -&gt; Int -&gt; Offset a</span></span></code></pre></div>
<p>After doing some plumbing to change all the function types to refer to <code>BufferOffset</code> and <code>LineOffset</code> rather than <code>Int</code>, I was left with a few type errors in the program: <em>corresponding exactly with the bug I had set out to fix, and two others I didn’t know about!</em></p>
<figure>
<img src="/images/underline/underline.png" alt="Underlined Bugs" /><figcaption aria-hidden="true">Underlined Bugs</figcaption>
</figure>
<p>Let me restate that. The computer <em>underlined the bugs</em> in my program. It found bugs in code I’d already written.</p>
<p>If this isn’t one of the best arguments for static typing, I can’t imagine what would be.</p>
        ]]>
      </content>
    </entry>
</feed>

