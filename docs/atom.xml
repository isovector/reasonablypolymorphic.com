<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns='http://www.w3.org/2005/Atom' xmlns:g='http://base.google.com/ns/1.0'>
  <title>Reasonably Polymorphic</title>
  <updated>2023-08-23T21:00:00Z</updated>
  <author><name>Sandy Maguire</name></author>
  <id>https://reasonablypolymorphic.com</id>
  <link rel='self' href='https://reasonablypolymorphic.com/atom.xml'/>

    <entry>
      <title>Certainty by Construction Progress Report 8</title>
      <id>blog/cbc-report8/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report8/index.html'/>
      <published>2023-08-23</published>
      <updated>2023-08-23</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Eight days away from my deadline. How’s it going? Hectic.</p>
<p>I’ve been in a flurry of editing for the last two weeks. As of right now, I’m currently editing page 138/252. At this rate, it’s not looking promising, but I did just buy a flat of Red Bull, so you never know.</p>
<p>Besides editing, what’s new? Lots of minor typesetting stuff, like which paragraphs should be indented. I also did a pass through all the Agda modules with their new, final names, in easy searchable format. Along with that, the end of each chapter now has an explicit export list, which subsequent chapters import (rather than getting it from the stdlib.) This means you can see at a glance whether a chapter has prerequisites you need to read first! Minor stuff, but Nintendo polish nevertheless.</p>
<p>I had to rewrite a good chunk of chapter 2, and a lot of the prose in chapter 3 is from a very early edition of the book, and doesn’t have the shine as the rest of it. So that’s getting reworked too. My hope is that the later chapters were written more recently, and therefore will require less elbow grease. It’s plausible, and would be greatly appreciated. But I fear that the setoids chapter needs a lot of work, and I’m just trying my best to ignore it. For now.</p>
<p>In other news, I’m now uploading nightly builds to <a href="https://leanpub.com/certainty-by-construction">Leanpub</a> in order to keep myself honest. There’s no indication of which half of the book has been edited and which hasn’t, but that seems like a good idea I should adopt for the next build. That way particularly dedicated readers could follow along and see just how quickly I can get material cleaned up. And it will prevent me from accidentally forgetting where I was and re-editing it all again. Which has happened several times, somehow.</p>
<p>Okay that’s enough of an update. Back to the grind. Love y’all.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 7</title>
      <id>blog/cbc-report7/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report7/index.html'/>
      <published>2023-08-12</published>
      <updated>2023-08-12</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Where has this dingus Sandy been?? Busy busy busy! I’m in the middle of planning a wedding (my own), as well as just finished being the best man at my friend’s wedding. Plus getting the tax man’s records all sorted out for him, and a bunch of other things that fell into the “urgent” AND “important” categories.</p>
<p>Yeesh. Enough excuses though. I’m back and haven’t given up on any of this!</p>
<p>These days I’m calling the book “essentially done,” and all that is required is extensive editing. Which I’ve been doing. Every day on the bus I’m reading my PDF copy and making notes in the margin. Then I get home and go through the notes and clean up the prose.</p>
<p>It’s slow going, but that’s the way of the world. The prose is getting dramatically tightened up, however. It’s kind of fun to go through, be aware of the point I’m trying to make, and realize that I haven’t actually made it. I’m not calling this “rewriting,” but most paragraphs are changing dramatically.</p>
<p>Today I also sat down and hashed out a bunch of the technical pipeline issues I’ve been putting off for a year. Like getting section references working. So now instead of saying “as in <strong>sec:propeq?</strong>”, the prose now says “as in section 3.2”. The annotations have always been there, but getting the build to actually put in the text has taken away several hours of my life.</p>
<p>More excitingly, I also managed to get inline code snippets properly highlighted—and, even better, <em>broken code</em> now also highlights. This is a resounding achievement, because the whole idea of literate Agda is that it must compile. And the compiler is what generates the syntax highlighting. It’s a terrifying marvel of engineering, but it does work.</p>
<p>So that’s all. I’m just going to push on this book thing until it’s done. Or until September 1. Whichever comes sooner. That’s a terrifying thought, so I guess I’d better get back to it.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 6</title>
      <id>blog/cbc-report6/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report6/index.html'/>
      <published>2023-07-14</published>
      <updated>2023-07-14</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Aaaand we’re back. Traveling was nice, but it’s nicer to be home and being productive and making things.</p>
<p>This week I did a lot of work on the isomorphisms chapter. First and foremost, I proved that everything I knew about cardinalities from the Curry-Howard isomorphism held true. That is, that sum types add the cardinalities of their constituent types, product types multiply them, and by far the hardest to prove, that functions act as exponentials.</p>
<p>Going through the work of that taught me that I haven’t really internalized everything I ought to have regarding setoids, since I originally framed the problem wrong and needed Reed to help sort me out. There is some material in this chapter about building the relevant setoids for all of the necessary types, which sucks and would be better to avoid. I’m unsure if it will get moved out to the setoid chapter, or if I’ll just give a sketch in the final version, or maybe if it just gets left where it is.</p>
<p>For me, the motivating use case behind the algebra of types is to find different representations of things, ones with better computational properties. This turns out to be extremely easy to exploit in Haskell, but upon trying to write about it, I realized how much magic the Haskell runtime is doing in order to make that happen. It’s amazing that I’m still managing to trick myself into thinking I understand things, even after working on this book for nearly a year. But I suppose that’s the whole purpose!</p>
<p>So anyway, that section isn’t yet finished, but I think one more week will be enough to tie it together. And at that point, I’ve written everything I intend to, and will spend the remainder of my project time on editing, rewriting, cleaning up, and tackling the weird typesetting problems that remain. The end is nigh!</p>
<hr />
<p>That’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 5</title>
      <id>blog/cbc-report5/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report5/index.html'/>
      <published>2023-06-20</published>
      <updated>2023-06-20</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Reporting in a little early this week, since I’m going to be traveling for two weeks without my laptop starting tomorrow. That means the book isn’t going to get much work done on it until early July.</p>
<p>Nevertheless, I’ve been busy this week. I looked at a “real” book the other day, and was floored by how beautifully it was typeset. It inspired me to up my game and put a lot more energy into presentation. The results, in my opinion, are stunning. I redid the chapter headings. I changed the page headers. Painfully, I changed the margins too, which left the book 100 pages shorter than it used to be. Ouch! But what I’m most proud of is the new color scheme.</p>
<p>Let’s face it. The out-of-the-box color scheme for Agda is hard to love. It’s got ten seemingly-randomly-chosen colors, all smashed together. At first I tried a black and white color scheme, which looked great, but made the code hard to parse. So instead, I’ve settled on a trichomatic scheme based on the colors from <a href="https://c82.net/euclid/#books">Byrne’s Euclid</a>. It took a lot of tweaking to make everything work, but I’m really happy with how it’s turned out.</p>
<p>But presentation isn’t everything I did this week. No, I also rewrote everything I had on setoids, and have now motivated them by way of a section on monoids and their homomorphisms. This material is also a rewrite of the old janky monoid stuff, and it’s really come together. I’ve been trying to tie in a little more “and, as a programmer, why you should care” about some of these ideas.</p>
<p>Furthermore, there’s some rudimentary new material on finite numbers, characteristic functions and isomorphisms, with the eventual programming tie-in being automatic memoization of functions. This is a topic I thought I understood, but working through the formalization makes me realize I had fooled myself.</p>
<p>Anyway. I’m going to be gone for a few weeks, but I’ll pick right back up when I hit ground again. See you soon.</p>
<hr />
<p>That’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 4</title>
      <id>blog/cbc-report4/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report4/index.html'/>
      <published>2023-06-16</published>
      <updated>2023-06-16</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>I landed a two-week long gig three weeks ago, and that ate up my time for a little bit. But I’m back in action, significantly richer, and much more inspired to be working on Certainty by Construction again.</p>
<p>The end is finally in sight. This week I tore apart the modular arithmetic stuff from the material on setoids, realizing that the two were unrelated. I’d been having a lot of trouble getting that chapter sorted out, and it’s because it shouldn’t have been a chapter after all.</p>
<p>Instead, I’ve been working on merging the stuff about monoids and monoid homomorphisms into the setoid chapter, which is a much better motivation for setoids when you realize you can’t write many of the monoids you’d like to be able to. If I can fit lattices into there as well, I’ll be a very happy man.</p>
<p>Also this week I worked on some typesetting things. In particular, you’ll notice a gutter indicator on every code block telling you exactly where the code block should be indented relative to the file. This is a big improvement from before when you just had to guess, but I’m not yet <em>happy</em> with it. Please give it a read and let me know if you like the change, or what might be better.</p>
<p>Additionally I spent a <em>lot</em> of time making sure every code block had good vertical alignment of its code elements. That means all the equals signs should line up, and that the same argument is always in the same column, no matter how many patterns you’ve already matched. It’s not the sort of thing you’d notice, but it’s certainly the sort of thing whose <em>absence</em> you’d notice.</p>
<p>I’m committing to a hard deadline for this book of <em>September 1, 2023.</em> The thing is going to be finished and off to the printers by that day, because I want to have it done before I’m married, and that is coming up soon. And also, I work much better with a deadline.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 3</title>
      <id>blog/cbc-report3/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report3/index.html'/>
      <published>2023-05-25</published>
      <updated>2023-05-25</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Week three, and this update is coming in hot, a whole day early! This week I worked on the ring solving chapter, realizing that I can make a very much non-toy solver, and pack it into a chapter. We now build a multivariate semiring solver, discuss how and why it works, and then do some dependent-type shenanigans to put a delightful user interface in front of the whole thing.</p>
<p>In addition, it came with some excellent opportunities to discuss where semantics come from, and let me talk about homomorphisms earlier than I was otherwise hoping to.</p>
<p>My plan for the week was to tackle the remainder of the setoids chapter, but setoids are awful and it’s hard to motivate myself to do that, since I avoid using them in my day-to-day life whenever I can. Which is always. We’ll see what happens with this chapter, but maybe it’ll get melted down into something else. Nevertheless, understanding setoids <em>is</em> important for actually doing anything with the stdlib, so I dunno.</p>
<p>On the typesetting front, I spent an hour today fighting with Latex trying to ensure that it has glyphs for every unicode character in the book. I’ve got all but one of them sorted out now, and in the process, learned way more about Latex than any human should need to know.</p>
<p>The plan for next week is to cleanup the extremely WIP backmatter chapters. There’s a bunch of crap in there about me trying to do math math and failing, because math math doesn’t give two sniffs about constructability, and so none of it works out. If I’m feeling particularly plucky, I might try my hand at defining the reals, just because it might be fun.</p>
<p>As of today’s update, the book is now 360 pages long! I estimate it’ll be about 450 when it’s done, so we’re clearly making progress.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 2</title>
      <id>blog/cbc-report2/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report2/index.html'/>
      <published>2023-05-18</published>
      <updated>2023-05-18</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>It’s week two of regular updates on Certainty by Construction, baby! This week I made 17 commits to the repository, half of which were towards the goal of improving the book’s typesetting. Spurred on by a bug report asking “what the hell does <code>AgdaCmd:MakeCase</code> mean?” I decided to upgrade the book’s build system. Now you should see explicit keystrokes to press when the book asks you to run a command alongside.</p>
<p>You’ll also notice intra-prose syntax highlighting, meaning that if the book mentions a type, it will now be presented in a beautiful blue, among other things in other colors. Agda has some janky support for this, but I couldn’t get it working, which means I annotated each and every piece of syntax highlighting by hand. Please file a bug if you notice I’ve missed any.</p>
<p>Content-wise, the old chapter on “structured sets” has become “relations”, and it has several new sections fleshing out the idea and giving several more examples. I’m now in the middle of rewriting the setoids chapter, but it too has three new sections, and thus the whole thing is no longer <em>all</em> about modular arithmetic.</p>
<p>Next week I’m going to continue powering on with the setoids chapter—including a big digression on what congruence entails under a setoid—and then I think I’ll tackle the ring solving chapter.</p>
<p>For the first time, this book seems like I might not be working on it for the rest of my life. It’s nowhere near done, but the topic and style are finally hashed out, and the content is mostly in an alpha state. From here it’s really just to continue grinding, rewriting all the crap bits over and over again, until they’re no longer crap.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Certainty by Construction Progress Report 1</title>
      <id>blog/cbc-report1/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/cbc-report1/index.html'/>
      <published>2023-05-12</published>
      <updated>2023-05-12</updated>

      <content type="html">
        <![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>As part of a new ~quarterly goal, I’m going to be publishing updates to Certainty by Construction every Friday. This is for a few reasons: one, things get done much more quickly when you’re not doing them in private; two, relatedly, it’s good to get some exposure here and keep myself accountable.</p>
<p>Anyway, there are 26 new pages since last week, although a good deal of that is code without any prose around it yet. I’m in the process of cannibalizing the sections on relations and setoids into a single chapter. It’s a discussion of mathematical relations, their properties, an several examples. We explore different pre-orders, partial orders and total orders, and have a length digression about effectively designing indices for <code>data</code> types.</p>
<p>This last point arose from me spending a few hours trying to work out under which circumstances exactly Agda gets confused about whether or not a computing index will give rise to a constructor. My findings are that it’s not really about computing indices, so much as it is about Agda running out of variables in which it can pack constraints. I suspect this knowledge can be exploited to make more interesting constructors than I thought possible, but I haven’t worked out how to do it yet.</p>
<p>I’ve also been working on how to simplify some bigger setoid proofs, where you have a bunch of equational reasoning you’d like to do under congruence. The folklore on this is generally to introduce a lemma somewhere else, but this has always struck me as a disappointing solution. Modulo the concrete syntax, this seems to work pretty well:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>≈nested<span class="ot">_</span>[<span class="ot">_</span>]<span class="ot">_</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> A</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">{</span>f <span class="ot">:</span> A <span class="ot">→</span> A<span class="ot">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>cong <span class="ot">:</span> <span class="ot">{</span>x y <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> x ≈ y <span class="ot">→</span> f x ≈ f y<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">{</span>x y z <span class="ot">:</span> A<span class="ot">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> x IsRelatedTo y</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> f y IsRelatedTo z</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> f x IsRelatedTo z</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> ≈nested cong [ relTo x=y ] <span class="ot">(</span>relTo fy=z<span class="ot">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> relTo <span class="ot">(</span>trans <span class="ot">(</span>cong x=y<span class="ot">)</span> fy=z<span class="ot">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>≈nested<span class="ot">_</span>[<span class="ot">_</span>]<span class="ot">_</span></span></code></pre></div>
<p>which lets you focus in on a particular sub-expression, and use a new equational reasoning block to rewrite that, before popping your results back to the full expression. As an example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  ⌊ <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c +H d *S a ⌋ * x + b * d</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>≈nested <span class="ot">(</span>+-congʳ ∘ *-congʳ<span class="ot">)</span> [  <span class="co">-- focus on subexpr</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ⌊ <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c +H d *S a ⌋</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>≈⟨ +H-+-hom <span class="ot">(((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c<span class="ot">)</span> <span class="ot">(</span>d *S a<span class="ot">)</span> x ⟩</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  ⌊<span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c ⌋ + ⟦ d *S a ⌋</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>≈⟨ +-congʳ <span class="ot">(</span>+H-+-hom <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> <span class="ot">(</span>b *S c<span class="ot">)</span> x<span class="ot">)</span> ⟩</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  ⌊ a *H c ⌋ * x + 0# + ⌊ b *S c ⌋ + ⌊ d *S a ⌋</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>≈⟨ …via… *S-*-hom ⟩</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  ⌊ a *H c ⌋ * x + <span class="ot">(</span>b * ⌊ c ⌋<span class="ot">)</span> + <span class="ot">(</span>d * ⌊ a ⌋<span class="ot">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>≈⟨ +-congʳ <span class="ot">(</span>+-congʳ <span class="ot">(</span>*-congʳ <span class="ot">(</span>*H-*-hom a c x<span class="ot">)))</span> ⟩</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  ⌊ a ⌋ * ⌊ c ⌋ * x + b * ⌊ c ⌋ + d * ⌊ a ⌋</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>∎ ]                            <span class="co">-- pop back</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(</span>⌊ a ⌋ * ⌊ c ⌋ * x + b * ⌊ c ⌋ + d * ⌊ a ⌋<span class="ot">)</span> * x + <span class="ot">(</span>b * d<span class="ot">)</span></span></code></pre></div>
<p>The attentive reader here will notice that I have also clearly been improving the chapter on ring solving. Maybe I’m just better at proofs these days, but the whole thing feels much less challenging than my first few times looking at it.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>The Co-Blub Paradox</title>
      <id>blog/coblub/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/coblub/index.html'/>
      <published>2023-03-24</published>
      <updated>2023-03-24</updated>

      <content type="html">
        <![CDATA[
        <p>The following is an excerpt from <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>It is widely acknowledged that the languages you speak shape the thoughts you can think; while this is true for natural language, it is doubly so in the case of programming languages. And it’s not hard to see why; while humans have dedicated neural circuitry for natural language, it would be absurd to suggest there is dedicated neural circuitry for fiddling around with the semantics of pushing around arcane symbol abstractly encoded as electrical potentials over a conductive metal.</p>
<p>Because programming—and mathematics more generally—does not come easily to us humans, it can be hard to see the forest for the trees. We have no built-in intuition as to what should be possible, and thus, this intuition is built by observing the artifacts created by more established practitioners. In these more “artificial” of human endeavors, newcomers to the field are truly constructivists—their methods for practicing the art are shaped only by their previously-observed patterns. Because different programming languages support different features and idioms, the imaginable shape of what programming <em>is</em> must be shaped by the languages we understand.</p>
<p>In a famous essay, “<a href="http://www.paulgraham.com/avg.html">Beating the Averages</a>,” Paul Graham points out the so-called <em>Blub paradox.</em> This, Graham says, is the ordering of programming languages by powerfulness; a programmer who thinks in a middle-of-the-road language along this ordering (call it Blub) can identify less powerful languages, but not those which are more powerful. The idea rings true; one can arrange languages in power by the features they support, and subsequently check to see if a language supports all the features felt to be important. If it doesn’t, it must be less powerful. However, this technique doesn’t work to identify more powerful languages—at best, you will see that the compared language supports all the features you’re looking for, but you don’t know enough to ask for more.</p>
<p>More formally, we can describe the Blub paradox as a semi-decision procedure. That is, given an ordering over programming languages (here, by “power”,) we can determine whether a language is less than our comparison language, but not whether it is more than. We can determine when the answer is definitely “yes,” but, not when it is “no!”</p>
<p>Over two decades of climbing this lattice of powerful languages, I have come to understand a lesser-known corollary of the Blub paradox, coining it the <em>Co-Blub paradox</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This is the observation that knowledge of lesser languages is <em>actively harmful</em> in the context of a more powerful language. The hoops you unwittingly jumped through in Blub due to lacking feature X are <em>anti-patterns</em> in the presence of feature X. This is obviously true when stated abstractly, but insidious when one is in the middle of it.</p>
<p>Let’s look at a few examples over the ages, to help motivate the problem before we get into our introspection proper. In the beginning, people programmed directly in machine code. Not assembly, mind you, but in raw binary-encoded op-codes. They had a book somewhere showing them what bits needed to be set in order to cajole the machine into performing any given instruction. Presumably if this were your job, you’d come to memorize the bit patterns for common operations, and it wouldn’t be nearly as tedious as it seems today.</p>
<p>Then came assembly languages, which provided human-meaningful mnemonics to the computer’s opcodes. No longer did we need to encode a jump as <code>11111000110000001100</code> — now it was <code>jl 16</code>. Still mysterious, to be sure, but significant gains are realized in legibility. When encoded directly in machine code, programs were, for the most part, write-only. But assembly languages don’t come for free; first you need to write an assembler: a program that reads the mnemonics and outputs the raw machine code. If you were already proficient writing machine code directly, you can imagine the task of implementing an assembler to feel like make work—a tool to automate a problem you don’t have. In the context of the Co-Blub paradox, knowing the direct encodings of your opcodes is an anti-pattern when you have an assembly language, as it makes your contributes inscrutable among your peers.</p>
<p>Programming directly in assembly eventually hit its limits. Every computer had a different assembly language, which meant if you wanted to run the same program on a different computer you’d have to completely rewrite the whole thing; often needing to translate between extremely different concepts and limitations. Ignoring a lot of history, C came around with the big innovation that software should be portable between different computers: the same C program should work regardless of the underlying machine architecture. If you were an assembly programmer, you ran into the anti-pattern that while you could squeeze more performance and perform clever optimizations if you were aware of the underlying architecture, this fundamentally limited you <em>to that platform.</em></p>
<p>By virtue of being, in many ways, a unifying assembly language, C runs very close to what we think of as “the metal.” Although different computer architectures have minor differences in registers and ways of doing things, they are all extremely similar variations on a theme. They all expose storable memory indexed by a number, operations for performing basic logic and arithmetic tasks, and means of jumping around to what the computer should consider to be the next instruction. As a result, C exposes this abstraction of what a computer <em>is</em> to its programmers, who are thus required to think about mutable memory and about how to encode complicated objects as sequences of bytes in that memory. But then came Java, whose contribution to mainstream programming was to popularize the idea that memory is cheap and abundant, and thus OK to waste some in order to alleviate the headache of needing to track it all yourself. As a C programmer coming to Java, you must unlearn the idea that memory is sacred and scarce, that you can do a better job of keeping track of it than the compiler can, and, hardest of all, that it is an important thing to track in the first place.</p>
<p>There is a clear line of progression here; as we move up the lattice of powerful languages, we notice that more and more details of what we thought were integral parts of programming turn out to be not particularly relevant to the actual task at hand. However, the examples thus discussed are already known to the modern programmer. Let’s take a few steps further, into languages deemed esoteric in the present day. It’s easy to see and internalize examples from the past, but those staring us in the face are much more difficult to spot.</p>
<p>Compare Java then to Lisp, which—among many things—makes the argument that functions, and even <em>programs themselves,</em> are just as meaningful objects as are numbers and records. Where Java requires the executable pieces to be packaged up and moved around with explicit dependencies on the data it requires, Lisp just lets you write and pass around functions, which automatically carry around all the data they reference. Java has a <em>design pattern</em> for this called the “command pattern,” which requires much ado and ink to be spilled, while in Lisp it just works in a way that is hard to understand if you are used to thinking about computer programs as static sequences of instructions. Indeed, the command pattern is bloated and ultimately unnecessary in Lisp, and practitioners must first unlearn it before they can begin to see the beauty of Lisp.</p>
<p>Haskell takes a step further than Lisp, in that it restricts when and where side-effects are allowed to occur in a program. This sounds like heresy (and feels like it for the first six months of programming in Haskell) until you come to appreciate that <em>almost none</em> of a program needs to perform side-effects. As it happens, side-effects are the only salient observation of the computer’s execution model, and by restricting their use, Haskell frees its programmers from needing to think about how the computer will execute their code—promising only that it will. As a result, Haskell code looks much more like mathematics than it looks like a traditional computer program. Furthermore, by abstracting away the execution model, the runtime is free to parallelize and reorder code, often even eliding unnecessary execution altogether. The programmer who refuses to acknowledge this reality and insists on coding with side-effects pays a great price, both on the amount of code they need to write, in its long-term reusability, and, most importantly, in the correctness of their computations.</p>
<p>All of this brings us to Agda, which is as far as I’ve gotten along the power lattice of programming languages. While Agda looks a great deal like Haskell, its powerful typesystem allows us to articulate many invariants that are impossible to write down in other languages. It’s tempting to think about Agda as Haskell-but-with-better-types, but this is missing the point. Agda’s type system is so precise we can <em>prove</em> that our solutions are correct, which alleviates the need to actually <em>run</em> the subsequent programs. In essence, programming in Agda abstracts away the notion of execution entirely. Following our argument about co-Blub programmers, they will come to Agda with the anti-pattern that thinking their hard-earned, battle-proven programming techniques for wrangling runtime performance will come in handy. But this is not the case; most of the techniques we have learned and consider “computer science” are in fact <em>implementation ideas:</em> that is, specific realizations from infinite classes of solutions, chosen not for their simplicity or clarity, but for their <em>efficiency.</em></p>
<p>Thus, the process of learning Agda, in many ways, is learning to separate the beautiful aspects of problem solving from the multitude of clever hacks we have accumulated over the years. Much like the fish who is unable to recognize the ubiquitous water around him, as classically-trained programmers, it is nigh-impossible to differentiate the salient points from the implementation details until we find ourselves in a domain where they do not overlap. Indeed, in Agda, you will often feel the pain of having accidentally conflated the two, when your proofs end up being much more difficult than you feel they deserve. Despite the pain and the frustration, this is in fact a feature, and not a bug. It is a necessary struggle, akin to the type-checker informing you that your program is wrong. While it can be tempting to blame the tool, the real fault is in the workmanship.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Although precisely speaking, the name should be the co-(Blub paradox), as the corollary applies to the paradox as a whole, not only the Blub piece. Alas, such is an awkward construction in English, and thus we will not use it.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Abusing Constraints for Automatic Documentation</title>
      <id>blog/abusing-constraints/index.html</id>
      <link href='https://reasonablypolymorphic.com/blog/abusing-constraints/index.html'/>
      <published>2023-01-03</published>
      <updated>2023-01-03</updated>

      <content type="html">
        <![CDATA[
        <h2 id="constraints"><a href="#constraints" class="header-link">Constraints<span class="header-link-emoji">🔗</span></a></h2>
<p><a href="https://github.com/wireapp/wire-server/pull/2950">At work I was recently tasked with figuring out what API calls our program makes</a>, and more interestingly, which code-paths lead to those API calls. Determining this by hand is tedious and error-prone, and worse, doesn’t stay up to date with code changes. Instead, let’s see how we can use the type system to eliminate the pain.</p>
<p>The existing code was organized around a class <code>HasAPI</code> that looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">HasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasAPI</span> srv name <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> srv name</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  callAPI ::</span> <span class="dt">APICall</span> srv name</span></code></pre></div>
<p>Here, <code>HasAPI</code> is a type class with an associated type family <code>APICall</code> which gives the type for making the call. For example, there might be an instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  callAPI str <span class="ot">=</span> <span class="fu">pure</span> <span class="op">$</span> <span class="fu">fmap</span> <span class="fu">toUpper</span> str</span></code></pre></div>
<p>This is a silly example — the real codebase makes actual API calls — but it serves for demonstration.</p>
<p>Our goal is to document every codepath that makes any use of <code>callAPI</code>, in some sense, “infecting” every path with some marker of that fact. This is a common experience to Haskell programmers; in fact, <code>IO</code> has this same pattern of infectiousness. Whenever you make a function perform IO, every type in the callstack needs to document the fact it performs <code>IO</code>. This is the inspiration we will take, except that changing types is extremely expensive. What if we pushed a constraint around instead?</p>
<h3 id="propagating-constraints"><a href="#propagating-constraints" class="header-link">Propagating Constraints<span class="header-link-emoji">🔗</span></a></h3>
<p>The trick is to define a new class, of the same shape as <code>HasAPI</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">CallsAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CallsAPI</span> srv name</span></code></pre></div>
<p>but crucially, we give <code>CallsAPI</code> <em>no instances.</em> On first blush, this seems insane: why introduce a class with no methods and no instances? Having no methods means it can’t do anything useful. Having no instances means GHC can never eliminate the constraint, and thus must propagate it upwards. This is the infectiousness we want; any function which makes an API call must document that fact in its type — failure to do so will result in GHC failing to compile with the message <code>No instance for (CallsAPI srv name)</code>.</p>
<p>The trick now is to ensure that <code>callsAPI</code> produces a <code>CallsAPI</code> constraint. The easy way to do this is a little renaming to ensure existing polymorphic code continues work:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">UnsafeHasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">UnsafeHasAPI</span> srv name <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  unsafeCallAPI ::</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HasAPI</span> <span class="ot">=</span> (<span class="dt">UnsafeHasAPI</span> srv name, <span class="dt">CallsAPI</span> srv name)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>callAPI</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> srv name</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">.</span> <span class="dt">HasAPI</span> srv name</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>callAPI <span class="ot">=</span> unsafeCallAPI</span></code></pre></div>
<p>Any code written against the old <code>HasAPI</code> constraint will continue to work (modulo the instance definitions,) but concrete calls to <code>callAPI</code> now result in a dangling, unsatisfiable <code>CallsAPI</code> constraint. You’ll need to go through the codebase now, and document every transitive call to the API with matching <code>CallsAPI</code> constraints. Thankfully, HLS can help with this task: it will underline the missing cases, and suggest a code action that will automatically add these constraints to the type. Rinse and repeat, until every code path is documented.</p>
<p>Great success! We have automatically found every codepath that makes an API call, and forced them to document that fact. Better yet, we have solved the problem once and for all; our coworkers also must document any new API calls they make, lest their code not compile. It seems like we’re done!</p>
<p>Except for one fact: GHC will rudely refuse to compile our project, even if we correctly track all of our API calls. The problem of course, is that all we have managed to do is force <code>main</code> to collect every <code>CallsAPI</code> constraint. But GHC will still complain <code>No instance for (CallsAPI srv name)</code>. Of course, you could just give an orphan instance in the same module that defines <code>main</code>, which would work, but this doesn’t give you any sort of <em>external documentation.</em> It’s nice when you read the code, but it doesn’t help the business people.</p>
<h2 id="solving-the-unsolvable"><a href="#solving-the-unsolvable" class="header-link">Solving The Unsolvable<span class="header-link-emoji">🔗</span></a></h2>
<p>A better approach here is to selectively solve the <code>CallsAPI</code> constraints, which we can do with some Haskell dark magic. The <code>Dict</code> type captures a constraint, giving us a convenient way to manipulate constraints:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Dict</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dict</span> c <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Dict</span><span class="ot"> ::</span> c <span class="ot">=&gt;</span> <span class="dt">Dict</span> c</span></code></pre></div>
<p>We can write an eliminator to bring the <code>c</code> from a <code>Dict c</code> into scope, which, importantly, allows us to solve otherwise-unsolved constraints:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(\\)<span class="ot"> ::</span> (c <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Dict</span> c <span class="ot">-&gt;</span> r</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>f \\ <span class="dt">Dict</span> <span class="ot">=</span> f</span></code></pre></div>
<p>If we can get our hands on a <code>Dict (CallsAPI Srv Name)</code>, we can use <code>(\\)</code> to convince GHC to compile our program.</p>
<p>GHC is happy to give us dictionaries for constraints it knows about:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showIntDict ::</span> <span class="dt">Dict</span> (<span class="dt">Show</span> <span class="dt">Int</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>showIntDict <span class="ot">=</span> <span class="dt">Dict</span></span></code></pre></div>
<p>but unfortunately, refuses to give us dictionaries for unsolved constraints:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">callsAPIDict ::</span> <span class="kw">forall</span> srv name<span class="op">.</span> <span class="dt">Dict</span> (<span class="dt">CallsAPI</span> srv name)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>callsAPIDict <span class="ot">=</span> <span class="dt">Dict</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Error: No instance for (CallsAPI srv name)</span></span></code></pre></div>
<p>It seems like we’re just as stuck, but we have a trick up our sleeve. The first step is to define another class with an instance in scope. GHC will happily give us a dictionary for such a thing:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Trivial</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Trivial</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">trivialDict ::</span> <span class="dt">Dict</span> <span class="dt">Trivial</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>trivialDict <span class="ot">=</span> <span class="dt">Dict</span></span></code></pre></div>
<p>and now for something naughty:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">callsAPIDict ::</span> <span class="kw">forall</span> srv name<span class="op">.</span> <span class="dt">Dict</span> (<span class="dt">CallsAPI</span> srv name)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>callsAPIDict <span class="ot">=</span> unsafeCoerce trivialDict</span></code></pre></div>
<p>Behind the scenes, GHC compiles classes into records, instances into values of these records, and replaces wanted constraints with function arguments taking those records. By ensuring that <code>Trivial</code> and <code>CallsAPI</code> are both empty classes, with no methods or super-classes, we can be certain the generated records for these classes will be identical, and thus that it is OK to coerce one into the other.</p>
<p>Armed with <code>withDict</code> and <code>callsAPIDict</code>, we can play the part of the constraint solver and satisfy constraints ourself. GHC will happily compile the following example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ex ::</span> <span class="dt">HasAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ex <span class="ot">=</span> callAPI <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span> <span class="st">&quot;hello world&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Look ma, no HasAPI constraint!</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> ex \\ callsAPIDict <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span></span></code></pre></div>
<p>So that’s the rough technique. But how do we actually use it in anger?</p>
<h3 id="automatically-documenting-the-server"><a href="#automatically-documenting-the-server" class="header-link">Automatically Documenting the Server<span class="header-link-emoji">🔗</span></a></h3>
<p>Our actual use case at work is to add these API calls to our swagger documentation. Swagger is this automatically generated manifest of an API surface; we want to document the fact that some API calls might call other ones. Our server is one big servant application, and servant is extensible. So the real technique is to build a servant combinator that eliminates <code>HasAPI</code> constraints when you document them in the API definition.</p>
<p>Getting into the nitty gritty bits of servant is beyond the scope of this post, but we can sketch the idea. Servant APIs use the type-level <code>(:&gt;)</code> operator to combine information about an endpoint. For example, we might expose another service:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ServantAPI</span> <span class="ot">=</span> <span class="st">&quot;api&quot;</span> <span class="op">:&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;echo&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span></code></pre></div>
<p>This definition states that we have a REST server with a single route, <code>api/echo</code> which responds to <code>POST</code> requests, returning a JSON-encoded string, which takes a JSON-encoded string as the request body.</p>
<p>A servant server for <code>ServantAPI</code> would have type <code>Server ServantAPI</code>, where <code>Server</code> is a type family given by <code>HasServer</code>. Evaluating the type family results in <code>String -&gt; Handler String</code>, so in order to implement this server, we would need to provide a function of that type.</p>
<p>Let’s implement our server endpoint:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>echo</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">CallsAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">String</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>echo str <span class="ot">=</span> liftIO <span class="op">$</span> callAPI <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span> str</span></code></pre></div>
<p>Unfortunately, due to our earlier work, we can’t eliminate the <code>CallsAPI</code> constraint, and thus we can’t actually use <code>echo</code> as the handler for our endpoint.</p>
<p>It’s important to note that servant’s DSL is extensible, and we can add our own machinery here. The first step is to build a type that we can use in servant:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MakesAPICall</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MakesAPICall</span> srv name</span></code></pre></div>
<p>We can now build a second version of <code>ServantAPI</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ServantAPI</span> <span class="ot">=</span> <span class="st">&quot;api&quot;</span> <span class="op">:&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;echo&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">MakesAPICall</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span></code></pre></div>
<p>In order to actually run our endpoint, we need to give an instance of <code>HasServer</code> for our new <code>MakesAPICall</code> combinator:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasServer</span> api ctx</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) ctx</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) m <span class="ot">=</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Dict</span> (<span class="dt">CallsFed</span> srv name) <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api m</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  route _ ctx f <span class="ot">=</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    route (<span class="dt">Proxy</span> <span class="op">@</span>api) ctx <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">$</span> callsAPIDict <span class="op">@</span>srv <span class="op">@</span>name) f</span></code></pre></div>
<p>The <code>ServerT</code> instance here adds a <code>Dict (CallsFed srv name)</code> to the type of the handler required to satisfy this endpoint, while <code>route</code> automatically fills in the dictionary whenever the handler needs to be run. In an ideal world, we could give our <code>ServerT</code> instance as:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) m <span class="ot">=</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CallsFed</span> srv name <span class="ot">=&gt;</span> <span class="dt">ServerT</span> api m</span></code></pre></div>
<p>but GHC doesn’t let us use quantified types on the right-hand sides of type families, so this is unfortunately a no-go. Playing games with <code>Dict</code> instead is the best approach I’ve found here, but I’d love to hear if anyone has a better idea.</p>
<p>We still can’t use <code>echo</code> as a handler, but we can use <code>makesCall echo</code> as one, where <code>makesCall</code> is given as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">makesCall ::</span> (c <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Dict</span> c <span class="ot">-&gt;</span> r</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>makesCall <span class="ot">=</span> (\\)</span></code></pre></div>
<p>Servers that document their API calls via <code>MakesAPICall</code> and which wrap their handlers with <code>makesCall</code> can now eliminate <code>CallsFed</code> constraints. Since this is the only way of eliminating <code>CallsFed</code> constraints, we can be sure that every API call is correctly documented in the servant DSL!</p>
<p>The final step here is to add an instance of <code>HasSwagger (MakesAPICall srv name :&gt; api)</code>, but the details are gory and devoid of educational value. Suffice it to say that this instance was written, and now we have automatically generated JSON documentation describing which server endpoints make which other API calls. This documentation is guaranteed to be correct, because updating it is the only way to convince GHC to compile your code.</p>
        ]]>
      </content>
    </entry>
</feed>

