<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Some1 Like You</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="fonts.css" media="screen,projection"></link><link rel="stylesheet" href="presentation.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="150"><div class="step step-level-1" step="0" id="title" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<h1>Some1 Like You</h1>
<h2>Dependent Pairs in Haskell</h2>
<h3>A talk by <span>Sandy Maguire</span></h3>
<h4>reasonablypolymorphic.com</h4></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="slides-available">Slides available.</h1><pre>
<h3>reasonablypolymorphic.com/some1-like-you</h3>

</pre></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="an-almost-real-life-example">An (almost) real life example.</h1><p>We will make a simple data-ingestion platform for our life-tracking app.</p><p>The program will provide an API with a unique endpoint for each distinct type of data we can ingest.</p></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="survey-says-big-growth">Survey says: big growth!</h1><p>The marketing team says that by the end of the year, we'll have over 500 different "events" we'll want to be able to
ingest.</p></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="at-this-scale-any-boilerplate-is-bad-news">At this scale, <em>any</em> boilerplate is bad news.</h1><p>Boilerplate is boring to write and easy to get wrong.</p></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="a-first-attempt">A first attempt.</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Event</span> <span class="ow">=</span> <span class="kt">WakeUp</span>
           <span class="o">|</span> <span class="kt">Eat</span>     <span class="kt">Meal</span>
           <span class="o">|</span> <span class="kt">RockOut</span> <span class="kt">Song</span> <span class="kt">Duration</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="kr">instance</span> <span class="kt">FromJSON</span> <span class="kt">Event</span> <span class="kr">where</span>
  <span class="n">parseJSON</span> <span class="ow">=</span> <span class="n">parseWakeUp</span>
          <span class="o">&lt;|&gt;</span> <span class="n">parseEat</span>
          <span class="o">&lt;|&gt;</span> <span class="n">parseRockOut</span></pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="the-api">The API.</h1><pre class="highlight code haskell"><span class="kr">type</span> <span class="kt">Req</span>  <span class="ow">=</span> <span class="kt">ReqBody</span> <span class="kt">'[JSON]</span> <span class="kt">Value</span>
<span class="kr">type</span> <span class="kt">Resp</span> <span class="ow">=</span> <span class="kt">Post</span>    <span class="kt">'[JSON]</span> <span class="kt">Response</span>

<span class="kr">type</span> <span class="kt">EventAPI</span> <span class="ow">=</span>
  <span class="s">"api"</span> <span class="kt">:&gt;</span> <span class="s">"event"</span> <span class="kt">:&gt;</span>
             <span class="p">(</span> <span class="s">"wake-up"</span>  <span class="kt">:&gt;</span> <span class="kt">Req</span> <span class="kt">:&gt;</span> <span class="kt">Resp</span>
          <span class="kt">:&lt;|&gt;</span> <span class="s">"eat"</span>      <span class="kt">:&gt;</span> <span class="kt">Req</span> <span class="kt">:&gt;</span> <span class="kt">Resp</span>
          <span class="kt">:&lt;|&gt;</span> <span class="s">"rock-out"</span> <span class="kt">:&gt;</span> <span class="kt">Req</span> <span class="kt">:&gt;</span> <span class="kt">Resp</span>
             <span class="p">)</span></pre></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">importEvent</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">ExceptT</span> <span class="kt">ServantErr</span> <span class="kt">IO</span> <span class="kt">Response</span>
<span class="nf">importEvent</span> <span class="n">blob</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">fromJSON</span> <span class="n">blob</span> <span class="kr">of</span>
    <span class="kt">Error</span>   <span class="n">err</span> <span class="ow">-&gt;</span> <span class="n">throwM</span> <span class="n">err</span>
    <span class="kt">Success</span> <span class="n">ev</span>  <span class="ow">-&gt;</span> <span class="n">pure</span> <span class="o">$</span> <span class="kt">Response</span> <span class="n">ev</span></pre></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">wakeUp</span>  <span class="ow">=</span> <span class="n">importEvent</span>
<span class="nf">eat</span>     <span class="ow">=</span> <span class="n">importEvent</span>
<span class="nf">rockOut</span> <span class="ow">=</span> <span class="n">importEvent</span>

<span class="nf">eventServer</span> <span class="ow">::</span> <span class="kt">Server</span> <span class="kt">EventAPI</span>
<span class="nf">eventServer</span> <span class="ow">=</span> <span class="n">serve</span> <span class="o">$</span>
  <span class="n">wakeUp</span> <span class="kt">:&lt;|&gt;</span> <span class="n">eat</span> <span class="kt">:&lt;|&gt;</span> <span class="n">rockOut</span></pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><p>Notice how there is no type safety here.</p><p>Our <em>wake-up</em> endpoint will happily accept a <em>eat</em> payload.</p></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="we-can-do-better">We can do better!</h1><p>Separate the constructors of our sum type into their own types.</p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">PayloadWakeUp</span>  <span class="ow">=</span> <span class="kt">PayloadWakeUp</span>
<span class="kr">data</span> <span class="kt">PayloadEat</span>     <span class="ow">=</span> <span class="kt">PayloadEat</span>     <span class="kt">Meal</span>
<span class="kr">data</span> <span class="kt">PayloadRockOut</span> <span class="ow">=</span> <span class="kt">PayloadRockOut</span> <span class="kt">Song</span> <span class="kt">Duration</span>

<span class="kr">instance</span> <span class="kt">FromJSON</span> <span class="kt">PayloadWakeUp</span>
<span class="kr">instance</span> <span class="kt">FromJSON</span> <span class="kt">PayloadEat</span>
<span class="kr">instance</span> <span class="kt">FromJSON</span> <span class="kt">PayloadRockOut</span></pre></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><pre>
{-# LANGUAGE TemplateHaskell #-}

data Event = EventWakeUp  <span class="new">PayloadWakeUp</span>
           | EventEat     <span class="new">PayloadEat</span>
           | EventRockOut <span class="new">PayloadRockOut</span>

<span class="new">makePrisms ''Event</span>

</pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="optics-provide-type-safety">Optics provide type safety!</h1><p>We can use these prisms to lift our payload types into our Event type.</p></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><pre>
{-# LANGUAGE RankNTypes #-}

importEvent :: <span class="new">FromJSON e</span>
            <span class="new">=> Prism' Event e</span>
            -> Value
            -> ExceptT ServantErr IO Response
importEvent <span class="new">prism</span> blob =
  case fromJSON blob of
    Error   err -> throwM err
    Success e   -> pure . Response $ <span class="new">review prism</span> e

</pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="server-upgrades">Server upgrades.</h1><pre>
wakeUp  = importEvent <span class="new">_PayloadWakeUp</span>
eat     = importEvent <span class="new">_PayloadEat</span>
rockOut = importEvent <span class="new">_PayloadRockOut</span>

eventServer :: Server EventAPI
eventServer = serve $
  wakeUp :<|> eat :<|> rockOut

</pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="we-ve-gained-type-safety">We've gained type safety!</h1><p>The endpoints will no longer accept payloads of the wrong type.</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><p>The compiler doesn't know that our new payload types are related.</p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="id1">We can do better!</h1><p>Grouping our payload types together might provide opportunities for more clever tricks.</p></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="a-brief-interlude">A brief interlude.</h1><p>On data kinds and type families.</p></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><p>Data kinds lifts <em>values</em> to <strong>types</strong>, and <em>types</em> to <strong>kinds</strong>.</p></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="wat">Wat?</h1></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span>
          <span class="o">|</span> <span class="kt">False</span></pre><pre>

</pre><p>begets, via DataKinds:</p><pre class="highlight code haskell">

<span class="kc">kind</span> <span class="kind">Bool</span> where
  <span class="kc">type</span> '<span class="type">True</span>
  <span class="kc">type</span> '<span class="type">False</span>

</pre></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="type-families">Type families.</h1><p>A <strong>type family</strong> is a function that returns a type.</p></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="a-silly-thing">A silly thing.</h1><pre class="highlight code haskell"><span class="kr">type</span> <span class="kr">family</span> <span class="kt">NotInt</span> <span class="n">t</span> <span class="kr">where</span>
  <span class="kt">NotInt</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="nb">()</span>
  <span class="kt">NotInt</span> <span class="n">a</span>   <span class="ow">=</span> <span class="n">a</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">NotInt</span> <span class="kt">Bool</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="kt">True</span>

<span class="nf">bar</span> <span class="ow">::</span> <span class="kt">NotInt</span> <span class="kt">Int</span>
<span class="nf">bar</span> <span class="ow">=</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><p>Type families only exist at the type level.</p></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><p>We can write type families over DataKinds.</p></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="back-to-our-regularly-scheduled-talk">Back to our regularly scheduled talk.</h1></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="cm">{-# LANGUAGE DataKinds    #-}</span>
<span class="cm">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kr">data</span> <span class="kt">EventType</span> <span class="ow">=</span> <span class="kt">WakeUp</span> <span class="o">|</span> <span class="kt">Eat</span> <span class="o">|</span> <span class="kt">RockOut</span></pre><pre class="highlight code haskell">
<span class="kc">data family</span> <span class="kt">Payload</span> (<span class="type">e</span> :: <span class="kind">EventType</span>)

</pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><pre>
data <span class="new">instance</span> (<span class="new">Payload '<span class="type">WakeUp</span></span>) =
  PayloadWakeUp

data <span class="new">instance</span> (<span class="new">Payload '<span class="type">Eat</span></span>) =
  PayloadEat Meal

data <span class="new">instance</span> (<span class="new">Payload '<span class="type">RockOut</span></span>) =
  PayloadRockOut Song Duration

instance FromJSON (Payload '<span class="type">WakeUp</span>)
instance FromJSON (Payload '<span class="type">Eat</span>)
instance FromJSON (Payload '<span class="type">RockOut</span>)

</pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="data-types-for-free">Data types for free.</h1><p>Armed with this type family, we can get our old sum type for free.</p></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><pre class="highlight code haskell">
{-# LANGUAGE GADTs #-}

<span class="kc">data</span> <span class="kt">Event</span> <span class="kc">where</span>
  <span class="kt">MkEvent</span> :: <span class="kt">Payload</span> (<span class="type">et</span> :: <span class="kind">EventType</span>) -> <span class="kt">Event</span>

</pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><pre>
<span class="new">{-# LANGUAGE AllowAmbiguousTypes #-}</span>
<span class="new">{-# LANGUAGE KindSignatures      #-}</span>
<span class="new">{-# LANGUAGE ScopedTypeVariables #-}</span>

importEvent :: <span class="new">forall (<span class="type">et</span> :: <span class="kind">EventType</span>)</span>
             . FromJSON (Payload <span class="type">et</span>)
            => Value
            -> ExceptT ServantErr IO Response

importEvent blob =
  case fromJSON blob of
    Error err ->
      throwM err

    Success (e <span class="new">:: Payload <span class="type">et</span></span>) ->
      pure . Response $ <span class="new">MkEvent</span> e

</pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="make-it-compile-again">Make it compile again.</h1><pre>
<span class="new">{-# LANGUAGE TypeApplications #-}</span>

wakeUp  = importEvent <span class="new">@'<span class="type">WakeUp</span></span>
eat     = importEvent <span class="new">@'<span class="type">Eat</span></span>
rockOut = importEvent <span class="new">@'<span class="type">RockOut</span></span>

eventServer :: Server EventAPI
eventServer = serve $
  wakeUp :<|> eat :<|> rockOut

</pre></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><p>Notice that we've eliminated some boilerplate.</p><p>We no longer need to keep our Event type in sync with the payload types.</p></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="id2">We can do better!</h1><p>Generating the API definition automatically would remove a lot more boilerplate.</p><p>The EventType now exists at the value level.</p></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="we-might-have-a-chance">We might have a chance!</h1></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="api-changes">API changes.</h1><pre>
type Req  = ReqBody '[JSON] Value
type Resp = Post    '[JSON] Response

type EventAPI =
  "api" :>
    "event" :>
      <span class="new">Capture "event-type" EventType</span> :> Req :> Resp

</pre></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="too-clever-for-our-own-good">Too clever for our own good.</h1><pre>
importEvent :: <span class="new">EventType</span>
            -> Value
            -> ExceptT ServantErr IO Response

importEvent <span class="new">et</span> blob =
  case fromJSON blob of
    Error err ->
      throwM err

    Success (e :: Payload <span class="type">et</span>) ->
      pure . Response $ MkEvent e

</pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="it-doesn-t-work">It doesn't work.</h1><pre class="error">
No instance for (FromJSON (Payload <span class="type">et</span>))
  arising from a use of `fromJSON'
  </pre><p>Huh??</p></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="id3">A brief interlude.</h1><p>On singletons.</p></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="consider-unit">Consider Unit.</h1><pre class="highlight code haskell"><span class="nb">()</span> <span class="ow">::</span> <span class="nb">()</span></pre><p>If you know what value you have, you know its type, and vice-versa.</p></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><h1 id="singletons-generalize-this">Singletons generalize this.</h1><p>We'll introduce a new type for each value we'd like to move to the type level.</p></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="sounds-like-datakinds">Sounds like DataKinds!</h1><p>But it's not.</p><p>Unfortunately, not the same types as provided by DataKinds.</p></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><pre class="highlight code haskell">
{-# LANGUAGE PolyKinds  #-}
{-# LANGUAGE TypeInType #-}

<span class="kr">data family</span> <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">k</span>)

<span class="kr">class</span> <span class="kt">SingKind</span> <span class="kind">k</span> where
  fromSing :: <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">k</span>) -> k
  toSing   :: k -> <span class="kt">SomeSing</span> <span class="kind">k</span>

</pre></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><pre class="highlight code haskell">
<span class="kr">data instance</span> (<span class="kt">Sing</span> '<span class="type">True</span>)  = <span class="kt">STrue</span>
<span class="kr">data instance</span> (<span class="kt">Sing</span> '<span class="type">False</span>) = <span class="kt">SFalse</span>


<span class="kr">instance</span> <span class="kt">SingKind</span> <span class="kind">Bool</span> where
  fromSing s = <span class="kr">case</span> s <span class="kr">of</span>
    <span class="kt">STrue</span>  -> <span class="kt">True</span>
    <span class="kt">SFalse</span> -> <span class="kt">False</span>

  toSing b = <span class="kr">case</span> b <span class="kr">of</span>
    <span class="kt">True</span>  -> <span class="kt">SomeSing STrue</span>
    <span class="kt">False</span> -> <span class="kt">SomeSing SFalse</span>

</pre></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75200" data-y="0" data-z="0"><h1 id="it-doesn-t-have-to-be-so-bad">It doesn't have to be so bad!</h1><pre class="highlight code haskell"><span class="nf">singletons</span> <span class="p">[</span><span class="n">d</span><span class="o">|</span>
  <span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">True</span>
            <span class="o">|</span> <span class="kt">False</span>
  <span class="o">|</span><span class="p">]</span></pre></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="76800" data-y="0" data-z="0"><h1 id="not-just-for-bools">Not just for Bools!</h1><pre class="highlight code haskell"><span class="nf">singletons</span> <span class="p">[</span><span class="n">d</span><span class="o">|</span>
  <span class="kr">data</span> <span class="kt">EventType</span> <span class="ow">=</span> <span class="kt">WakeUp</span>
                 <span class="o">|</span> <span class="kt">Eat</span>
                 <span class="o">|</span> <span class="kt">RockOut</span>
  <span class="o">|</span><span class="p">]</span></pre></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="78400" data-y="0" data-z="0"><h1 id="a-helper-function">A helper function.</h1><pre class="highlight code haskell">
withSomeSing :: <span class="kt">SingKind</span> <span class="kind">k</span>
             => k
             -> (<span class="kc">forall</span> (<span class="type">a</span> :: <span class="kind">k</span>). <span class="kt">Sing</span> <span class="type">a</span> -> r)
             -> r

</pre></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80000" data-y="0" data-z="0"><h1 id="id4">Back to our regularly scheduled talk.</h1><p>Armed with this knowledge, we can lift our EventType value into the type system!</p></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="81600" data-y="0" data-z="0"><pre>
importEvent :: EventType
            -> Value
            -> ExceptT ServantErr IO Response

importEvent etype blob =
  <span class="new">withSomeSing etype $ \ (_ :: Sing <span class="type">et</span>) -></span>
    case fromJSON blob of
      Error err ->
        throwM err

      Success (e :: Payload <span class="type">et</span>) ->
        pure . Response $ MkEvent e

</pre></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="83200" data-y="0" data-z="0"><h1 id="it-still-doesn-t-work">It still doesn't work.</h1><pre class="error">
No instance for (FromJSON (Payload <span class="type">et</span>))
  arising from a use of `fromJSON'
  </pre><p>Huh?????????????</p><p>Didn't we fix this?</p></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="84800" data-y="0" data-z="0"><h1 id="stupid-compiler">Stupid compiler.</h1><p><em>We</em> know that FromJSON is total over Payload.</p><p>But how can we prove it?</p></div><div class="step step-level-1" step="54" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="86400" data-y="0" data-z="0"><h1 id="if-it-s-too-hard-prove-it-at-the-term-level">If it's too hard, prove it at the term level.</h1><pre class="highlight code haskell">
dictFromJSON :: ( <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">WakeUp</span>)
                , <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">Eat</span>)
                , <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">RockOut</span>)
                )
             => <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">EventType</span>)
             -> <span class="kt">Dict</span> (<span class="kt">FromJSON</span> (<span class="kt">Payload</span> <span class="type">a</span>))

</pre><p>A Dict c is a proof that we have the constraint c.</p></div><div class="step step-level-1" step="55" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="88000" data-y="0" data-z="0"><pre class="highlight code haskell">
dictFromJSON :: ( <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">WakeUp</span>)
                , <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">Eat</span>)
                , <span class="kt">FromJSON</span> (<span class="kt">Payload</span> '<span class="type">RockOut</span>)
                )
             => <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">EventType</span>)
             -> <span class="kt">Dict</span> (<span class="kt">FromJSON</span> (<span class="kt">Payload</span> <span class="type">a</span>))
dictFromJSON s = <span class="kc">case</span> s <span class="kc">of</span>
  <span class="kt">SWakeUp</span>  -> <span class="kt">Dict</span>
  <span class="kt">SEat</span>     -> <span class="kt">Dict</span>
  <span class="kt">SRockOut</span> -> <span class="kt">Dict</span>

</pre></div><div class="step step-level-1" step="56" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="89600" data-y="0" data-z="0"><pre>
importEvent :: EventType
            -> Value
            -> ExceptT ServantErr IO Response

importEvent etype blob =
  withSomeSing etype $ \ (<span class="new">setype</span> :: Sing <span class="type">et</span>) ->
    <span class="new">case dictFromJSON setype of</span>
      <span class="new">Dict -></span>
        case fromJSON blob of
          Error err ->
            throwM err

          Success (e :: Payload <span class="type">et</span>) ->
            pure . Response $ MkEvent e

</pre></div><div class="step step-level-1" step="57" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="91200" data-y="0" data-z="0"><h1 id="so-groovy">So groovy.</h1><pre>
eventServer :: Server EventAPI
eventServer = serve <span class="new">importEvent</span>

</pre></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="92800" data-y="0" data-z="0"><h1 id="compiler-driven-coding">Compiler driven coding.</h1><p>It is now impossible to incorrectly hook up a new EventType:</p><ul><li>Exhaustiveness checking of dictFromJSON ensures we made a new payload type and gave it a ToJSON instance.</li><li>The API definitions and server handlers write themselves.</li></ul></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="94400" data-y="0" data-z="0"><h1 id="the-other-half-of-the-problem">The other half of the problem.</h1><p>We also want to serialize these new events into a single pipe for downstream consumption.</p><p>For simplicitly we'll also use JSON going downstream.</p></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="96000" data-y="0" data-z="0"><h1 id="we-know-the-drill">We know the drill.</h1><pre class="highlight code haskell">
dictToJSON :: ( <span class="kt">ToJSON</span> (<span class="kt">Payload</span> '<span class="type">WakeUp</span>)
              , <span class="kt">ToJSON</span> (<span class="kt">Payload</span> '<span class="type">Eat</span>)
              , <span class="kt">ToJSON</span> (<span class="kt">Payload</span> '<span class="type">RockOut</span>)
              )
           => <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">EventType</span>)
           -> <span class="kt">Dict</span> (<span class="kt">ToJSON</span> (<span class="kt">Payload</span> <span class="type">a</span>))
dictToJSON s = <span class="kc">case</span> s <span class="kc">of</span>
  <span class="kt">SWakeUp</span>  -> <span class="kt">Dict</span>
  <span class="kt">SEat</span>     -> <span class="kt">Dict</span>
  <span class="kt">SRockOut</span> -> <span class="kt">Dict</span>

</pre></div><div class="step step-level-1" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="97600" data-y="0" data-z="0"><h1 id="id5">We can do better!</h1><p>Besides the constraints under consideration, dictToJSON is identical to dictFromJSON.</p></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="99200" data-y="0" data-z="0"><pre>
<span class="new">{-# LANGUAGE ConstraintKinds #-}</span>

dictPayload :: ( <span class="new">c</span> (Payload '<span class="type">WakeUp</span>)
               , <span class="new">c</span> (Payload '<span class="type">Eat</span>)
               , <span class="new">c</span> (Payload '<span class="type">RockOut</span>)
               )
            => Sing (<span class="type">a</span> :: <span class="kind">EventType</span>)
            -> Dict (<span class="new">c</span> (Payload <span class="type">a</span>))
dictPayload s = case s of
  SWakeUp  -> Dict
  SEat     -> Dict
  SRockOut -> Dict

</pre><p>We can now lift <em>any</em> constraint that is total over Payload.</p></div><div class="step step-level-1" step="63" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="100800" data-y="0" data-z="0"><p>Let's use it to implement ToJSON over Events.</p></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="102400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="kr">instance</span> <span class="kt">ToJSON</span> <span class="kt">Event</span> <span class="kr">where</span>
  <span class="n">toJSON</span> <span class="p">(</span><span class="kt">MkEvent</span> <span class="n">payload</span><span class="p">)</span> <span class="ow">=</span> <span class="n">toJSON</span> <span class="n">payload</span></pre></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="104000" data-y="0" data-z="0"><h1 id="id6">It doesn't work.</h1><pre class="error">
No instance for (ToJSON (Payload <span class="type">et</span>))
  arising from a use of `toJSON'
  </pre><p>Oh yeah. It doesn't lift automatically.</p></div><div class="step step-level-1" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="105600" data-y="0" data-z="0"><h1 id="we-need-a-singleton-to-get-the-dict">We need a singleton to get the Dict.</h1><p>But we don't have one.</p><p>But we used to!</p></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="107200" data-y="0" data-z="0"><h1 id="save-that-singleton">Save that singleton.</h1><pre>
data Event where
  MkEvent :: <span class="new">Sing (<span class="type">et</span> :: <span class="kind">EventType</span>)</span>
          -> Payload <span class="type">et</span>
          -> Event

</pre></div><div class="step step-level-1" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="108800" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="kr">instance</span> <span class="kt">ToJSON</span> <span class="kt">Event</span> <span class="kr">where</span>
  <span class="n">toJSON</span> <span class="p">(</span><span class="kt">MkEvent</span> <span class="n">setype</span> <span class="n">payload</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">dictPayload</span> <span class="o">@</span><span class="kt">ToJSON</span> <span class="n">setype</span> <span class="kr">of</span>
      <span class="kt">Dict</span> <span class="ow">-&gt;</span>
        <span class="n">object</span> <span class="p">[</span> <span class="s">"type"</span>    <span class="o">.=</span> <span class="n">fromSing</span> <span class="n">setype</span>
               <span class="p">,</span> <span class="s">"payload"</span> <span class="o">.=</span> <span class="n">payload</span>
               <span class="p">]</span></pre><p>We can write a similar FromJSON instance.</p></div><div class="step step-level-1" step="69" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="110400" data-y="0" data-z="0"><h1 id="we-re-done">We're done!</h1><p>But what can we take away?</p></div><div class="step step-level-1" step="70" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="112000" data-y="0" data-z="0"><h1 id="we-didn-t-invent-the-event-type">We didn't invent the Event type.</h1><p>In the literature, the combination of a value and a type that <em>depends</em> on that type is known as a <strong>dependent pair</strong>.</p></div><div class="step step-level-1" step="71" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="113600" data-y="0" data-z="0"><p>We can write the type of a dependent pair like this:</p><p>$$\sum_\text{a :: EventType} \text{Payload}(a)$$</p></div><div class="step step-level-1" step="72" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="115200" data-y="0" data-z="0"><h1 id="highschool-algebra">Highschool algebra.</h1><p>$$\sum_\text{a :: EventType} \text{Payload}(a) = \text{Payload}(a_1) + \text{Payload}(a_2) + \cdots + \text{Payload}(a_n)$$</p></div><div class="step step-level-1" step="73" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="116800" data-y="0" data-z="0"><h1 id="look-familiar">Look familiar?</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Event</span> <span class="ow">=</span> <span class="kt">EventWakeUp</span>  <span class="p">(</span><span class="kt">Payload</span> <span class="kt">WakeUp</span><span class="p">)</span>
           <span class="o">|</span> <span class="kt">EventEat</span>     <span class="p">(</span><span class="kt">Payload</span> <span class="kt">Eat</span><span class="p">)</span>
           <span class="o">|</span> <span class="kt">EventRockOut</span> <span class="p">(</span><span class="kt">Payload</span> <span class="kt">RockOut</span><span class="p">)</span></pre><p>This type is perfectly captured by the dependent pair.</p></div><div class="step step-level-1" step="74" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="118400" data-y="0" data-z="0"><h1 id="more-generally">More generally.</h1><p>$$(a, b) :: \sum_\text{a :: A} \text{F}(a)$$</p><p>We can encode this directly in Haskell.</p></div><div class="step step-level-1" step="75" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="120000" data-y="0" data-z="0"><h1 id="namesake-of-the-talk">Namesake of the talk.</h1><pre class="highlight code haskell">
<span class="kc">data</span> <span class="kt">Some1</span> (f :: <span class="kind">k</span> -> <span class="kind">Type</span>) <span class="kc">where</span>
  <span class="kt">Some1</span> :: <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">k</span>) -> f <span class="type">a</span> -> <span class="kt">Some1</span> f

</pre></div><div class="step step-level-1" step="76" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="121600" data-y="0" data-z="0"><h1 id="specializing">Specializing.</h1><pre>
type Event = <span class="new">Some1 Payload</span>

</pre></div><div class="step step-level-1" step="77" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="123200" data-y="0" data-z="0"><h1 id="but-that-s-not-all">But that's not all.</h1><p>We can generalize our dictPayload function as well:</p><pre class="highlight code haskell">
<span class="kc">class</span> <span class="kt">Dict1</span> (c :: <span class="kind">output</span> -> <span class="kind">Constraint</span>)
            (f :: <span class="kind">input</span>  -> <span class="kind">output</span>) <span class="kc">where</span>
  dict1 :: <span class="kt">Sing</span> (<span class="type">a</span> :: <span class="kind">input</span>) -> <span class="kt">Dict</span> (c (f a))

</pre></div><div class="step step-level-1" step="78" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="124800" data-y="0" data-z="0"><h1 id="it-comes-pre-assembled">It comes pre-assembled.</h1><p>All of this machinery has already been built for you!</p><p><a href="https://hackage.haskell.org/package/exinst">https://hackage.haskell.org/package/exinst</a></p><p>It also provides instances lifting Dict1 over Some1, as well as tons of other goodies.</p></div><div class="step step-level-1" step="79" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="126400" data-y="0" data-z="0"><h1 id="thanks-for-listening">Thanks for listening!</h1><h1 id="questions">Questions?</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>