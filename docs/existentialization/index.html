<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Existentialization</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="fonts.css" media="screen,projection"></link><link rel="stylesheet" href="presentation.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="150"><div class="step step-level-1" step="0" id="title" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<h1>Existentialization</h1>
<h2>What Is It Good For?</h2>
<h3>A talk by <span>Sandy Maguire</span></h3>
<h4>reasonablypolymorphic.com</h4></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="slides-available">Slides available.</h1><pre>
<h3>reasonablypolymorphic.com/existentialization</h3>

</pre></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="the-problem">The Problem</h1><ul><li>We would like to be able to automatically generate quickcheck properties for instances we write</li><li>eg. automatic proofs that every Monad instance is well behaved</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="but-first">BUT FIRST</h1></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="heterogeneous-lists">Heterogeneous Lists</h1><ul><li>Let's say we are Javascript programmers and we hate types</li><li>We want to make a list that can contain values of any type</li><li>Haskell doesn't let us do this:</li></ul><pre class="highlight code haskell"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>   <span class="c1">-- ok</span>
<span class="p">[</span><span class="kt">True</span><span class="p">]</span>    <span class="ow">::</span> <span class="p">[</span><span class="kt">Bool</span><span class="p">]</span>  <span class="c1">-- ok</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span> <span class="ow">::</span> <span class="o">??</span>      <span class="c1">-- type error, :(</span></pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="id1">Heterogeneous Lists</h1><ul><li>This is not all that useful, it turns out.</li><li>But even so, is Haskell such a shit language that we can't express such a thing?</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="no-we-can">No! We can!</h1></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="the-any-type">The Any Type</h1><p>Use a GADT.</p><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Any</span> <span class="kr">where</span>
  <span class="kt">Any</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Any</span></pre><p>We can think of Any as a container.</p><p>We can stuff whatever we want into it, and get back a value of type Any.</p></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="id2">The Any Type</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Any</span> <span class="kr">where</span>
  <span class="kt">Any</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Any</span>

<span class="kt">Any</span> <span class="kt">True</span>                    <span class="ow">::</span> <span class="kt">Any</span>
<span class="kt">Any</span> <span class="p">(</span><span class="n">show</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Any</span></pre><p>We've lost track of what type the value inside the Any had.</p><p>We say the a is now <em>existential</em>.</p><p>As in: we know it <em>exists</em>, but not much else about it.</p></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="rigid-skolems">RIGID SKOLEMS</h1><p>What happens if we try to take the value out of the Any?</p><pre class="highlight code haskell"><span class="nf">f</span> <span class="p">(</span><span class="kt">Any</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span></pre><p>Any guesses?</p></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="id3">RIGID SKOLEMS</h1><pre>
&#8226; Couldn't match expected type &#8216;t&#8217; with actual type &#8216;a&#8217;
  because type variable &#8216;a&#8217; would escape its scope
  This (rigid, skolem) type variable is bound by
    a pattern with constructor: Any :: forall a. a -> Any,

</pre><p>u wot m8</p></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="id4">RIGID SKOLEMS</h1><p>We can get some insight by looking at what type this thing would have.</p><pre class="highlight code haskell"><span class="nf">f</span> <span class="ow">::</span> <span class="kt">Any</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">Any</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="id5">RIGID SKOLEMS</h1><p>But recall that this is short form for:</p><pre class="highlight code haskell"><span class="nf">f</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Any</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">f</span> <span class="p">(</span><span class="kt">Any</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span></pre><p>ie. "I can give you back any a you want"</p></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="that-s-a-damn-lie">That's a damn lie</h1><p>There's a specific a inside the Any.</p><p>It might be a Bool or a String or whatever, but it is <em>not</em> "whatever you ask for".</p></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="too-rigid">Too Rigid</h1><p>You will run into this error all the time when you first start existentializing things.</p><p>So that's what this means:</p><ul><li>a (rigid, skolem) variable is a type that is existentially quantified</li><li>you can't leak it out because it doesn't even EXIST outside</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="anyways">Anyways</h1><p>This kind of solves our subproblem:</p><pre class="highlight code haskell"><span class="nf">listOfAnything</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Any</span><span class="p">]</span>
<span class="nf">listOfAnything</span> <span class="ow">=</span> <span class="p">[</span> <span class="kt">Any</span> <span class="mi">5</span>
                 <span class="p">,</span> <span class="kt">Any</span> <span class="kt">Bool</span>
                 <span class="p">,</span> <span class="kt">Any</span> <span class="p">(</span><span class="n">show</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">String</span><span class="p">)</span>
                 <span class="p">]</span></pre><p>But it's not actaully useful because we can never get any of this data out.</p></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="but-that-doesn-t-mean-the-technique-isn-t-useful">But that doesn't mean the technique isn't useful</h1></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="usefulness">Usefulness</h1><p>As you might guess, this doesn't mean we can't actually do anything useful with the technique.</p><p>Just that it requires <em>more thinking</em></p><p>Let's talk about iterators. Like in Python or whatever.</p></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="iterators">Iterators</h1><p>We want to be able to produce a series of values.</p><p>And maybe these values depend on some sort of state</p><p>We don't really care what that state is, so long as we can pull values out of it</p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="a-first-try">A first try</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Iterator</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Iterator</span>
  <span class="p">{</span> <span class="n">iterState</span> <span class="ow">::</span> <span class="n">s</span>
  <span class="p">,</span> <span class="n">iterNext</span>  <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">}</span></pre><p>This seems to do what we want.</p></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="but-it-s-kinda-gross">But it's kinda gross</h1><p>The state variable leaks.</p><p>That means you can't make a list of these things with different pieces of internal state, eg.</p></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="iterators-take-2">Iterators Take 2</h1><p>Let's existentialize it!</p><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Iterator</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Iterator</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">iterState</span> <span class="ow">::</span> <span class="n">s</span>
              <span class="p">,</span> <span class="n">iterNext</span>  <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
              <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Iterator</span> <span class="n">a</span></pre><p>The thing to notice here is that i don't care what the internal state is</p><p>It doesn't leak out of my type signature</p></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="pump-it-real-good">Pump It Real Good</h1><ul><li>We can implement a function that uses an Iterator to spit out a s</li></ul><pre class="highlight code haskell"><span class="nf">pump</span> <span class="ow">::</span> <span class="kt">Iterator</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Iterator</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">pump</span> <span class="n">iter</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">getNext</span> <span class="ow">=</span> <span class="n">iterNext</span> <span class="n">iter</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s'</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getNext</span> <span class="o">$</span> <span class="n">iterState</span> <span class="n">iter</span>
             <span class="kr">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Iterator</span> <span class="n">s'</span> <span class="n">getNext</span><span class="p">)</span></pre><p>This is kind of neat.</p></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="id6">Pump It Real Good</h1><pre class="highlight code haskell"><span class="nf">pump</span> <span class="ow">::</span> <span class="kt">Iterator</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Iterator</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">pump</span> <span class="n">iter</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">getNext</span> <span class="ow">=</span> <span class="n">iterNext</span> <span class="n">iter</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s'</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getNext</span> <span class="o">$</span> <span class="n">iterState</span> <span class="n">iter</span>
             <span class="kr">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">Iterator</span> <span class="n">s'</span> <span class="n">getNext</span><span class="p">)</span></pre><p>We can think of this as</p><pre class="highlight code haskell"><span class="p">(</span><span class="n">iterState</span><span class="p">,</span> <span class="n">iterNext</span><span class="p">)</span> <span class="ow">::</span> <span class="n">exists</span> <span class="n">s</span><span class="o">.</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span></pre><p>GHC doesn't know what this s type variable is, but it knows that iterState and iterNext are talking about the same
thing.</p></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="and-now-for-something-seemingly-completely-different">And now for something seemingly completely different.</h1></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="a-more-interesting-gadt">A More Interesting GADT</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Dict</span> <span class="p">(</span><span class="n">c</span> <span class="ow">::</span> <span class="kt">Constraint</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kt">Dict</span> <span class="ow">::</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">Dict</span> <span class="n">c</span></pre><p>Notice here that c exists in the type, and so it is not existential.</p><p>But this is not any old data type!</p></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="constructing-dicts">Constructing Dicts</h1><p>This says we can only construct a Dict c if c is an instance.</p><p>eg.</p><pre class="highlight code haskell"><span class="kt">Dict</span> <span class="ow">::</span> <span class="kt">Dict</span> <span class="p">(</span><span class="kt">Enum</span> <span class="kt">Bool</span><span class="p">)</span>        <span class="c1">-- ok</span>
<span class="kt">Dict</span> <span class="ow">::</span> <span class="kt">Dict</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Int</span><span class="p">)</span>         <span class="c1">-- ok</span>

<span class="kt">Dict</span> <span class="ow">::</span> <span class="kt">Dict</span> <span class="p">(</span><span class="kt">Eq</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">))</span>  <span class="c1">-- bad</span></pre><p>Haskell doesn't have equality defined for functions.</p></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="reified-constraints">Reified Constraints</h1><p>What value does this provide us?</p><p>It means we can pass constraints along as values -- they're now refied at the value level.</p><pre class="highlight code haskell"><span class="nf">maybeShow</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Dict</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">maybeShow</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">Dict</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">a</span>
<span class="nf">maybeShow</span> <span class="kr">_</span> <span class="kt">Nothing</span>     <span class="ow">=</span> <span class="s">"i don't know how to show that"</span>


<span class="nf">maybeShow</span> <span class="kt">True</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">Dict</span><span class="p">)</span>  <span class="c1">-- "True"</span>
<span class="nf">maybeShow</span> <span class="n">flip</span> <span class="kt">Nothing</span>      <span class="c1">-- "i don't know how to show that"</span></pre></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="generalizing">Generalizing</h1><p>We can use the same technique to make a more useful any-list</p><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Showable</span> <span class="kr">where</span>
  <span class="kt">Showable</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Showable</span>

<span class="nf">showList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Showable</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">showList</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">&#x3BB;</span><span class="p">(</span><span class="kt">Showable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">a</span><span class="p">)</span>

<span class="c1">-------------------------------------</span>

<span class="nf">myList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Showable</span><span class="p">]</span>
<span class="nf">myList</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Showable</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">Showable</span> <span class="kt">Bool</span><span class="p">,</span> <span class="kt">Showable</span> <span class="s">"hello"</span><span class="p">]</span>

<span class="nf">showList</span> <span class="n">myList</span>  <span class="c1">-- [1, Bool, "\"hello\""]</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="a-counter-example">A Counter Example</h1><p>Something we <em>can't</em> do:</p><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Equatable</span> <span class="kr">where</span>
  <span class="kt">Equatable</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Equatable</span>

<span class="nf">equate</span> <span class="ow">::</span> <span class="kt">Equatable</span> <span class="ow">-&gt;</span> <span class="kt">Equatable</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">equate</span> <span class="p">(</span><span class="kt">Equatable</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Equatable</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="id7">A Counter Example</h1><p>This doesn't work, because it's morally equivalent to this:</p><pre class="highlight code haskell"><span class="nf">equate</span> <span class="ow">::</span> <span class="n">exists</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">equate</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span></pre><p>We don't know that a and b have the same type!</p></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="eliminators">Eliminators</h1><p>In general, the strategy for doing useful things with existential variables is to introduce <strong>eliminators</strong> for them.</p><p>If we want to do something useful with a value of unknown type, we're going to need to provide a function that can do
something FOR ALL types.</p></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="id8">Eliminators</h1><p>The general form of it is this:</p><pre class="highlight code haskell"><span class="nf">eliminate</span> <span class="ow">::</span> <span class="kt">SomeExistential</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span></pre><p>If you give us an existential, and a way of constructing an r for any type I throw at you, then I can give you back an
r.</p><p>wat?</p></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="id9">Eliminators</h1><p>A dumb example:</p><pre class="highlight code haskell"><span class="nf">eliminate</span> <span class="n">myExistential</span> <span class="p">(</span><span class="n">const</span> <span class="kt">True</span><span class="p">)</span>   <span class="c1">-- True</span></pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="id10">Eliminators</h1><pre class="highlight code haskell"><span class="nf">eliminate</span> <span class="ow">::</span> <span class="kt">SomeExistential</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">r</span></pre><p>The forall a. a bit should be replaced with the definition of the existential.</p></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="id11">Eliminators</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Showable</span> <span class="kr">where</span>
  <span class="kt">Showable</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Showable</span>


<span class="nf">eliminateShowable</span> <span class="ow">::</span> <span class="kt">Showable</span>
                  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span>
                  <span class="ow">-&gt;</span> <span class="n">r</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="id12">Eliminators</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Iterator</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Iterator</span> <span class="ow">::</span> <span class="p">{</span> <span class="n">iterState</span> <span class="ow">::</span> <span class="n">s</span>
              <span class="p">,</span> <span class="n">iterNext</span>  <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
              <span class="p">}</span> <span class="ow">-&gt;</span> <span class="kt">Iterator</span> <span class="n">a</span>


<span class="nf">eliminateIterator</span> <span class="ow">::</span> <span class="kt">Iterator</span> <span class="n">a</span>
                  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">s</span><span class="o">.</span> <span class="n">s</span>
                            <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                            <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span>
                  <span class="ow">-&gt;</span> <span class="n">r</span></pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="eliminate-the-lack-of-intuition">Eliminate the Lack of Intuition</h1><p>The idea is that if can produce some r (that i get to choose) from whatever contents are inside the existential</p><p>Then I can produce an r given some existential value!</p></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="a-server">A Server</h1><p>Let's say I want to run a server that will respond to different endpoints.</p><p>But each endpoint will take and return different payload types.</p></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><h1 id="id13">A Server</h1><pre class="highlight code haskell"><span class="kr">class</span> <span class="kt">Encodable</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">encode</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span>
  <span class="n">decode</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">Encodable</span> <span class="kt">Bool</span>
<span class="kr">instance</span> <span class="kt">Encodable</span> <span class="kt">Int</span>
<span class="kr">instance</span> <span class="kt">Encodable</span> <span class="kt">String</span>
<span class="c1">-- etc</span></pre></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="id14">A Server</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">SomeHandler</span> <span class="kr">where</span>
  <span class="kt">SomeHandler</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Encodable</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Encodable</span> <span class="n">b</span><span class="p">)</span>
              <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span><span class="p">)</span>
              <span class="ow">-&gt;</span> <span class="kt">SomeHandler</span></pre></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><h1 id="id15">A Server</h1><pre class="highlight code haskell"><span class="nf">recv</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Endpoint</span><span class="p">,</span> <span class="kt">ByteString</span><span class="p">)</span>
<span class="nf">send</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">ByteString</span>


<span class="nf">serve</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Endpoint</span><span class="p">,</span> <span class="kt">SomeHandler</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">serve</span> <span class="n">handlers</span> <span class="ow">=</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">recv</span>

  <span class="kr">case</span> <span class="n">lookup</span> <span class="n">endpoint</span> <span class="n">handlers</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"no handler!"</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="kt">SomeHandler</span> <span class="n">handler</span><span class="p">)</span> <span class="ow">-&gt;</span>
      <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">handler</span> <span class="o">$</span> <span class="n">decode</span> <span class="n">payload</span>
      <span class="n">send</span> <span class="o">$</span> <span class="n">encode</span> <span class="n">result</span></pre></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="thanks-for-listening">Thanks for listening!</h1><p>Any questions?</p></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>