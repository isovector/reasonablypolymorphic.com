<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Don't Eff It Up</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="fonts.css" media="screen,projection"></link><link rel="stylesheet" href="presentation.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="150"><div class="step step-level-1" step="0" id="title" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1>Don't Eff It Up</h1>
<h2>Freer Monads in Action</h2>
<h3>A talk by <span>Sandy Maguire</span></h3>
<h4>reasonablypolymorphic.com</h4></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="a-dumb-example">A dumb example.</h1><p>We will make a (very) simple banking app.</p><ul><li>It will attempt to withdraw funds</li><li>Logs a message if it fails</li><li>Updates the current balance if it succeeds</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="types-first">Types first!</h1><pre class="highlight code haskell"><span class="nf">withdraw</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">MonadIO</span>     <span class="n">m</span>
            <span class="p">,</span> <span class="kt">MonadLogger</span> <span class="n">m</span>
            <span class="p">)</span>
         <span class="ow">=&gt;</span> <span class="kt">Int</span>
         <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span></pre></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">withdraw</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">MonadIO</span>     <span class="n">m</span>
            <span class="p">,</span> <span class="kt">MonadLogger</span> <span class="n">m</span>
            <span class="p">)</span>
         <span class="ow">=&gt;</span> <span class="kt">Int</span>
         <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span>

<span class="nf">withdraw</span> <span class="n">desired</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">amount</span> <span class="ow">&lt;-</span> <span class="n">getCurrentBalance</span>
  <span class="kr">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="n">desired</span>
     <span class="kr">then</span> <span class="kr">do</span>
       <span class="n">log</span> <span class="s">"not enough funds"</span>
       <span class="n">return</span> <span class="kt">Nothing</span>

     <span class="kr">else</span> <span class="kr">do</span>
       <span class="n">putCurrentBalance</span> <span class="o">$</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">desired</span>
       <span class="n">return</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">amount</span></pre></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="but-how-can-we-test-it">But how can we test it?</h1></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><p>A new datatype describing if we're running for real:</p><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Mode</span> <span class="ow">=</span> <span class="kt">ForReal</span>
          <span class="o">|</span> <span class="kt">Test</span> <span class="p">(</span><span class="kt">IORef</span> <span class="kt">Int</span><span class="p">)</span></pre></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><pre>
withdraw :: ( MonadIO     m
            , MonadLogger m
            )
         => <span class="new">Mode</span>
         -> Int
         -> m (Maybe Int)

withdraw mode desired = do
  amount <- <span class="new">case mode of
              ForReal    -> </span>getCurrentBalance<span class="new">
              Test ioref -> liftIO $ readIORef ioref</span>
  if amount < desired
     then do
       log "not enough funds"
       return Nothing

     else do
       <span class="new">let putAction =
             case mode of
               ForReal    -> </span>putCurrentBalance<span class="new">
               Test ioref -> liftIO . writeIORef ioref</span>
       putAction $ amount - desired
       return $ Just amount
</pre></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="this-sucks">This sucks!</h1><ul><li>IO is directly exposed</li><li>Test code is interspersed with our real logic</li><li>No compiler guarantees that we mocked <em>all</em> of our IO</li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="wouldn-t-it-be-nice">Wouldn't it be nice...</h1><p>... if we could just write the program that we cared about?</p></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="polymorphism-to-the-rescue">Polymorphism to the rescue!</h1><pre class="highlight code haskell"><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBank</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">getCurrentBalance</span> <span class="ow">::</span> <span class="n">m</span> <span class="kt">Int</span>
  <span class="n">putCurrentBalance</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="the-code-we-want-to-write">The code we want to write.</h1><pre>
withdraw :: ( <span class="new">MonadBank</span>   m
            , MonadLogger m
            )
         => Int
         -> m (Maybe Int)

withdraw desired = do
  amount <- <span class="new">getCurrentBalance</span>
  if amount < desired
     then do
       log "not enough funds"
       return Nothing

     else do
       <span class="new">putCurrentBalance</span> $ amount - desired
       return $ Just amount
</pre></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><p>By adding this new constraint, we can abstract over IO.</p><p>Our application and test code can swap out different monads.</p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="all-is-right-in-the-world">All is right in the world.</h1><p>Or is it?</p><p>This abstraction comes with a heavy cost.</p></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="we-need-a-carrier">We need a carrier...</h1><pre class="highlight code haskell"><span class="kr">newtype</span> <span class="kt">IOBankT</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">IOBankT</span>
  <span class="p">{</span> <span class="n">runIOBankT</span> <span class="ow">::</span> <span class="kt">IdentityT</span> <span class="n">m</span> <span class="n">a</span>
  <span class="p">}</span></pre></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="one-that-behaves-with-mtl">one that behaves with MTL...</h1><pre class="highlight code haskell"><span class="cm">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>

  <span class="kr">deriving</span> <span class="p">(</span> <span class="kt">Functor</span>
           <span class="p">,</span> <span class="kt">Applicative</span>
           <span class="p">,</span> <span class="kt">Monad</span>
           <span class="p">,</span> <span class="kt">MonadError</span> <span class="n">e</span>
           <span class="p">,</span> <span class="kt">MonadIO</span>
           <span class="p">,</span> <span class="kt">MonadRWS</span> <span class="n">r</span> <span class="n">w</span> <span class="n">s</span>
           <span class="p">,</span> <span class="kt">MonadReader</span> <span class="n">r</span>
           <span class="p">,</span> <span class="kt">MonadState</span> <span class="n">s</span>
           <span class="p">,</span> <span class="kt">MonadTrans</span>
           <span class="p">,</span> <span class="kt">MonadWriter</span> <span class="n">w</span>
           <span class="p">,</span> <span class="o">...</span>
           <span class="p">)</span></pre></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="which-implements-our-monad">which implements our monad...</h1><pre class="highlight code haskell"><span class="kr">instance</span> <span class="kt">MonadIO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBank</span> <span class="p">(</span><span class="kt">IOBankT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">getCurrentBalance</span> <span class="ow">=</span> <span class="o">...</span>
  <span class="n">putCurrentBalance</span> <span class="ow">=</span> <span class="o">...</span></pre></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="and-doesn-t-need-to-be-at-the-top-of-the-stack">and doesn't need to be at the top of the stack...</h1><pre class="highlight code haskell"><span class="kr">instance</span> <span class="kt">MonadBank</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBank</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">getCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">getCurrentBalance</span>
  <span class="n">putCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">getCurrentBalance</span>

<span class="kr">instance</span> <span class="kt">MonadBank</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBank</span> <span class="p">(</span><span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">getCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">getCurrentBalance</span>
  <span class="n">putCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">getCurrentBalance</span>

<span class="kr">instance</span> <span class="kt">MonadBank</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadBank</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">getCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">getCurrentBalance</span>
  <span class="n">putCurrentBalance</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">getCurrentBalance</span>

<span class="c1">-- so many more</span></pre></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 style="text-align: center; font-size: 48pt;"><span class="cursive">Nobody</span> has time for this crap.</h1></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="things-that-take-a-lot-of-work-don-t-get-done">Things that take a lot of work don't get done.</h1><p>Even if they're best practices.</p><p>Boilerplate gets in the way.</p></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="monad-transformers-are-a-hack">Monad transformers are a hack.</h1><p>Everything else we use in Haskell composes.</p><p>Why don't monads?</p></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="there-s-a-better-way">There's a better way.</h1></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="free-monads">Free monads.</h1><p>Monadic programs expressed as data structures we can manipulate.</p><p>Provided by the freer-effects package.</p></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 class="cursive">
Write it now; decide what it means later.
</h1></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="eff-to-the-rescue">Eff to the Rescue!</h1><pre>
withdraw :: ( <span class="new">Member Bank   r</span>
            , <span class="new">Member Logger r</span>
            )
         => Int
         -> <span class="new">Eff r</span> (Maybe Int)

withdraw desired = do
  amount <- getCurrentBalance
  if amount < desired
     then do
       log "not enough funds"
       return Nothing

     else do
       putCurrentBalance $ amount - desired
       return $ Just amount
</pre></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="small-change-big-impact">Small change. Big impact.</h1><pre class="highlight code haskell"><span class="nf">withdraw</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">MonadBank</span>   <span class="n">m</span>
            <span class="p">,</span> <span class="kt">MonadLogger</span> <span class="n">m</span>
            <span class="p">)</span>
         <span class="ow">=&gt;</span> <span class="kt">Int</span>
         <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span></pre><div class="bigass down">&#10144;</div><pre class="highlight code haskell"><span class="nf">withdraw</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">Member</span> <span class="kt">Bank</span>   <span class="n">r</span>
            <span class="p">,</span> <span class="kt">Member</span> <span class="kt">Logger</span> <span class="n">r</span>
            <span class="p">)</span>
         <span class="ow">=&gt;</span> <span class="kt">Int</span>
         <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span></pre></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="listen-to-the-types">Listen to the types.</h1></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="an-unambiguous-monad">An unambiguous monad.</h1><pre>
withdraw :: ( Member Bank   r
            , Member Logger r
            )
         => Int
         -> <span class="new">Eff r</span> (Maybe Int)
</pre></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="no-nominal-typing">No nominal typing.</h1><pre>
withdraw :: ( <span class="new">Member Bank   r</span>
            , Member Logger r
            )
         => Int
         -> Eff r (Maybe Int)
</pre></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="effects-as-data">Effects as data.</h1><pre class="highlight code haskell"><span class="cm">{-# LANGUAGE GADTs #-}</span>

<span class="kr">data</span> <span class="kt">Bank</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">GetCurrentBalance</span> <span class="ow">::</span> <span class="kt">Bank</span> <span class="kt">Int</span>
  <span class="kt">PutCurrentBalance</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bank</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">getCurrentBalance</span> <span class="ow">::</span> <span class="kt">Member</span> <span class="kt">Bank</span> <span class="n">r</span>
                  <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="kt">Int</span>
<span class="nf">getCurrentBalance</span> <span class="ow">=</span> <span class="n">send</span> <span class="kt">GetCurrentBalance</span></pre></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">putCurrentBalance</span> <span class="ow">::</span> <span class="kt">Member</span> <span class="kt">Bank</span> <span class="n">r</span>
                  <span class="ow">=&gt;</span> <span class="kt">Int</span>
                  <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="nb">()</span>
<span class="nf">putCurrentBalance</span> <span class="n">amount</span> <span class="ow">=</span> <span class="n">send</span> <span class="o">$</span> <span class="kt">PutCurrentBalance</span> <span class="n">amount</span></pre></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="still-too-much-boilerplate">Still too much boilerplate?</h1><pre class="highlight code haskell"><span class="cm">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kr">data</span> <span class="kt">Bank</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">GetCurrentBalance</span> <span class="ow">::</span> <span class="kt">Bank</span> <span class="kt">Int</span>
  <span class="kt">PutCurrentBalance</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bank</span> <span class="nb">()</span>

<span class="nf">makeFreer</span> <span class="kt">''Bank</span></pre></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="don-t-forget-the-lumberjack">Don't forget the lumberjack.</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Logger</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Log</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="nb">()</span>

<span class="nf">makeFreer</span> <span class="kt">''Logger</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="what-s-left">What's left?</h1><pre>
withdraw :: ( Member Bank   r
            , Member Logger r
            )
         => Int
         -> Eff <span class="new">r</span> (Maybe Int)
</pre></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="the-repl-can-help">The REPL can help.</h1><pre class="highlight code haskell"><span class="o">&gt;</span> <span class="kt">:</span><span class="n">kind</span> <span class="kt">Eff</span>

<span class="kt">Eff</span> <span class="ow">::</span> <span class="p">[</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span></pre></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="an-exact-correspondence">An exact correspondence.</h1><pre class="highlight code haskell"><span class="kt">StateT</span> <span class="n">s</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="kt">IO</span><span class="p">)</span> <span class="n">a</span></pre><div class="bigass down">&#11020;</div><pre class="highlight code haskell"><span class="kt">Eff</span> <span class="kt">'[State s, Reader r, IO]</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="so-what">So what?</h1><p>main runs in IO -- not in Eff.</p></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><p>We have one special function:</p><pre class="highlight code haskell"><span class="nf">runM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="kt">'[m]</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="not-just-for-monads">Not just for monads!</h1><pre class="highlight code haskell"><span class="nf">run</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="kt">'[]</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><p>run and runM provide base cases.</p></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><h1 id="induction">Induction.</h1><p>We want a function that looks like this:</p><pre class="highlight code haskell"><span class="nf">runLogger</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Logger</span> <span class="sc">'</span><span class="err">: r) a</span>
          <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span></pre><p>It "peels" a Logger off of our eff stack.</p></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><p>What does it mean to run a Logger?</p><p>Maybe we want to log those messages to stdout.</p><pre>
runLogger :: <span class="new">Member IO r</span>
          => Eff (Logger ': r) a
          -> Eff r a
</pre></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><h1 id="all-for-naught">All for naught?</h1><h2 id="no">No!</h2><p>Even though we have IO here, it's not the program that requires it; only the
intepretation.</p></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">runLogger</span> <span class="ow">::</span> <span class="kt">Member</span> <span class="kt">IO</span> <span class="n">r</span>
          <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Logger</span> <span class="sc">'</span><span class="err">: r) a</span>
          <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>

<span class="nf">runLogger</span> <span class="ow">=</span> <span class="n">runNat</span> <span class="n">logger2io</span>
  <span class="kr">where</span>
    <span class="n">logger2io</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">x</span>
    <span class="n">logger2io</span> <span class="p">(</span><span class="kt">Log</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="n">s</span></pre></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="we-can-do-the-same-thing-for-bank">We can do the same thing for Bank.</h1></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">runBank</span> <span class="ow">::</span> <span class="kt">Member</span> <span class="kt">IO</span> <span class="n">r</span>
        <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Bank</span> <span class="sc">'</span><span class="err">: r) a</span>
        <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>

<span class="nf">runBank</span> <span class="ow">=</span> <span class="n">runNat</span> <span class="n">bank2io</span>
  <span class="kr">where</span>
    <span class="n">bank2io</span> <span class="ow">::</span> <span class="kt">Bank</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">x</span>
    <span class="n">bank2io</span> <span class="kt">GetCurrentBalance</span>            <span class="ow">=</span>  <span class="c1">-- use IO to return an Int</span>
    <span class="n">bank2io</span> <span class="p">(</span><span class="kt">PutCurrentBalance</span> <span class="n">newValue</span><span class="p">)</span> <span class="ow">=</span>  <span class="c1">-- perform IO and return ()</span></pre></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><h1 id="back-to-the-repl">Back to the REPL.</h1><pre class="highlight code haskell"><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">runM</span> <span class="o">.</span> <span class="n">runLogger</span> <span class="o">.</span> <span class="n">runBank</span><span class="p">)</span>

<span class="kt">Eff</span> <span class="kt">'[Bank, Logger, IO]</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75200" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">runM</span> <span class="o">.</span> <span class="n">runLogger</span> <span class="o">.</span> <span class="n">runBank</span> <span class="o">$</span> <span class="n">withdraw</span> <span class="mi">50</span><span class="p">)</span>

<span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span></pre></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="76800" data-y="0" data-z="0"><h1 id="but-how-can-we-test-this">But how can we test this?</h1></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="78400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="cm">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="nf">ignoreLogger</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">r</span> <span class="n">a</span>
              <span class="o">.</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Logger</span> <span class="sc">'</span><span class="err">: r) a</span>
             <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>

<span class="nf">ignoreLogger</span> <span class="ow">=</span> <span class="n">handleRelay</span> <span class="n">pure</span> <span class="n">bind</span>
  <span class="kr">where</span>
    <span class="n">bind</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">x</span>
          <span class="o">.</span> <span class="kt">Logger</span> <span class="n">x</span>
         <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span>
         <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>
    <span class="n">bind</span> <span class="p">(</span><span class="kt">Log</span> <span class="kr">_</span><span class="p">)</span> <span class="n">cont</span> <span class="ow">=</span> <span class="n">cont</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80000" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">testBank</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">r</span> <span class="n">a</span>
           <span class="o">.</span> <span class="kt">Int</span>
          <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Bank</span> <span class="sc">'</span><span class="err">: r) a</span>
          <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>

<span class="nf">testBank</span> <span class="n">balance</span> <span class="ow">=</span> <span class="n">handleRelayS</span> <span class="n">balance</span> <span class="p">(</span><span class="n">const</span> <span class="n">pure</span><span class="p">)</span> <span class="n">bind</span>
  <span class="kr">where</span>
    <span class="n">bind</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">x</span>
          <span class="o">.</span> <span class="kt">Int</span>
         <span class="ow">-&gt;</span> <span class="kt">Bank</span> <span class="n">x</span>
         <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span>
         <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>
    <span class="n">bind</span> <span class="n">s</span> <span class="kt">GetCurrentBalance</span>      <span class="n">cont</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">s</span>  <span class="n">s</span>
    <span class="n">bind</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">PutCurrentBalance</span> <span class="n">s'</span><span class="p">)</span> <span class="n">cont</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">s'</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="81600" data-y="0" data-z="0"><h1 id="finally-pure-interpretations">Finally, pure interpretations!</h1><pre class="highlight code haskell"><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">run</span> <span class="o">.</span> <span class="n">ignoreLogger</span> <span class="o">.</span> <span class="n">testBank</span><span class="p">)</span>

<span class="kt">Eff</span> <span class="kt">'[Bank, Logger]</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="83200" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">run</span> <span class="o">.</span> <span class="n">ignoreLogger</span> <span class="o">.</span> <span class="n">testBank</span> <span class="o">$</span> <span class="n">withdraw</span> <span class="mi">50</span><span class="p">)</span>

<span class="kt">Maybe</span> <span class="kt">Int</span></pre></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="84800" data-y="0" data-z="0"><h1 id="so-far-this-doesn-t-seem-very-reusable">So far, this doesn't seem very reusable.</h1></div><div class="step step-level-1" step="54" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="86400" data-y="0" data-z="0"><h1 id="instead-of-this">Instead of this...</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Logger</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">Log</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Logger</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="55" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="88000" data-y="0" data-z="0"><h1 id="why-not-this">Why not this?</h1><pre>
data <span class="new">Writer w</span> a where
  Tell :: <span class="new">w</span> -> Writer w ()
</pre><p>Note: there is no Monoid constraint here!</p></div><div class="step step-level-1" step="56" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="89600" data-y="0" data-z="0"><h1 id="id1">Instead of this...</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Bank</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">GetCurrentBalance</span> <span class="ow">::</span> <span class="kt">Bank</span> <span class="kt">Int</span>
  <span class="kt">PutCurrentBalance</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bank</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="57" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="91200" data-y="0" data-z="0"><h1 id="id2">Why not this?</h1><pre>
data <span class="new">State s</span> a where
  Get :: State s <span class="new">s</span>
  Put :: <span class="new">s</span> -> State s ()
</pre></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="92800" data-y="0" data-z="0"><h1>This gives us more <span class="cursive" style="font-size: 48pt;">denotational meaning</span>.</h1></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="94400" data-y="0" data-z="0"><pre>
withdraw :: ( Member <span class="new">(State Int)</span>     r
            , Member <span class="new">(Writer String)</span> r
            )
         => Int
         -> Eff r (Maybe Int)

withdraw desired = do
  amount <span class="new">:: Int</span> <- <span class="new">get</span>
  if amount < desired
     then do
       <span class="new">tell</span> "not enough funds"
       return Nothing

     else do
       <span class="new">put</span> $ amount - desired
       return $ Just amount
</pre></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="96000" data-y="0" data-z="0"><h1 id="mo-generality-fewer-problems">Mo' generality = fewer problems.</h1><p>More general types are more likely to already have the interpretations that you
want.</p></div><div class="step step-level-1" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="97600" data-y="0" data-z="0"><h1 id="a-drop-in-for-mtl">A drop-in for MTL?</h1><p>Yes! But more than just that!</p></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="99200" data-y="0" data-z="0"><h1 id="a-conceptually-different-execution-model">A conceptually different execution model.</h1><p>In MTL:</p><pre class="highlight code haskell"><span class="nf">runReaderT</span> <span class="ow">::</span> <span class="kt">ReaderT</span> <span class="n">x</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span></pre><p>In Eff:</p><pre class="highlight code haskell"><span class="nf">runReader</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Reader</span> <span class="n">x</span> <span class="sc">'</span><span class="err">: r) a -&gt; x -&gt; Eff r a</span></pre></div><div class="step step-level-1" step="63" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="100800" data-y="0" data-z="0"><h1 id="interpreting-effects-in-terms-of-one-another">Interpreting effects in terms of one another.</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">Exc</span> <span class="n">e</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">ThrowError</span> <span class="ow">::</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Exc</span> <span class="n">e</span> <span class="n">a</span>
<span class="nf">makeFreer</span> <span class="kt">''Exc</span></pre></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="102400" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">accumThenThrow</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">Eq</span> <span class="n">e</span>
                  <span class="p">,</span> <span class="kt">Monoid</span> <span class="n">e</span>
                  <span class="p">,</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">Exc</span> <span class="n">e</span><span class="p">)</span> <span class="n">r</span>
                  <span class="p">)</span>
                <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">e</span> <span class="sc">'</span><span class="err">: r) a</span>
                <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>
<span class="nf">accumThenThrow</span> <span class="n">prog</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pureWriter</span> <span class="n">prog</span>
  <span class="n">unless</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">mempty</span><span class="p">)</span> <span class="o">$</span> <span class="n">throwError</span> <span class="n">e</span>
  <span class="n">return</span> <span class="n">a</span></pre></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="104000" data-y="0" data-z="0"><h1 id="non-trivial-transformations">Non-trivial transformations.</h1><pre class="highlight code haskell"><span class="kr">data</span> <span class="kt">SetOf</span> <span class="n">s</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">SetAdd</span>      <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">SetOf</span> <span class="n">s</span> <span class="nb">()</span>
  <span class="kt">SetContains</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="kt">SetOf</span> <span class="n">s</span> <span class="kt">Bool</span>
<span class="nf">makeFreer</span> <span class="kt">''SetOf</span></pre></div><div class="step step-level-1" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="105600" data-y="0" data-z="0"><pre class="highlight code haskell"><span class="nf">dedupWriter</span> <span class="ow">::</span> <span class="p">(</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">SetOf</span>  <span class="n">w</span><span class="p">)</span> <span class="n">r</span>
               <span class="p">,</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="n">r</span>
               <span class="p">)</span>
            <span class="ow">=&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>
            <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="n">r</span> <span class="n">a</span>
<span class="nf">dedupWriter</span> <span class="ow">=</span> <span class="n">interpose</span> <span class="n">pure</span> <span class="n">bind</span>
  <span class="kr">where</span>
    <span class="n">bind</span> <span class="p">(</span><span class="kt">Tell</span> <span class="n">w</span><span class="p">)</span> <span class="n">cont</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">alreadyTold</span> <span class="ow">&lt;-</span> <span class="n">setContains</span> <span class="n">w</span>
      <span class="n">unless</span> <span class="n">alreadyTold</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">setAdd</span> <span class="n">w</span>
        <span class="n">tell</span> <span class="n">w</span>
      <span class="n">cont</span> <span class="nb">()</span></pre></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="107200" data-y="0" data-z="0"><h1 id="summing-up">Summing up.</h1><ul><li>Eff gives us the flexibility of MTL without the boilerplate.</li><li>We get testing (mostly) for free.</li><li>We're forced to separate our business logic from implementation details.</li></ul></div><div class="step step-level-1" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="108800" data-y="0" data-z="0"><h1 id="thanks-for-listening">Thanks for listening!</h1><h1 id="questions">Questions?</h1></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>