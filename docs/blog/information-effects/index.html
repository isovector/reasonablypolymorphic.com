<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Review: Information Effects :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link href='https://fonts.googleapis.com/css?family=Amiri|Muli' rel='stylesheet' type='text/css' />
        <link href="/css/style.css" type="text/css" rel="stylesheet" />
        <link href="/css/syntax.css" type="text/css" rel="stylesheet" />

        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                    "HTML-CSS": {
                        scale: 100
                    },
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
  TeX: {extensions: [ "AMSmath.js"
                    , "AMSsymbols.js"
                    , "color.js"
                    , "cancel.js"
                    , "http://sonoisa.github.io/xyjax_ext/xypic.js"
                    ]}
            });
        </script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/information-effects">Review: Information Effects</a></h1>
</header>
<p class="meta">
    <span class="prev">
        <a href="/blog/theorems-for-free">&larr;</a>
    </span>
    <span class="next">
        <a href="/blog/modeling-music">&rarr;</a>
    </span>
    <time>August 20, 2017</time>

    <span class="tags">
        <a href="/tags/papers.html">papers</a>, <a href="/tags/review.html">review</a>, <a href="/tags/james.html">james</a>, <a href="/tags/sabry.html">sabry</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/reversible computing.html">reversible computing</a>
    </span>
</p>
<div class="content">
    <p>One of the most exciting papers I’ve read in a long time is James and Sabry’s <a href="https://www.cs.indiana.edu/~sabry/papers/information-effects.pdf">Information Effects</a>. It starts with the hook “computation is a physical process which, like all other physical processes, is fundamentally reversible,” and it goes from there. If that doesn’t immediately pull you in, perhaps some of the subsequent PL jargon will – it promises a “typed, universal, and reversible computation model in which information is treated as a linear resource”.</p>
<p>I don’t know about you, but I was positively shaking with anticipation at this point. That’s one heck of an abstract.</p>
<p>After some philosophy and overview of the paper, James and Sabry dive into the appetizer in a section titled “Thermodynamics of Computation and Information”. They give the following definition:</p>
<blockquote>
<p>DEFINITION 2.2 (Entropy of a variable). Let <span class="math inline">\(b\)</span> be a (not necessarily finite) type whose values are labeled <span class="math inline">\(b_1\)</span>, <span class="math inline">\(b_2\)</span>, <span class="math inline">\(\ldots\)</span>. Let <span class="math inline">\(\xi\)</span> be a random variable of type <span class="math inline">\(b\)</span> that is equal to <span class="math inline">\(b_i\)</span> with probability <span class="math inline">\(p_i\)</span>. The entropy of <span class="math inline">\(\xi\)</span> is defined as <span class="math inline">\(- \sum p_i \log{p_i}\)</span>.</p>
</blockquote>
<p>and the following, arguably less inspired definition:</p>
<blockquote>
<p>DEFINITION 2.3 (Output entropy of a function). Consider a function <code>f : a -&gt; b</code> where <code>b</code> is a (not necessarily finite) type whose values are labeled <span class="math inline">\(b_1\)</span>, <span class="math inline">\(b_2\)</span>, <span class="math inline">\(\ldots\)</span>. The output entropy of the function is given by <span class="math inline">\(- \sum q_j \log{q_j}\)</span> where <span class="math inline">\(q_j\)</span> indicates the probability of the function to have value <span class="math inline">\(b_j\)</span>.</p>
</blockquote>
<p>We can say now that a function is reversible if and only if the entropy of its arguments is equal to the entropy of its output. Which is to say that the gain in entropy across the function is 0.</p>
<p>Of course, as astute students of mathematics we know that reversibility of a function is equivalent to whether that function is an isomorphism. While this is how we will prefer to think of reversibility, the definition in terms of entropy brings up interesting questions of pragmatics that we will get to later.</p>
<p>James et al. present the following language, which we have reproduced here translated into Haskell. The language is first order, and so we will ignore function types, giving us the types:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators     #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Corresponds to Haskell &#39;()&#39; type</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">U</span> <span class="ot">=</span> <span class="dt">U</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Corresponds to Haskell &#39;Either&#39; type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">+</span> b</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">InL</span> a</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">InR</span> a</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Corresponds to Haskell &#39;(,)&#39; type</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">*</span> b <span class="ot">=</span> <span class="dt">Pair</span> a b</span></code></pre></div>
<p>The language presented is based around the notion of type isomorphisms, and so in order to model this language in Haskell, we’ll need the following types:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">&lt;=&gt;</span> b <span class="ot">=</span> <span class="dt">Iso</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> run ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> rev ::</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This type <code>a &lt;=&gt; b</code> represents an isomorphism between type <code>a</code> and type <code>b</code>, as witnessed by a pair of functions <code>to</code> and <code>from</code>. This probably isn’t the best encoding of an isomorphism, but for our purposes it will be sufficient.</p>
<p>James and Sabry present the following axioms of their language:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapP   ::</span>       a <span class="op">+</span> b <span class="op">&lt;=&gt;</span> b <span class="op">+</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assocP  ::</span> a <span class="op">+</span> (b <span class="op">+</span> c) <span class="op">&lt;=&gt;</span> (a <span class="op">+</span> b) <span class="op">+</span> c</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">unite   ::</span>       <span class="dt">U</span> <span class="op">*</span> a <span class="op">&lt;=&gt;</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">swapT   ::</span>       a <span class="op">*</span> b <span class="op">&lt;=&gt;</span> b <span class="op">*</span> a</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">assocT  ::</span> a <span class="op">*</span> (b <span class="op">*</span> c) <span class="op">&lt;=&gt;</span> (a <span class="op">*</span> b) <span class="op">*</span> c</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ot">distrib ::</span> (a <span class="op">+</span> b) <span class="op">*</span> c <span class="op">&lt;=&gt;</span> (a <span class="op">*</span> c) <span class="op">+</span> (b <span class="op">*</span> c)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot">      ::</span>           a <span class="op">&lt;=&gt;</span> a</span></code></pre></div>
<p>The implementations of these terms are all trivial, being that they are purely syntactic isomorphisms. They will not be reproduced here, but can be found in the <a href="https://github.com/isovector/information-effects/blob/master/src/Main.hs">code accompanying this post</a>. The motivated reader is encouraged to implement these for themself.</p>
<p>With the terms of our algebra out of the way, we’re now ready for the operators. We are presented with the following:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Isomorphisms are symmetric.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">sym ::</span> (a <span class="op">&lt;=&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="op">&lt;=&gt;</span> a)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Isomorphisms are transitive.</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> (a <span class="op">&lt;=&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="op">&lt;=&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="op">&lt;=&gt;</span> c)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Products and coproducts are bifunctors.</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">(.+) ::</span> (a <span class="op">&lt;=&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="op">&lt;=&gt;</span> d) <span class="ot">-&gt;</span> (a <span class="op">+</span> b <span class="op">&lt;=&gt;</span> c <span class="op">+</span> d)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> (a <span class="op">&lt;=&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="op">&lt;=&gt;</span> d) <span class="ot">-&gt;</span> (a <span class="op">*</span> b <span class="op">&lt;=&gt;</span> c <span class="op">*</span> d)</span></code></pre></div>
<p>It turns out that the resulting language is already surprisingly expressive. We can encode booleans:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">U</span> <span class="op">+</span> <span class="dt">U</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>true,<span class="ot"> false ::</span> <span class="dt">Bool</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>true  <span class="ot">=</span> <span class="dt">InL</span> <span class="dt">U</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> <span class="dt">InR</span> <span class="dt">U</span></span></code></pre></div>
<p>With these out of the way, James et al. show us a “one-armed if-expression”: if the incoming <code>Bool</code> is <code>true</code>, transform the <code>a</code> by the provided combinator:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifthen ::</span> (a <span class="op">&lt;=&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="op">*</span> a <span class="op">&lt;=&gt;</span> <span class="dt">Bool</span> <span class="op">*</span> a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ifthen c <span class="ot">=</span> distrib <span class="op">&gt;&gt;</span> (<span class="fu">id</span> <span class="op">.*</span> c) <span class="op">.+</span> <span class="fu">id</span> <span class="op">&gt;&gt;</span> sym distrib</span></code></pre></div>
<p>For syntactic convenience, we will enable rebindable syntax, allowing us to represent these chains of isomorphism transitivities with <code>do</code> notation. We can thus express the above more clearly as:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">ifthen ::</span> (a <span class="op">&lt;=&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="op">*</span> a <span class="op">&lt;=&gt;</span> <span class="dt">Bool</span> <span class="op">*</span> a)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>ifthen c <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  distrib</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">id</span> <span class="op">.*</span> c) <span class="op">.+</span> <span class="fu">id</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  sym distrib</span></code></pre></div>
<p>The mystery behind naming our transitivity operator <code>(&gt;&gt;)</code> is thus explained.</p>
<p>But how does our <code>ifthen</code> combinator actually work? Recall that <code>Bool = U + U</code>, meaning that we can distribute the <code>U</code>s across the pair, giving us the type <code>(U * a) + (U * a)</code>. The left branch (of type <code>U * a</code>) of this coproduct has an inhabitant if the incoming boolean was <code>true</code>.</p>
<p>We can thus bimap over the coproduct. Since the left case corresponds to an incoming <code>true</code>, we can apply an isomorphism over only that branch. Because we want to transform the incoming <code>a</code> by the combinator <code>c</code>, we then bimap over our <code>U * a</code> with <code>id .* c</code> – not touching the <code>U</code> but using our combinator.</p>
<p>Finally, we need to repackage our <code>(U * a) + (U * a)</code> into the correct return type <code>Bool * a</code>, which we can do by factoring out the <code>a</code>. Factoring is the inverse of <code>distrib</code>uting, and so we can use the <code>sym</code> operator to “undo” the <code>distrib</code>.</p>
<p>It’s crazy, but it actually works! We can run these things to convince ourselves. Given:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="op">&lt;=&gt;</span> <span class="dt">Bool</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> <span class="ot">=</span> swapP  <span class="co">-- move a left (&#39;true&#39;) to a right (&#39;false&#39;), and vice versa.</span></span></code></pre></div>
<p>We get:</p>
<pre><code>&gt; run (ifthen not) $ Pair true false
Pair true true

&gt; run (ifthen not) $ Pair false false
Pair false false</code></pre>
<p>Neat, no? For fun, we can also run these things <em>backwards</em>:</p>
<pre><code>&gt; rev (ifthen not) $ Pair true true
Pair true false

&gt; rev (ifthen not) $ Pair false false
Pair false false</code></pre>
<p>James et al. are eager to point out that <code>ifthen (ifthen not) :: Bool * (Bool * Bool) &lt;=&gt; Bool * (Bool * Bool)</code> is the <a href="https://en.wikipedia.org/wiki/Toffoli_gate">Toffoli gate</a> – a known universal reversible gate. Because we can implement Toffoli (and due to its universalness), we can thus implement <em>any</em> boolean expression.</p>
<h2 id="recursion-and-natural-numbers">Recursion and Natural Numbers</h2>
<p>Given two more primitives, James and Sabry show us how we can extend this language to be “expressive enough to write arbitrary looping programs, including non-terminating ones.”</p>
<p>We’ll need to define a term-level recursion axiom:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">trace ::</span> (a <span class="op">+</span> b <span class="op">&lt;=&gt;</span> a <span class="op">+</span> c) <span class="ot">-&gt;</span> (b <span class="op">&lt;=&gt;</span> c)</span></code></pre></div>
<p>The semantics of <code>trace</code> are as follows: given an incoming <code>b</code> (or, symmetrically, a <code>c</code>), lift it into <code>InR b :: a + b</code>, and then run the given iso over it looping until the result is an <code>InR c</code>, which can then be returned.</p>
<p>Notice here that we have introduced potentially non-terminating looping. Combined with our universal boolean expressiveness, this language is now Turing-complete, meaning it is capable of computing anything computable. Furthermore, by construction, we <em>also</em> have the capability to compute backwards – given an output, we can see what the original input was.</p>
<p>You might be concerned that the potential for partiality given by the <code>trace</code> operator breaks the bijection upon which all of our reversibility has been based. This, we are assured is not a problem, because a divergence is never actually observed, and as such, does not <em>technically</em> violate the bijectiveness. It’s fine, you guys. Don’t worry.</p>
<p>There is one final addition we need, which is the ability to represent inductive types:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fold ::</span> f (<span class="dt">Fix</span> f) <span class="op">&lt;=&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>fold <span class="ot">=</span> <span class="dt">Iso</span> <span class="dt">Fix</span> unFix</span></code></pre></div>
<p>Given these things, we can define the natural numbers a little circuitously. We can define their type as follows:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Fix</span> ((<span class="op">+</span>) <span class="dt">U</span>)</span></code></pre></div>
<p>Constructing such things is a little tricky, however. First we’ll need a way to introduce a coproduct. The type and name of this isomorphism should be suggestive:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">just ::</span> a <span class="op">&lt;=&gt;</span> <span class="dt">U</span> <span class="op">+</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>just <span class="ot">=</span> trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  sym assocP</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  (sym fold <span class="op">&gt;&gt;</span> swapP) <span class="op">.+</span> <span class="fu">id</span></span></code></pre></div>
<p><code>just</code> is a tricky little beast; it works by using <code>trace</code> to eliminate the <code>Nat + U</code> of a <code>(Nat + U) + (U + a)</code>. We can follow the derivation a little more closely:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">body ::</span> (<span class="dt">Nat</span> <span class="op">+</span> <span class="dt">U</span>) <span class="op">+</span> a <span class="op">&lt;=&gt;</span> (<span class="dt">Nat</span> <span class="op">+</span> <span class="dt">U</span>) <span class="op">+</span> (<span class="dt">U</span> <span class="op">+</span> a)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>body <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  sym assocP      <span class="co">-- Nat + (U + a)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  sym fold <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- (U + Nat) + (U + a)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  swapP    <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- (Nat + U) + (U + a)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>trace<span class="ot"> body ::</span> a <span class="op">&lt;=&gt;</span> <span class="dt">U</span> <span class="op">+</span> a</span></code></pre></div>
<p>I wish I had come up with this, because it’s quite clever. Notice however that this is a partial isomorphism; when run backwards, it will diverge in the case of <code>InR U :: U + a</code>.</p>
<p>Given <code>just</code>, we can now define <code>succ</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">succ</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="op">&lt;=&gt;</span> <span class="dt">Nat</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">succ</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  just  <span class="co">-- U + Nat</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  fold  <span class="co">-- Nat</span></span></code></pre></div>
<p>James et al. provide a little more machinery in order to get to the introduction of a 0:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">injectR ::</span> a <span class="op">&lt;=&gt;</span> a <span class="op">+</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>injectR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  sym unite       <span class="co">-- U * a</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  just <span class="op">.*</span> <span class="fu">id</span>      <span class="co">-- (U + U) * a</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  distrib         <span class="co">-- (U * a) + (U * a)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  unite <span class="op">.+</span> unite  <span class="co">-- a + a</span></span></code></pre></div>
<p>and finally:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">zero ::</span> <span class="dt">U</span> <span class="op">&lt;=&gt;</span> <span class="dt">Nat</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>zero <span class="ot">=</span> trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>       <span class="co">-- Nat + U</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  swapP    <span class="co">-- U + Nat</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  fold     <span class="co">-- Nat</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  injectR  <span class="co">-- Nat + Nat</span></span></code></pre></div>
<p>What’s interesting here is that the introduction of 0 is an isomorphism between <code>U</code> and <code>Nat</code>, as we should expect since 0 is a constant.</p>
<h3 id="induction-on-nats">Induction on Nats</h3>
<p>The paper teases an implementation of <code>isEven</code> for natural numbers – from the text:</p>
<blockquote>
<p>For example, it is possible to write a function <code>even? :: Nat * Bool &lt;=&gt; Nat * Bool</code> which, given inputs <code>(n, b)</code>, reveals whether <code>n</code> is even or odd by iterating <code>not</code> <code>n</code>-times starting with <code>b</code>. The iteration is realized using <code>trace</code> as shown in the diagram below <strong>(where we have omitted the boxes for <code>fold</code> and <code>unfold</code>)</strong>.</p>
</blockquote>
<p>Emphasis mine. The omitted <code>fold</code> and <code>unfold</code> bits of the diagram are the actual workhorses of the isomorphism, and their omission caused me a few days of work to rediscover. I have presented the working example here to save you, gentle reader, from the same frustration.</p>
<p>The insight is this – our desired isomorphism has type <code>Nat * a &lt;=&gt; Nat * a</code>. Due to its universally qualified nature, we are unable to pack any information into the <code>a</code>, and thus to be reversible, the <code>Nat</code> must be the same on both sides. Since we are unable to clone arbitrary values given our axioms (seriously! try it!), our only solution is to build a resulting <code>Nat</code> up from 0 as we tear apart the one we were given.</p>
<p>We can view the <code>a</code> in <code>trace :: (a + b &lt;=&gt; a + c) -&gt; (b &lt;=&gt; c)</code> as “scratch space” or “intermediate state”. It is clear that in order to execute upon our earlier insight, we will need three separate pieces of state: the <code>Nat</code> we’re tearing down, the <code>Nat</code> we’re building up, and the <code>a</code> along for the ride.</p>
<p>For reasons I don’t deeply understand, other than it happened to make the derivation work, we also need to introduce a unit to the input of our traced combinator.</p>
<p>With this line of reasoning, we have the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iterNat ::</span> (a <span class="op">&lt;=&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Nat</span> <span class="op">*</span> a <span class="op">&lt;=&gt;</span> <span class="dt">Nat</span> <span class="op">*</span> a)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>iterNat step <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  sym unite</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>  <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  unite</span></code></pre></div>
<p>For clarity, we’ll annotate the natural number under construction as <code>Nat'</code>.</p>
<p>When the iteration begins, our combinator receives an <code>InR</code> whose contents are of type <code>U * (Nat * a)</code> corresponding to the fact that there is not yet any internal state. From there we can factor our the <code>Nat * a</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>           <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    sym distrib  <span class="co">-- (Nat&#39; + U) * (Nat * a)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>All of a sudden this looks like a more tenable problem. We now have a product of (conceptually) a <code>Maybe Nat'</code>, the <code>Nat</code> being torn down, and our <code>a</code>. We can <code>fold :: U + Nat &lt;=&gt; Nat</code> our <code>Nat'</code>, which will give us 0 in the case that the state hasn’t yet been created, or <span class="math inline">\(n+1\)</span> in the case it has.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>                     <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    sym distrib            <span class="co">-- (Nat&#39; + U) * (Nat * a)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    (swapP <span class="op">&gt;&gt;</span> fold) <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- Nat&#39; * (Nat * a)</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>The only thing left is to destruct the incoming <code>Nat</code> and apply our <code>step</code> isomorphism. We introduce a lemma to help:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapBacT ::</span> a <span class="op">*</span> (b <span class="op">*</span> c) <span class="op">&lt;=&gt;</span> b <span class="op">*</span> (a <span class="op">*</span> c)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>swapBacT <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  assocT</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> <span class="fu">id</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  sym assocT</span></code></pre></div>
<p>which we can then use to move the pieces of our state and destruct the correct number:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>                         <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    sym distrib                <span class="co">-- (Nat&#39; + U) * (Nat * a)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    (swapP <span class="op">&gt;&gt;</span> fold) <span class="op">.*</span> <span class="fu">id</span>      <span class="co">-- Nat&#39; * (Nat * a)</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    swapBacT                   <span class="co">-- Nat * (Nat&#39; * a)</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    (sym fold <span class="op">&gt;&gt;</span> swapP) <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- (Nat + U) * (Nat&#39; * a)</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>We can then distribute out the <code>Nat + U</code> again:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>                         <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    sym distrib                <span class="co">-- (Nat&#39; + U) * (Nat * a)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    (swapP <span class="op">&gt;&gt;</span> fold) <span class="op">.*</span> <span class="fu">id</span>      <span class="co">-- Nat&#39; * (Nat * a)</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    swapBacT                   <span class="co">-- Nat * (Nat&#39; * a)</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    (sym fold <span class="op">&gt;&gt;</span> swapP) <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- (Nat + U) * (Nat&#39; * a)</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    distrib                    <span class="co">-- (Nat * (Nat&#39; * a)) + (U * (Nat&#39; * a))</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>And finally, we apply our <code>step</code> iso to the internal state (we do this after the <code>distrib</code> so that we don’t apply the combinator if the incoming number was 0). The fruits of our labor are presented in entirety:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iterNat ::</span> (a <span class="op">&lt;=&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Nat</span> <span class="op">*</span> a <span class="op">&lt;=&gt;</span> <span class="dt">Nat</span> <span class="op">*</span> a)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>iterNat step <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  sym unite</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span>                          <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat * a))</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    sym distrib                 <span class="co">-- (Nat&#39; + U) * (Nat * a)</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    (swapP <span class="op">&gt;&gt;</span> fold) <span class="op">.*</span> <span class="fu">id</span>       <span class="co">-- Nat&#39; * (Nat * a)</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    swapBacT                    <span class="co">-- Nat * (Nat&#39; * a)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    (sym fold <span class="op">&gt;&gt;</span> swapP) <span class="op">.*</span> <span class="fu">id</span>   <span class="co">-- (Nat + U) * (Nat&#39; * a)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    distrib                     <span class="co">-- (Nat * (Nat&#39; * a)) + (U * (Nat&#39; * a))</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">id</span> <span class="op">.*</span> (<span class="fu">id</span> <span class="op">.*</span> step)) <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- (Nat * (Nat&#39; * a)) + (U * (Nat&#39; * a))</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    swapBacT <span class="op">.+</span> <span class="fu">id</span>              <span class="co">-- (Nat&#39; * (Nat * a)) + (U * (Nat&#39; * a))</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>  unite</span></code></pre></div>
<p>Lo and behold, the types now line up, and thus quod erat demonstrandum. The implementation of <code>isEven</code> is now trivial:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isEven ::</span> <span class="dt">Nat</span> <span class="op">*</span> <span class="dt">Bool</span> <span class="op">&lt;=&gt;</span> <span class="dt">Nat</span> <span class="op">*</span> <span class="dt">Bool</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>isEven <span class="ot">=</span> iterNat <span class="fu">not</span></span></code></pre></div>
<p>which computes if a <code>Nat</code> is even in the case the incoming <code>Bool</code> is <code>false</code>, and whether it is odd otherwise.</p>
<h2 id="lists">Lists</h2>
<p>James and Sabry provide a sketch of how to define lists, but I wanted to flesh out the implementation to test my understanding.</p>
<p>For reasons I don’t pretend to understand, Haskell won’t let us partially apply a type synonym, so we’re forced to write a higher-kinded data definition in order to describe the shape of a list.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- To be read as @type ListF a b = U + (a * b)@.</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListF</span> a b</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cons</span> a b</span></code></pre></div>
<p>We can then get the fixpoint of this in order to derive a real list:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">ListF</span> a)</span></code></pre></div>
<p>And to get around the fact that we had to introduce a wrapper datatype in order to embed this into Haskell, we then provide an eliminator to perform “pattern matching” on a <code>List a</code>. In a perfect world, this function would just be <code>sym fold</code>, but alas, we must work with what we have.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liste ::</span> <span class="dt">List</span> a <span class="op">&lt;=&gt;</span> <span class="dt">U</span> <span class="op">+</span> (a <span class="op">*</span> <span class="dt">List</span> a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>liste <span class="ot">=</span> <span class="dt">Iso</span> to from</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Fix</span> <span class="dt">Nil</span>)          <span class="ot">=</span> <span class="dt">InL</span> <span class="dt">U</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    to (<span class="dt">Fix</span> (<span class="dt">Cons</span> a b))   <span class="ot">=</span> <span class="dt">InR</span> (<span class="dt">Pair</span> a b)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">InL</span> <span class="dt">U</span>)          <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">Nil</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    from (<span class="dt">InR</span> (<span class="dt">Pair</span> a b)) <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Cons</span> a b)</span></code></pre></div>
<p>From here, it is trivial to write <code>cons</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cons ::</span> a <span class="op">*</span> <span class="dt">List</span> a <span class="op">&lt;=&gt;</span> <span class="dt">List</span> a</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>cons <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  just       <span class="co">-- U + (a * List a)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  sym liste  <span class="co">-- List</span></span></code></pre></div>
<p>However, introducing a list via <code>nil</code> is actually quite complicated. Note the parallels with the natural numbers, where it was trivial to define <code>succ</code> but required a clever trick to introduce a <code>zero</code>.</p>
<p>We begin with a lemma that moves a coproduct:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swapCbaP ::</span> (a <span class="op">+</span> b) <span class="op">+</span> c <span class="op">&lt;=&gt;</span> (c <span class="op">+</span> b) <span class="op">+</span> a</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>swapCbaP <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  sym assocP   <span class="co">-- a + (b + c)</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  swapP        <span class="co">-- (b + c) + a</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  swapP <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- (c + b) + a</span></span></code></pre></div>
<p>And given that, we can write an isomorphism between any <code>a</code> and any <code>b</code>. The catch, of course, is that you can never witness such a thing since it obviously doesn’t exist. Nevertheless, we can use it to convince the type checker that we’re doing the right thing in cases that would diverge in any case.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">diverge ::</span> a <span class="op">&lt;=&gt;</span> b</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>diverge <span class="ot">=</span> trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>                 <span class="co">-- (a + b) + a</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  swapP <span class="op">.+</span> <span class="fu">id</span>        <span class="co">-- (b + a) + a</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  swapCbaP           <span class="co">-- (a + a) + b</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  sym injectR <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- a + b</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  swapP              <span class="co">-- b + a</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>  right <span class="op">.+</span> <span class="fu">id</span>        <span class="co">-- (b + b) + a</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  swapCbaP           <span class="co">-- (a + b) + b</span></span></code></pre></div>
<p>Finally we can implement <code>nil</code> using the same trick we did for <code>zero</code> – use <code>trace</code> to vacuously introduce exactly the type we need, rip out the result, and then divergently reconstruct the type that <code>trace</code> expects.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nil ::</span> <span class="dt">U</span> <span class="op">&lt;=&gt;</span> <span class="dt">List</span> a</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>nil <span class="ot">=</span> trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>                        <span class="co">-- (a * List a) + U</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  swapP                     <span class="co">-- U + (a * List a)</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  sym liste                 <span class="co">-- List a</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  sym unite                 <span class="co">-- U * List a</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  just <span class="op">.*</span> <span class="fu">id</span>                <span class="co">-- (U + U) * List a</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  distrib                   <span class="co">-- (U * List a) + (U * List a)</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  (diverge <span class="op">.*</span> <span class="fu">id</span>) <span class="op">.+</span> unite  <span class="co">-- (a * List a) + List a</span></span></code></pre></div>
<h3 id="induction-on-lists">Induction on Lists</h3>
<p>In a manner spiritually similar to <code>iterNat</code>, we can define <code>iterList :: (a * z &lt;=&gt; b * z) -&gt; (List a * z &lt;=&gt; List b * z)</code>. The semantics are mostly what you’d expect from its type, except that the resulting <code>List b</code> is in reverse order due to having to be constructed as the <code>List a</code> was being destructed. We present the implementation here for completeness but without further commentary.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">iterList ::</span> (a <span class="op">*</span> z <span class="op">&lt;=&gt;</span> b <span class="op">*</span> z) <span class="ot">-&gt;</span> (<span class="dt">List</span> a <span class="op">*</span> z <span class="op">&lt;=&gt;</span> <span class="dt">List</span> b <span class="op">*</span> z)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>iterList f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  sym unite</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                                <span class="co">-- ((b * List b) * (List a * z)) + (U * (List a * z))</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    sym distrib                 <span class="co">-- ((b * List b) + U) * (List a * z)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    (swapP <span class="op">&gt;&gt;</span> sym liste) <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- List b * (List a * z)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    swapBacT                    <span class="co">-- List a * (List b * z)</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    liste <span class="op">.*</span> <span class="fu">id</span>                 <span class="co">-- (U + (a * List a)) * (List b * z)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    distrib                     <span class="co">-- (U * (List b * z)) + ((a * List a) * (List b * z))</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    (<span class="op">.+</span>) <span class="fu">id</span> <span class="op">$</span>                   <span class="co">-- (U * (List b * z)) + ...</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        swapT <span class="op">.*</span> <span class="fu">id</span>             <span class="co">--    ((List a * a) * (List b * z))</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        swapAcbdT               <span class="co">--    ((List a * List b) * (a * z))</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">id</span> <span class="op">.*</span> f                 <span class="co">--    ((List a * List b) * (b * z))</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        swapAcbdT               <span class="co">--    ((List a * b) * (List b * z))</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    swapP                       <span class="co">-- ((List a * b) * (List b * z)) + (U * (List b * z))</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    (swapT <span class="op">.*</span> <span class="fu">id</span>) <span class="op">.+</span> <span class="fu">id</span>         <span class="co">-- ((b * List a) * (List b * z)) + (U * (List b * z))</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    swapAcbdT <span class="op">.+</span> <span class="fu">id</span>             <span class="co">-- ((b * List b) * (List a * z)) + (U * (List b * z))</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>  unite</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="ot">swapAcbdT ::</span> (a <span class="op">*</span> b) <span class="op">*</span> (c <span class="op">*</span> d) <span class="op">&lt;=&gt;</span> (a <span class="op">*</span> c) <span class="op">*</span> (b <span class="op">*</span> d)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>swapAcbdT <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>  sym assocT</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> sw</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>  assocT</span></code></pre></div>
<p>From here, the functional programming favorite <code>map</code> is easily defined:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="op">&lt;=&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">List</span> a <span class="op">&lt;=&gt;</span> <span class="dt">List</span> b)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  sym unite</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  swapT</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  iterList <span class="op">$</span> f <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- map</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  iterList <span class="fu">id</span>         <span class="co">-- reverse to original order</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  swapT</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>  unite</span></code></pre></div>
<h2 id="remnants">Remnants</h2>
<p>The bulk of the remainder of the paper is an extension to the reversible semantics above, introducing <code>create :: U ~&gt; a</code> and <code>erase :: a ~&gt; U</code> where <code>(~&gt;)</code> is a non-reversible arrow. We are shown how traditional non-reversible languages can be transformed into the <code>(~&gt;)</code>-language.</p>
<p>Of more interest is James and Sabry’s construction which in general transforms <code>(~&gt;)</code> (a non-reversible language) into <code>(&lt;=&gt;)</code> (a reversible one). But how can such a thing be possible? Obviously there is a trick!</p>
<p>The trick is this: given <code>a ~&gt; b</code>, we can build <code>h * a &lt;=&gt; g * b</code> where <code>h</code> is “heap” space, and <code>g</code> is “garbage”. Our non-reversible functions <code>create</code> and <code>erase</code> thus become reversible functions which move data from the heap and to the garbage respectively.</p>
<p>Unfortunately, this is a difficult thing to model in Haskell, since the construction requires <code>h</code> and <code>g</code> to vary based on the axioms used. Such a thing requires dependent types, which, while possible, is quite an unpleasant undertaking. Trust me, I actually tried it.</p>
<p>However, just because it’s hard to model entirely in Haskell doesn’t mean we can’t discuss it. We can start with the construction of <code>(~&gt;)</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">~&gt;</span> b <span class="kw">where</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Arr</span><span class="ot">     ::</span> (a <span class="op">&lt;=&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">~&gt;</span> b)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Compose</span><span class="ot"> ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="op">~&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="op">~&gt;</span> c)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">First</span><span class="ot">   ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">*</span> c <span class="op">~&gt;</span> b <span class="op">*</span> c)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span><span class="ot">    ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">+</span> c <span class="op">~&gt;</span> b <span class="op">+</span> c)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Create</span><span class="ot">  ::</span> <span class="dt">U</span> <span class="op">~&gt;</span> a</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Erase</span><span class="ot">   ::</span> a <span class="op">~&gt;</span> <span class="dt">U</span></span></code></pre></div>
<p>The axioms here are quite explanatory and will not be discussed further. A point of note, however, is that <code>Arr</code> allows arbitrary embeddings of our iso <code>(&lt;=&gt;)</code> language in this arrow language.</p>
<p>The semantics of <code>Create</code> is given by induction:</p>
<p><span class="math display">\[
\newcommand{\u}{\text{U}}
\begin{align*}
\text{create U} &amp; \mapsto \u \\
\text{create}(a + b) &amp; \mapsto \text{InL } (\text{create } a) \\
\text{create}(a \times b) &amp; \mapsto (\text{create } a, \text{create } b)
\end{align*}
\]</span></p>
<p>With the ability to create and erase information, we’re (thankfully) now able to write some everyday functions that you never knew you missed until trying to program in the iso language without them. James et al. give us what we want:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fstA ::</span> a <span class="op">*</span> b <span class="op">~&gt;</span> a</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>fstA <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  arr swapT    <span class="co">-- b * a</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  first erase  <span class="co">-- U * a</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  arr unite    <span class="co">-- a</span></span></code></pre></div>
<p>In addition to projections, we also get injections:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftA ::</span> a <span class="op">~&gt;</span> a <span class="op">+</span> b</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>leftA <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  arr <span class="op">$</span> sym unite  <span class="co">-- U * a</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  first create     <span class="co">-- (a + b) * a</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  arr leftSwap     <span class="co">-- (a + b) * a</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  fstA             <span class="co">-- a + b</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="ot">leftSwap ::</span> (a <span class="op">+</span> b) <span class="op">*</span> a <span class="op">&lt;=&gt;</span> (a <span class="op">+</span> b) <span class="op">*</span> a</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>leftSwap <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  distrib      <span class="co">-- (a * a&#39;) + (b * a&#39;)</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.+</span> <span class="fu">id</span>  <span class="co">-- (a&#39; * a) + (b * a&#39;)</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  sym distrib  <span class="co">-- (a&#39; + b) * a</span></span></code></pre></div>
<p>And the ability to extract from a coproduct:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> a <span class="op">+</span> a <span class="op">~&gt;</span> a</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>join <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  arr <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    sym unite <span class="op">.+</span> sym unite  <span class="co">-- (U * a) + (U * a)</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    sym distrib             <span class="co">-- (U + U) * a</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    swapT                   <span class="co">-- a * (U + U)</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  fstA                      <span class="co">-- a</span></span></code></pre></div>
<p>We are also provided with the ability to clone a piece of information, given by structural induction. Cloning <code>U</code> is trivial, and cloning a pair is just cloning its projections and then shuffling them into place. The construction of cloning a coproduct, however, is more involved:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">clone ::</span> a <span class="op">+</span> b <span class="op">~&gt;</span> (a <span class="op">+</span> b) <span class="op">*</span> (a <span class="op">+</span> b)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>clone <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  left <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    clone                <span class="co">-- (a * a) + b</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    first leftA          <span class="co">-- ((a + b) * a) + b</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    arr swapT            <span class="co">-- (a * (a + b)) + b</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  arr swapP              <span class="co">-- b + (a * (a + b))</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  left <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    clone                <span class="co">-- (b * b) + (a * (a + b))</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    first leftA          <span class="co">-- ((b + a) * b) + (a * (a + b))</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    arr swapT            <span class="co">-- (b * (b + a)) + (a * (a + b))</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  arr <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    swapP                <span class="co">-- (a * (a + b)) + (b * (b + a))</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">id</span> <span class="op">.+</span> (<span class="fu">id</span> <span class="op">.*</span> swapP)  <span class="co">-- (a * (a + b)) + (b * (a + b))</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    sym distrib          <span class="co">-- (a + b) * (a + b)</span></span></code></pre></div>
<p>It should be quite clear that this arrow language of ours is now more-or-less equivalent to some hypothetical first-order version of Haskell (like <a href="http://reasonablypolymorphic.com/blog/elm-is-wrong">Elm</a>?). As witnessed above, information is no longer a linear commodity. A motivated programmer could likely get work done in a 9 to 5 with what we’ve built so far. It probably wouldn’t be a lot of fun, but it’s higher level than C at the very least.</p>
<p>The coup de grace of Information Effects is its construction lifting our arrow language <em>back</em> into the isomorphism language. The trick is to carefully construct heap and garbage types to correspond exactly with what our program needs to create and erase. We can investigate this further by case analysis on the constructors of our arrow type:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Arr</span><span class="ot"> ::</span> (a <span class="op">&lt;=&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">~&gt;</span> b)</span></code></pre></div>
<p>As we’d expect, an embedding of an isomorphism in the arrow language is already reversible. However, because we need to introduce a heap and garbage anyway, we’ll use unit.</p>
<p>Since we can’t express the typing judgment in Haskell, we’ll use a sequent instead:</p>
<p><span class="math display">\[
\newcommand{\lifted}[3]{\text{lift } #1 : #2 \leftrightarrow #3}
\newcommand{\arr}{\rightsquigarrow}
\frac{\text{arr } f : a \arr b}{\lifted{(\text{arr } f)}{\u
\times a}{\u \times b}}
\]</span></p>
<p>Assuming we have a way of describing this type in Haskell, all that’s left is to implement the <code>lift</code>ing of our iso into the enriched iso language:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>lift (<span class="dt">Arr</span> f) <span class="ot">=</span> <span class="fu">id</span> <span class="op">.*</span> f</span></code></pre></div>
<hr />
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Compose</span><span class="ot"> ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="op">~&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="op">~&gt;</span> c)</span></code></pre></div>
<p>Composition of arrows proceeds likewise in a rather uninteresting manner. Here, we have two pairs of heaps and garbages, results from lifting each of the arrows we’d like to compose. Because composition will run <em>both</em> of our arrows, we’ll need both heaps and garbages in order to implement the result. By this logic, the resulting heap and garbage types are pairs of the incoming ones.</p>
<p><span class="math display">\[
\frac{\lifted{f}{h_1\times a}{g_1\times b},\; \lifted{g}{h_2\times b}{g_2\times
c}}{\lifted{(g \circ f)}{(h_1\times h_2)\times a}{(g_1\times g_2)\times c}}
\]</span></p>
<p>We can express the resulting combinator in Haskell:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>lift (<span class="dt">Compose</span> f g) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>            <span class="co">-- (H1 * H2) * a</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> <span class="fu">id</span>   <span class="co">-- (H2 * H1) * a</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  sym assocT    <span class="co">-- H2 * (H1 * a)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> lift f  <span class="co">-- H2 * (G1 * b)</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>  assocT        <span class="co">-- (H2 * G1) * b</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> <span class="fu">id</span>   <span class="co">-- (G1 * H2) * b</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  sym assocT    <span class="co">-- G1 * (H2 * b)</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> lift g  <span class="co">-- G1 * (G2 * c)</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>  assocT        <span class="co">-- (G1 * G2) * c</span></span></code></pre></div>
<hr />
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">First</span><span class="ot"> ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">*</span> c <span class="op">~&gt;</span> b <span class="op">*</span> c)</span></code></pre></div>
<p>Lifting arrows over products again is uninteresting – since we’re doing nothing with the second projection, the only heap and garbage we have to work with are those resulting from the lifting of our arrow over the first projection.</p>
<p><span class="math display">\[
\frac{\lifted{f}{h\times a}{g\times b}}
{\lifted{(\text{First } f)}{h\times (a\times c)}{g\times (b\times c)}}
\]</span></p>
<p>In Haskell, our resulting combinator looks like this:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>lift (<span class="dt">First</span> f) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>          <span class="co">-- H * (a * c)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  assocT      <span class="co">-- (H * a) * c</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  f <span class="op">.*</span> <span class="fu">id</span>     <span class="co">-- (G * b) * c</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  sym assocT  <span class="co">-- G * (b * c)</span></span></code></pre></div>
<hr />
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span><span class="ot"> ::</span> (a <span class="op">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="op">+</span> c <span class="op">~&gt;</span> b <span class="op">+</span> c)</span></code></pre></div>
<p>Finally, we get to an interesting case. In the execution of <code>Left</code>, we may or may not use the incoming heap. We also need a means of creating a <code>b + c</code> given a <code>b</code> <em>or</em> given a <code>c</code>. Recall that in our iso language, we do not have <code>create</code> (nor relatedly, <code>leftA</code>) at our disposal, and so this is a harrier problem than it sounds at first.</p>
<p>We can solve this problem by requiring both a <code>b + c</code> and a <code>c + b</code> from the heap. Remember that the Toffoli construction (what we’re implementing here) will create a reversible gate with additional inputs and outputs that gives the same result when all of its inputs have their default values (ie. the same as those provided by <code>create</code>’s semantics). This means that our incoming <code>b + c</code> and <code>c + b</code> will both be constructed with <code>InL</code>.</p>
<p>Given this, we can thus perform case analysis on the incoming <code>a + c</code>, and then use <code>leftSwap</code> from earlier to move the resulting values into their coproduct.</p>
<p>What does the garbage situation look like? In the case we had an incoming <code>InL</code>, we will have used up our function’s heap, as well as our <code>b + c</code>, releasing the <code>g</code>, <code>b</code> (the default value swapped out of our incoming <code>b + c</code>), and the unused <code>c + b</code>.</p>
<p>If an <code>InR</code> was input to our isomorphism, we instead emit the function’s heap <code>h</code>, the unused <code>b + c</code>, and the default <code>c</code> originally in the heap’s coproduct.</p>
<p>Our final typing judgment thus looks like this:</p>
<p><span class="math display">\[
\frac{\lifted{f}{h\times a}{g\times b}}{\lifted{(\text{Left f})}{h&#39;\times (a + c)}{g&#39; \times (b + c)}}
\]</span></p>
<p><span class="math display">\[
h&#39; = h\times ((b + c) \times(c + b)) \\
g&#39; = (g\times (b\times(c + b))) + (h\times ((b+c)\times c))
\]</span></p>
<p>and is rather horrifyingly implemented:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>lift (<span class="dt">Left</span> f) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  swapT</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  distrib</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  leftSide f <span class="op">.+</span> rightSide</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  sym distrib</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>leftSide</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> (h <span class="op">*</span> a <span class="op">&lt;=&gt;</span> g <span class="op">*</span> b)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (a <span class="op">*</span> (h <span class="op">*</span> ((b <span class="op">+</span> c) <span class="op">*</span> (c <span class="op">+</span> b))) <span class="op">&lt;=&gt;</span> (g <span class="op">*</span> (b <span class="op">*</span> (c <span class="op">+</span> b))) <span class="op">*</span> (b <span class="op">+</span> c))</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>leftSide f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>  swapT                <span class="co">-- (H * ((b + c) * (c + b))) * a</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> <span class="fu">id</span>          <span class="co">-- (((b + c) * (c + b)) * H) * a</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>  sym assocT           <span class="co">-- ((b + c) * (c + b)) * (H * a)</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> f              <span class="co">-- ((b + c) * (c + b)) * (G * b&#39;)</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> <span class="fu">id</span>          <span class="co">-- ((c + b) * (b + c)) * (G * b&#39;)</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>  sw2                  <span class="co">-- ((c + b) * G) * ((b + c) * b&#39;)</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> leftSwap       <span class="co">-- ((c + b) * G) * ((b&#39; + c) * b)</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>  swapT <span class="op">.*</span> swapT       <span class="co">-- (G * (c + b)) * (b * (b&#39; + c))</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>  assocT               <span class="co">-- ((G * (c + b)) * b) * (b&#39; + c)</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>  sym assocT <span class="op">.*</span> <span class="fu">id</span>     <span class="co">-- (G * ((c + b) * b)) * (b&#39; + c)</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">id</span> <span class="op">.*</span> swapT) <span class="op">.*</span> <span class="fu">id</span>  <span class="co">-- (G * (b * (c + b))) * (b&#39; + c)</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a><span class="ot">rightSide ::</span> c <span class="op">*</span> (h <span class="op">*</span> ((b <span class="op">+</span> c) <span class="op">*</span> (c <span class="op">+</span> b))) <span class="op">&lt;=&gt;</span> (h <span class="op">*</span> ((b <span class="op">+</span> c) <span class="op">*</span> c)) <span class="op">*</span> (b <span class="op">+</span> c)</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>rightSide <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>  swapT                <span class="co">-- c&#39; * (H * ((b + c) * (c + b)))</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>  assocT <span class="op">.*</span> <span class="fu">id</span>         <span class="co">-- ((H * (b + c)) * (c + b)) * c&#39;</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>  sym assocT           <span class="co">-- (H * (b + c)) * ((c + b) * c&#39;)</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> leftSwap       <span class="co">-- (H * (b + c)) * ((c&#39; + b) * c)</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="op">.*</span> swapT          <span class="co">-- (H * (b + c)) * (c * (c&#39; + b))</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>  assocT               <span class="co">-- ((H * (b + c)) * c) * (c&#39; + b)</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>  sym assocT <span class="op">.*</span> swapP  <span class="co">-- (H * ((b + c) * c)) * (b + c&#39;)</span></span></code></pre></div>
<hr />
<p>The home stretch is within sight. We have only two constructors of our arrow language left. We look first at <code>Create</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Create</span><span class="ot">  ::</span> <span class="dt">U</span> <span class="op">~&gt;</span> a</span></code></pre></div>
<p>Because we’ve done all of this work to thread through a heap in order to give us the ability to create values, the typing judgment should come as no surprise:</p>
<p><span class="math display">\[
\frac{}{\lifted{\text{create}}{a\times\u}{\u\times a}}
\]</span></p>
<p>Our heap contains the <code>a</code> we want, and we drop our incoming <code>U</code> as garbage. The implementation of this is obvious:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>lift <span class="dt">Create</span> <span class="ot">=</span> swapT</span></code></pre></div>
<hr />
<p>We’re left with <code>Erase</code>, whose type looks suspiciously like running <code>Create</code> in reverse:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Erase</span><span class="ot">  ::</span> a <span class="op">~&gt;</span> <span class="dt">U</span></span></code></pre></div>
<p>This is no coincidence; the two operations are duals of one another.</p>
<p><span class="math display">\[
\frac{}{\lifted{\text{erase}}{\u\times a}{a\times\u}}
\]</span></p>
<p>As expected, the implementation is the same as <code>Create</code>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>lift <span class="dt">Erase</span> <span class="ot">=</span> swapT</span></code></pre></div>
<p>And we’re done! We’ve now constructed a means of transforming any non-reversible program into a reversible one. Success!</p>
<h2 id="summary">Summary</h2>
<p>Still here? We’ve come a long way, which we’ll briefly summarize. In this paper, James and Sabry have taken us through the construction of a reversible language, given a proof that it’s Turing-complete, and given us some simple constructions on it. We set out on our own to implement lists and derived <code>map</code> for them.</p>
<p>We then constructed a non-reversible language (due to its capability to create and erase information), and then gave a transformation from this language to our earlier reversible language – showing that non-reversible computing is a special case of its reversible counterpart.</p>
<p>Information Effects ends with a short discussion of potential applications, which won’t be replicated here.</p>
<h2 id="commentary-on-the-physics">Commentary (on the physics)</h2>
<p>Assuming I understand the physics correctly (which I probably don’t), the fact that these reversible functions do not increase entropy implies that they should be capable of shunting information for near-zero energy. <a href="https://en.wikipedia.org/wiki/Landauer&#39;s_principle">Landauer’s Principle</a> and <a href="https://en.wikipedia.org/wiki/Entropy_in_thermodynamics_and_information_theory#Szilard.27s_engine">Szilard’s engine</a> suggests that information entropy and thermodynamic entropy are <em>one and the same</em>; if we don’t increase entropy in our computation of a function, there is nowhere for us to have created any heat.</p>
<p>That’s pretty remarkable, if you ask me. Together with our construction from any non-reversible program to a reversible one, it suggests we should be able to cut down on our CPU power usage by a significant order of magnitudes.</p>
<h2 id="commentary-on-where-to-go-from-here">Commentary (on where to go from here)</h2>
<p>An obvious limitation of what we’ve built here today is that it is first-order, which is to say that functions are not a first class citizen. I can think of no immediate problem with representing reversible functions in this manner. We’d need to move our <code>(&lt;=&gt;)</code> directly into the language.</p>
<p><code>id</code> would provide introduction of this type, and <code>(&gt;&gt;)</code> (transitivity) would allow us to create useful values of the type. We’d also need a new axiom:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> a <span class="op">*</span> (a <span class="op">&lt;=&gt;</span> b) <span class="op">&lt;=&gt;</span> b <span class="op">*</span> (b <span class="op">&lt;=&gt;</span> a)</span></code></pre></div>
<p>which would allow us to use our functions. We should also expect the following theorems (which may or may not be axioms) due to our iso language forming a cartesian closed category:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span><span class="ot">   ::</span> (a <span class="op">&lt;=&gt;</span> (b <span class="op">*</span> c)) <span class="op">&lt;=&gt;</span> (a <span class="op">&lt;=&gt;</span> b) <span class="op">*</span> (a <span class="op">&lt;=&gt;</span> c)</span></code></pre></div>
<p>Things that we’d expect to be theorems but are <strong>not</strong> are:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">terminal ::</span> <span class="dt">U</span> <span class="op">&lt;=&gt;</span> (a <span class="op">&lt;=&gt;</span> <span class="dt">U</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="ot">select   ::</span> a <span class="op">&lt;=&gt;</span> (<span class="dt">U</span> <span class="op">&lt;=&gt;</span> a)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="ot">coproduct ::</span> (a <span class="op">&lt;=&gt;</span> (b <span class="op">+</span> c)) <span class="op">&lt;=&gt;</span> (a <span class="op">&lt;=&gt;</span> b) <span class="op">+</span> (a <span class="op">&lt;=&gt;</span> c)</span></code></pre></div>
<p>due to the symmetry of <code>(&lt;=&gt;)</code>, both of these are equivalent to <code>create</code> and <code>erase</code>. I think the fact that these are not theorems despite <code>U</code> being the terminal object is that <code>(&lt;=&gt;)</code> requires arrows in both directions, but <code>U</code> only has incoming arrows.</p>

<p class="meta">
    <span class="prev">
        <a href="/blog/theorems-for-free">&larr;</a>
    </span>
    <span class="next">
        <a href="/blog/modeling-music">&rarr;</a>
    </span>
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js"
        repo="isovector/reasonablypolymorphic.com"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br/>POLYMORPHIC</a></h1>
    
        <p> Hi there. I'm <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I'd love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/blog/archives/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I'M DOING</h2>
        <ul>
            <li><a href="/erdos">Erdos Project</a></li>
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li>
        </ul>
    
        <p>
        &copy; 2015-2025 Sandy Maguire
        </p>
    </nav>

    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
</body>
</html>

