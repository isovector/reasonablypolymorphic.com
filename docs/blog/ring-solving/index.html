<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Automatic Ring Solving :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/ring-solving/index.html#">Automatic Ring Solving</a></h1>
</header>
<p class="meta">
    <time>2022-02-16</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <p>Todayâ€™s sorta-review is of <a href="https://github.com/oisdk/agda-ring-solver-report/blob/master/report.pdf">Automatically and Efficiently Illustrating Polynomial Equations in Agda</a> by <a href="https://doisinkidney.com/">Donnacha Oisin Kidney</a>. I say itâ€™s sorta a review because I had to write some annoying proofs recently, and discovered that Agda has a ring solver that automates annoying proofs. For example, it can solve things like <code>(a + b) * (a + b) = a^2 + 2*a*b + b^2</code>, which is rather amazing if you think about it. I got curious about how this is possible, and came across AaEIPEiA, quickly skimmed it for the rough approach, and then decided to write my own ring solver. As a result, this post is certainly inspired by AaEIPiA, but my implementation is extremely naive compared to the one presented in the paper. Kidneyâ€™s paper is very good, and I apologize for not doing it justice here.</p>
<p>So, some background. Agda lets you write types that correspond to equalities, and values of those types are proofs of those equalities. For example, we can write the following type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(</span>x <span class="ot">:</span> â„•<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> â‰¡ <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span></code></pre></div>
<p>You probably wouldnâ€™t write this for its own sake, but it might come up as a lemma of something else youâ€™re trying to prove. However, actually proving this equality is a huge amount of busywork, that takes forever, and isnâ€™t actually interesting because we all know that this equality holds. For example, the proof might look something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ *-+-distrib <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x <span class="dv">1</span> âŸ©</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ cong <span class="ot">(\</span>Ï† <span class="ot">-&gt;</span> <span class="ot">((</span>x + <span class="dv">1</span><span class="ot">)</span> * x + Ï†<span class="ot">))</span> $ *-1-id-r <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> âŸ©</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ cong <span class="ot">(\</span>Ï† <span class="ot">-&gt;</span> Ï† + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-comm <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x âŸ©</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    x * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ cong <span class="ot">(\</span>Ï† <span class="ot">-&gt;</span> Ï† + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-+-distrib x x <span class="dv">1</span> âŸ©</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x + x * <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ ? âŸ©</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- kill me</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ ? âŸ©</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  âˆŽ</span></code></pre></div>
<p>Itâ€™s SO MUCH WORK to do <em>nothing!</em> This is not an interesting proof! A ring solver lets us reduce the above proof to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  â‰¡âŸ¨ solve âŸ©</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  âˆŽ</span></code></pre></div>
<p>or, even more tersely:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  solve</span></code></pre></div>
<p>So thatâ€™s the goal here. Automate stupid, boring proofs so that we as humans can focus on the interesting bits of the problem.</p>
<h2 id="i-dont-even-know-what-a-ring-is"><a href="#i-dont-even-know-what-a-ring-is" class="header-link">I Donâ€™t Even Know What a Ring Is<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>Why is this called a ring solver? I donâ€™t exactly know, but a ring is some math thing. My guess is that itâ€™s the abstract version of an algebra containing addition and multiplication, with all the usual rules.</p>
<p>And looking at it, sure enough! A ring is a set with two monoids on it, one corresponding to addition, and the other to multiplication. Importantly, we require that multiplication distributes over addition.</p>
<p>Rings technically have additive inverses, but I didnâ€™t end up implementing (or needing them.) However, I did require commutativity of both addition and multiplication â€” more on this later.</p>
<p>The ring laws mean that algebra works in the way we expect arithmetic to work. We can shuffle things around, and probably all have enough experience solving these sorts of problems with pen and paper. But whatâ€™s the actual algorithm here?</p>
<h2 id="how-do-you-solve-a-ring"><a href="#how-do-you-solve-a-ring" class="header-link">How Do You Solve A Ring?<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>At first blush, this sounds like a hard problem! It feels like we need to see if thereâ€™s a way to turn some arbitrary expression into some other arbitrary expression. And that is indeed true, but itâ€™s made easier when you realize that polynomials have a normal form as a sum of products of descending powers. For example, this is in normal form:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>The problem thus simplifies to determining if two expressions have the same normal form. Thus, we can construct a proof that each expression is equal to its normal form, and then compose those proofs together to show the unnormalized forms are equal.</p>
<p>My implementation is naive, and only works for expressions with a single variable, but I think the approach generalizes if you can find a suitable normal form for multiple variables.</p>
<p>All of this sounds like a good tack, but the hard part is convincing ourselves (and perhaps more importantly, Agda,) that the stated relationship holds. As it happens, we require three equivalent types:</p>
<ul>
<li><code>A</code>, the ring weâ€™re actually trying to solve</li>
<li><code>Poly</code>, a syntactic representation of the ring operations</li>
<li><code>Horner</code>, the type of <code>A</code>-normal forms</li>
</ul>
<p><code>Poly</code> and <code>Horner</code> are indexed by <code>A</code>, but Iâ€™ve left that out for presentation purposes. Furthermore, theyâ€™re also both indexed by the degree of the polynomial, that is, the biggest power they contain. Iâ€™m not sure this was necessary, but it helped me make sure my math was right when I was figuring out how to multiply <code>Horner</code>s.</p>
<p>At a high level, solving a ring equality is really a statement about how <code>A</code> is related to <code>Poly</code> and <code>Horner</code>. We can construct an A-expression by substituting an <code>A</code> for all the variables in a <code>Poly</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Poly n <span class="ot">â†’</span> A <span class="ot">â†’</span> A</span></code></pre></div>
<p>and we can normalize any syntactic expression:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>normalize <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Poly n <span class="ot">â†’</span> Horner n</span></code></pre></div>
<p>thus we can solve a ring equation by hoisting a proof of equality of its normal forms into a proof of equality of its construction:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>solve</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>x y <span class="ot">:</span> Poly n<span class="ot">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> normalize x â‰¡ normalize y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> construct x a â‰¡ construct y a</span></code></pre></div>
<p>This approach is a bit underwhelming, since we need to explicitly construct syntactic objects (in <code>Poly</code>) corresponding to the expressions weâ€™re trying to solve (in <code>A</code>). But this is something we can solve with Agdaâ€™s macro system, by creating the <code>Poly</code>s by inspecting the actual AST, so weâ€™ll consider the approach good enough. Todayâ€™s post is about understanding how to do ring solving, not about how to engineer a nice user-facing interface.</p>
<p>The actual implementation of <code>solve</code> is entirely straight-forward:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>solve x y eq a <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  begin</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    construct x a             â‰¡âŸ¨ construct-is-normal x a âŸ©</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a  â‰¡âŸ¨ cong <span class="ot">(\</span>Ï† <span class="ot">â†’</span> evaluate Ï† a<span class="ot">)</span> eq âŸ©</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    evaluate <span class="ot">(</span>normalize y<span class="ot">)</span> a  â‰¡âŸ¨ sym $ construct-is-normal y a âŸ©</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    construct y a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  âˆŽ</span></code></pre></div>
<p>given a lemma that <code>construct</code> is equal to evaluating the normal form:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>construct-is-normal</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> â„•<span class="ot">}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> construct x a â‰¡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span></code></pre></div>
<p>The implementation of this is pretty straightforward too, requiring only that we have <code>+</code> and <code>*</code> homomorphisms between <code>Horner</code> and <code>A</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>+A-+H-homo</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a â‰¡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>*A-*H-homo</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a â‰¡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>These two lemmas turn out to be the hard part.</p>
<h2 id="but-first-types"><a href="#but-first-types" class="header-link">But First, Types<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>Before we get into all of that, letâ€™s first discuss what each of the types looks like. We have <code>Poly</code>, which again, is an initial encoding of the ring algebra:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Poly <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  con <span class="ot">:</span> A <span class="ot">â†’</span> Poly <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  var <span class="ot">:</span> Poly <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>:+<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Poly m <span class="ot">â†’</span> Poly n <span class="ot">â†’</span> Poly <span class="ot">(</span>m âŠ” n<span class="ot">)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">_</span>:*<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Poly m <span class="ot">â†’</span> Poly n <span class="ot">â†’</span> Poly <span class="ot">(</span>m + n<span class="ot">)</span></span></code></pre></div>
<p>We can reify the meaning of <code>Poly</code> by giving a transformation into <code>A</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Poly N <span class="ot">â†’</span> A <span class="ot">â†’</span> A</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>construct var a <span class="ot">=</span> a</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>p :+ p2<span class="ot">)</span> a <span class="ot">=</span> construct p a +A construct p2 a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>construct <span class="ot">(</span>p :* p2<span class="ot">)</span> a <span class="ot">=</span> construct p a *A construct p2 a</span></code></pre></div>
<p>Our other core type is <code>Horner</code>, which is an encoding of the Horner normal form of a polynomial:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Horner <span class="ot">:</span> â„• <span class="ot">â†’</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  PC <span class="ot">:</span> A <span class="ot">â†’</span> Horner <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  PX <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> A <span class="ot">â†’</span> Horner n <span class="ot">â†’</span> Horner <span class="ot">(</span>suc n<span class="ot">)</span></span></code></pre></div>
<p><code>Horner</code> requires some discussion. Horner normal form isnâ€™t the same normal form presented earlier, instead, itâ€™s a chain of linear multiplications. For example, we earlier saw this:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>in Horner normal form, this would be written as</p>
<pre><code>0 + x * (3 + x * 5)</code></pre>
<p>The idea is we can write any polynomial inductively by nesting the bigger terms as sums inside of multiplications against <code>x</code>. We can encode the above as a <code>Horner</code> like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>PX <span class="dv">0</span> <span class="ot">(</span>PX <span class="dv">3</span> <span class="ot">(</span>PC <span class="dv">5</span><span class="ot">))</span></span></code></pre></div>
<p>and then reify the meaning of <code>Horner</code> with respect to <code>A</code> via <code>evaluate</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Horner n <span class="ot">â†’</span> A <span class="ot">â†’</span> A</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">(</span>PC x<span class="ot">)</span> v <span class="ot">=</span> x</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>evaluate <span class="ot">(</span>PX x xs<span class="ot">)</span> v <span class="ot">=</span> x +A <span class="ot">(</span>v *A evaluate xs v<span class="ot">)</span></span></code></pre></div>
<h2 id="operations-on-horners"><a href="#operations-on-horners" class="header-link">Operations on Horners<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>We can define addition over <code>Horner</code> terms, which is essentially <code>zipWith (+A)</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Horner m <span class="ot">â†’</span> Horner n <span class="ot">â†’</span> Horner <span class="ot">(</span>m âŠ” n<span class="ot">)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PC <span class="ot">(</span>x +A y<span class="ot">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> ys</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> xs</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> <span class="ot">(</span>xs +H ys<span class="ot">)</span></span></code></pre></div>
<p>We can also implement scalar transformations over <code>Horner</code>, which is exactly a monomorphic <code>fmap</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>scalMapHorner <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>A <span class="ot">â†’</span> A<span class="ot">)</span> <span class="ot">â†’</span> Horner m <span class="ot">â†’</span> Horner m</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>scalMapHorner f <span class="ot">(</span>PC x<span class="ot">)</span> <span class="ot">=</span> PC <span class="ot">(</span>f x<span class="ot">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>scalMapHorner f <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>f x<span class="ot">)</span> <span class="ot">(</span>scalMapHorner f xs<span class="ot">)</span></span></code></pre></div>
<p>and finally, we can define multiplication over <code>Horner</code> terms:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> â„•<span class="ot">}</span> <span class="ot">â†’</span> Horner m <span class="ot">â†’</span> Horner n <span class="ot">â†’</span> Horner <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span> y <span class="ot">=</span> scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> y</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span> <span class="ot">=</span> scalMapHorner <span class="ot">(_</span>*A y<span class="ot">)</span> <span class="ot">(</span>PX x xs<span class="ot">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> yy <span class="ot">=</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> yy +H PX #0 <span class="ot">(</span>xs *H yy<span class="ot">)</span></span></code></pre></div>
<p>The first two cases here are straightforward, just <code>scalMapHorner</code>-multiply in the constant value and go on your way. The <code>PX-PX</code> case is rather complicated however, but corresponds to the <code>*-+-distrib</code> law:</p>
<pre><code>*-+-distrib : âˆ€ x xs yy â†’ (x + xs) * yy â‰¡ x * yy +A xs * yy</code></pre>
<p>We take advantage of the fact that we know <code>x</code> is a scalar, by immediately multiplying it in via <code>scalMapHorner</code>.</p>
<h2 id="tying-it-all-together"><a href="#tying-it-all-together" class="header-link">Tying it All Together<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>As alluded to earlier, all thatâ€™s left is to show <code>evaluate</code>-homomorphisms for <code>+H</code>/<code>+A</code> and <code>*H</code>/<code>*A</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>+A-+H-homo</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a â‰¡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>*A-*H-homo</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a â‰¡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>Thereâ€™s nothing interesting in these proofs, itâ€™s just three hundred ironic lines of tedious, boring proofs, of the sort that we are trying to automate away.</p>
<p>Given these, we can implement <code>construct-is-normal</code></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>construct-is-normal</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> â„•<span class="ot">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> construct x a â‰¡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> refl</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>construct-is-normal var a <span class="ot">=</span> refl</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>x :+ y<span class="ot">)</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> +A-+H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> refl</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>construct-is-normal <span class="ot">(</span>x :* y<span class="ot">)</span> a</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> *A-*H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="ot">=</span> refl</span></code></pre></div>
<p>Nice!</p>
<p>The homomorphism proofs are left as an exercise to the reader, or you can go look at the <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">code</a> if you want to skip doing it.</p>
<h2 id="agda-woes"><a href="#agda-woes" class="header-link">Agda Woes<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>My implementation isnâ€™t 100% complete, I still need to prove that <code>*H</code> is commutative:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>*H-comm <span class="ot">:</span> <span class="ot">âˆ€</span> j k <span class="ot">â†’</span> j *H k â‰¡ k *H j</span></code></pre></div>
<p>which shouldnâ€™t be hard, because it <em>is</em> commutative. Unfortunately, Agda has gone into hysterics, and wonâ€™t even typecheck the type of <code>*H-comm</code>, because it canâ€™t figure out that <code>m + n = n + m</code> (the implicit indices on the result of <code>*H</code>). As far as I can tell, there is no easy fix here; thereâ€™s some weird <code>cong</code>-like thing for types called <code>subst</code>, but it seems to infect a program and push these weird-ass constraints everywhere.</p>
<p>This is extremely frustrating, because itâ€™s literally the last thing to prove after 300 grueling lines of proof. And itâ€™s also true and isnâ€™t even hard to show. Itâ€™s just that I canâ€™t get Agda to accept the type of the proof because itâ€™s an idiot that doesnâ€™t know about additive commutativity. After a few hours of fighting with getting this thing to typecheck, I just said fuck it and postulated <code>*H-comm</code>.</p>
<p>Stupid Agda.</p>
<p>If you know what Iâ€™ve done wrong to deserve this sort of hell, please let me know. It would be nice to be able to avoid problems like this in the future, or resolve them with great ease.</p>
<h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion<span class="header-link-emoji">ðŸ”—</span></a></h2>
<p>So, thatâ€™s it! Modulo a postulate, weâ€™ve managed to implement a ring-solver by showing the equivalence of three different representations of the same data. Just to convince ourselves that it works:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>test-a <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>test-a <span class="ot">=</span> <span class="ot">(</span>var :+ con #1<span class="ot">)</span> :* <span class="ot">(</span>var :+ con #1<span class="ot">)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>test-b <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>test-b <span class="ot">=</span> var :* var :+ two :* var :+ con #1</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    two <span class="ot">=</span> con #1 :+ con #1</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>success</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">â†’</span> <span class="ot">(</span>x +A #1<span class="ot">)</span> *A <span class="ot">(</span>x +A #1<span class="ot">)</span> â‰¡ <span class="ot">(</span>x *A x<span class="ot">)</span> +A <span class="ot">(</span>#1 +A #1<span class="ot">)</span> *A x +A #1</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>success x <span class="ot">=</span> solve test-a test-b refl x</span></code></pre></div>
<p>which Agda happily accepts!</p>
<p>I donâ€™t exactly know offhand how to generalize this to multivariate polynomials, but I think the trick is to just find a normal form for them.</p>
<p>As usual, the code for this post is <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">available on Github.</a></p>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        Â© 2015-2023 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

