<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Review: Adders and Arrows :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/adders-and-arrows/index.html#">Review: Adders and Arrows</a></h1>
</header>
<p class="meta">
    <time>2022-01-07</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <p>This year my goal is to go through one paper a week, and produce some resulting artifact to help hammer in my understanding. Today’s paper is <a href="http://conal.net/">Conal Elliott’s</a>’s <a href="http://conal.net/papers/drafts/adders-and-arrows.pdf">Adders and Arrows</a>.</p>
<p>In my opinion, Adders and Arrows is an attempt to answer the questions “where do digital circuits come from?” and “how can we be convinced our digital circuits do what they claim?” by focusing on the concrete case of adders. What’s quite remarkable to me is that the paper takes 17 pages to build up to the “known” ripple-carry adder, which is essentially day 1 of any digital circuitry class. This feels a bit ridiculous at first blush, but immediately pays off for itself by using the same machinery to derive a carry-forward adder. Carry-forward adders come like a week later in circuitry class, and are completely unrelated to ripple-carry adders, but Elliott derives them essentially for free. He then gives a third variation on the theme, which is a ripple-carry adder <em>in time,</em> rather than space, and again gets it in one page.</p>
<p>So that’s the impressive stuff. What’s also important is that the paper doesn’t require us to trust that the corresponding circuits do what they claim — the underlying machinery passes around a big chain of equivalence proofs, which automatically get composed and witness that addition over the naturals is a model for each circuit.</p>
<p>Something I really liked about this paper is that it’s the first time I’ve ever gotten a glimpse of why it might be valuable to understand category theory. It’s not just good for classifying things! Turns out you can do cool things with it too. But nobody who teaches it ever says that.</p>
<p>The paper itself is only a draft, and it shows in several places. Notably, the core abstraction (the arrow category) is missing, and the paper ends extremely abruptly. After some spelunking, I managed to track down the implementation of the arrow category, and was pleased to realize I’d already implemented it independently.</p>
<p>We’ll proceed section by section.</p>
<h2 id="section-1-a-model-of-addition"><a href="#section-1-a-model-of-addition" class="header-link">Section 1: A model of addition<span class="header-link-emoji">🔗</span></a></h2>
<p>Section 1 gives us a model of the natural numbers via the Peano encoding, and also defines addition. It drives home the point that this unary encoding is only the model of our computation — its specification — and not the actual implementation. This is a common theme in Elliott’s work: “how do we even know what question we’re trying to answer?” We know by posing the dumbest possible model of the problem, and then proving any actual solution to the problem is equivalent. He stresses that the “dumbest possible” thing is an important quality — this is the only part of the problem we get no checks or balances on, so our only hope is to make it so simple that we can’t screw it up.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Nat <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  zero <span class="ot">:</span> Nat</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  suc  <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Nat</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>zero  + n <span class="ot">=</span> n</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>suc m + n <span class="ot">=</span> suc <span class="ot">(</span>m + n<span class="ot">)</span></span></code></pre></div>
<p>Because arbitrary categories don’t support currying, we can uncurry addition, which will come in handy later:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>&lt;+&gt; <span class="ot">:</span> Nat2 <span class="ot">-&gt;</span> Nat</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>&lt;+&gt; <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">=</span> x + y</span></code></pre></div>
<h2 id="section-2-bounded-numbers"><a href="#section-2-bounded-numbers" class="header-link">Section 2: Bounded numbers<span class="header-link-emoji">🔗</span></a></h2>
<p>Section 2 is defines the <code>Fin</code>iteary numbers, which are natural numbers guaranteed to be smaller than a given upper bound.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> Fin <span class="ot">:</span> N <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></span></code></pre></div>
<p>Thus, <code>Fin 2</code> is the type of binary digits, and <code>Fin 10</code> is that of decimal digits.</p>
<p>Elliott gives us an observation of <code>Fin</code> in terms of <code>Nat</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>toN <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Nat</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>toN zero    <span class="ot">=</span> zero</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>toN <span class="ot">(</span>suc f<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toN f<span class="ot">)</span></span></code></pre></div>
<p>We’d like to find a model-preserving implementation of <code>+</code> over <code>Fin</code> (let’s call it <code>&lt;+F&gt;</code>.) But what does model-preserving meaning? As usual, the answer is “homomorphism”, and namely, that the following square must commute:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>&lt;+&gt; <span class="ot">.</span> bimap toN toN <span class="ot">=</span> toN <span class="ot">.</span> &lt;+F&gt;</span></code></pre></div>
<p>The paper says “solving this equation for <code>&lt;+F&gt;</code> yields the following recursive definition.” It’s unclear if this answer was “solved for” in the sense of being manipulated algebraically, or if it just happens to be a solution to the problem. I hope it’s the former, because I would love to see how to do that, but I suspect it’s the latter. Anyway, the definition of <code>_+F_</code> is given below, plus the work I needed to do to get everything to typecheck.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>n+suc <span class="ot">:</span> <span class="ot">(</span>n m <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> n + suc m == suc <span class="ot">(</span>n + m<span class="ot">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>n+suc zero m <span class="ot">=</span> refl</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>n+suc <span class="ot">(</span>suc n<span class="ot">)</span> m <span class="kw">rewrite</span> n+suc n m <span class="ot">=</span> refl</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>weaken <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">(</span>y <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>weaken <span class="ot">{</span>zero<span class="ot">}</span> y <span class="ot">=</span> y</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>weaken <span class="ot">{</span>suc m<span class="ot">}</span> zero <span class="ot">=</span> zero</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>weaken <span class="ot">{</span>suc m<span class="ot">}</span> <span class="ot">{</span>suc n<span class="ot">}</span> <span class="ot">(</span>suc y<span class="ot">)</span> <span class="kw">rewrite</span> n+suc m n <span class="ot">=</span> suc <span class="ot">(</span>weaken y<span class="ot">)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="ot">_</span>+F<span class="ot">_</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">{</span>m<span class="ot">}</span> zero y <span class="ot">=</span> weaken y</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">{</span>suc <span class="ot">_}</span> <span class="ot">(</span>suc x<span class="ot">)</span> y <span class="ot">=</span> suc <span class="ot">(</span>x +F y<span class="ot">)</span></span></code></pre></div>
<p>Something that ended up challenging me here was that Elliott uses extensional equality of functions for his commutative diagrams, but my implementation of arrow categories (coming up) requires a propositional equality. I got around the problem by postulating extensionality (which I stole from McBride), and then by defining a type-alias for extensional equality that plays well with <code>extensionality</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">postulate</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  extensionality <span class="ot">:</span> <span class="ot">{</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{</span>T <span class="ot">:</span> S <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">{</span>f g <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> S<span class="ot">)</span> <span class="ot">-&gt;</span> T x<span class="ot">}</span> <span class="ot">-&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">((</span>x <span class="ot">:</span> S<span class="ot">)</span> <span class="ot">-&gt;</span> f x == g x<span class="ot">)</span> <span class="ot">-&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                   f == g</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">1</span> <span class="ot">_</span>=o=<span class="ot">_</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>=o=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>=o=<span class="ot">_</span> <span class="ot">{</span>A<span class="ot">}</span> f g <span class="ot">=</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">-&gt;</span> f x == g x</span></code></pre></div>
<p>and then we can give <em>most</em> (it’s hard to prove things, OK?) of the proof for the commutative diagram:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>toN-weaken <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>y <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">-&gt;</span> toN <span class="ot">(</span>weaken <span class="ot">{</span>m<span class="ot">}</span> y<span class="ot">)</span> == toN y</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>toN-weaken <span class="ot">{</span>zero<span class="ot">}</span> y <span class="ot">=</span> refl</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> zero <span class="ot">=</span> refl</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> ?</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>toN-+F <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN <span class="ot">{</span>m + n<span class="ot">}</span> ∘ &lt;+F&gt; =o= &lt;+&gt; ∘ toN2 <span class="ot">{</span>suc m , n<span class="ot">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>toN-+F <span class="ot">{</span>zero , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span> <span class="ot">=</span> refl</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>toN-+F <span class="ot">{</span>suc m , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>m , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> y <span class="ot">=</span> refl</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>toN-+F <span class="ot">{</span>suc m , n<span class="ot">}</span> <span class="ot">(</span>suc x , y<span class="ot">)</span> <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>m , n<span class="ot">}</span> <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<h2 id="section-3-the-arrow-category"><a href="#section-3-the-arrow-category" class="header-link">Section 3: The arrow category<span class="header-link-emoji">🔗</span></a></h2>
<p>Section 3 presents the fact that we can bundle up the commutative diagram with its proof into an object. Unfortunately, it only gives the <em>barest hint</em> about how to actually go about doing that. I’m presenting here what I think it is, but if something goes wrong in the rest of the paper, here’s where the problem is.</p>
<p>The paper is keen to point out that we have five things we’re bundling together:</p>
<ol type="1">
<li>A mapping from implementation input to specification input.</li>
<li>A mapping from implementation output to specification output.</li>
<li>An implementation.</li>
<li>A specification.</li>
<li>A proof that the square commutes.</li>
</ol>
<p>Colloquially, I’d call the first two points our “observations” of the system.</p>
<p>The idea is, we’d like to bundle all of these things together, ideally in some sort of composable packaging. Composable usually means categorical, so we should look at our old friend <code>SET</code>, the category whose objects are types and arrows are functions. By itself, <code>SET</code> doesn’t give us any of the machinery we’d want for thinking about commutative squares. So instead, we’ll construct the arrow category over <code>SET</code>. Let’s call it <code>&gt;-SET-&gt;</code>.</p>
<p>But what is the arrow category? The paper is quiet on this front, but my understanding is that it transforms the <em>arrows</em> in <code>SET</code> into <em>objects</em> in <code>&gt;-SET-&gt;</code>. An arrow in <code>&gt;-SET-&gt;</code> is thus a pair of arrows in <code>SET</code> which form a commutative square. For example, consider the arrows in <code>SET</code>:</p>
<pre><code>Fin n x Fin n        Nat x Nat
      |                  |
      | &lt;+F&gt;             | &lt;+&gt;
      v                  v
    Fin n               Nat</code></pre>
<p>In <code>&gt;-SET-&gt;</code>, these are just two objects, and a morphism between them is something that makes the whole square commute. In <code>&gt;-SET-&gt;</code>:</p>
<pre><code>       bimap toNat toNat
&lt;+F&gt;  ------------------&gt;  &lt;+&gt;
             toNat</code></pre>
<p>and again in <code>SET</code>:</p>
<pre><code>                bimap toNat toNat
Fin n x Fin n  ------------------&gt; Nat x Nat
      |                                |
      | &lt;+F&gt;                           | &lt;+&gt;
      v               toNat            v
    Fin n      ------------------&gt;    Nat</code></pre>
<p>So we can consider the arrow category to be a “view” on its underlying category, like how databases present views over their data. The arrow category lets us talk about arrows directly, and <em>ensures</em> the commutativity of any constructions we’re able to form. As such, it’s a natural fit for our purposes of specification — we are literally unable to construct any arrows in <code>&gt;-SET-&gt;</code> which violate our specification.</p>
<h3 id="building-categories"><a href="#building-categories" class="header-link">Building Categories<span class="header-link-emoji">🔗</span></a></h3>
<p>How do we go about actually building an arrow category? First, some preliminaries to build a category:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Category <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">infix</span> <span class="dv">6</span> <span class="ot">_</span>~&gt;<span class="ot">_</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    Obj <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>~&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>A B <span class="ot">:</span> Obj<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    id <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">-&gt;</span> A ~&gt; A</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">_</span>&gt;&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">-&gt;</span> A ~&gt; B <span class="ot">-&gt;</span> B ~&gt; C <span class="ot">-&gt;</span> A ~&gt; C</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    id-l <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span> <span class="ot">-&gt;</span> id &gt;&gt; f == f</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    id-r <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span> <span class="ot">-&gt;</span> f &gt;&gt; id == f</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    &gt;&gt;-assoc <span class="ot">:</span> <span class="ot">{</span>A B C D <span class="ot">:</span> Obj<span class="ot">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>               <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="ot">(</span>g <span class="ot">:</span> B ~&gt; C<span class="ot">)</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="ot">(</span>h <span class="ot">:</span> C ~&gt; D<span class="ot">)</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> f &gt;&gt; <span class="ot">(</span>g &gt;&gt; h<span class="ot">)</span> == <span class="ot">(</span>f &gt;&gt; g<span class="ot">)</span> &gt;&gt; h</span></code></pre></div>
<p>And I have some syntactic sugar for dealing with arrows and composition in an arbitrary category:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">5</span> <span class="ot">_</span>[<span class="ot">_</span>,<span class="ot">_</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>[<span class="ot">_</span>,<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">(</span>C <span class="ot">:</span> Category<span class="ot">)</span> <span class="ot">-&gt;</span> Obj C <span class="ot">-&gt;</span> Obj C <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>C [ X , Y ] <span class="ot">=</span> <span class="ot">_</span>~&gt;<span class="ot">_</span> C X Y</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">5</span> <span class="ot">_</span>[<span class="ot">_</span>&gt;&gt;<span class="ot">_</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>[<span class="ot">_</span>&gt;&gt;<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">(</span>C <span class="ot">:</span> Category<span class="ot">)</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="ot">{</span>X Y Z <span class="ot">:</span> Obj C<span class="ot">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> C [ X , Y ]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> C [ Y , Z ]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> C [ X , Z ]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>C [ f &gt;&gt; g ] <span class="ot">=</span> <span class="ot">_</span>&gt;&gt;<span class="ot">_</span> C f g</span></code></pre></div>
<p>With this, we can describe an arrow in <code>SET</code> via <code>SET [ A , B ]</code>, and composition via <code>SET [ foo &gt;&gt; bar ]</code>.</p>
<h3 id="building-arrow-categories"><a href="#building-arrow-categories" class="header-link">Building arrow categories<span class="header-link-emoji">🔗</span></a></h3>
<p>An arrow category is parameterizd by the category whose arrows form its objects:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ARROW</span> (<span class="dt">C</span> <span class="op">:</span> <span class="dt">Category</span>) <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  open <span class="dt">Category</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  open _<span class="ot">=&gt;</span>_</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  record <span class="dt">ArrowObj</span> <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    constructor arrow<span class="op">-</span>obj</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    field</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>      {alpha} <span class="op">:</span> <span class="dt">Obj</span> <span class="dt">A</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      {beta}  <span class="op">:</span> <span class="dt">Obj</span> <span class="dt">B</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      hom <span class="op">:</span> <span class="dt">C</span> [ alpha , beta ]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  open <span class="dt">ArrowObj</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  record <span class="dt">ArrowArr</span> (<span class="dt">X</span> <span class="dt">Y</span> <span class="op">:</span> <span class="dt">ArrowObj</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    constructor arrow<span class="op">-</span>hom</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    field</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>      f <span class="op">:</span> <span class="dt">A</span> [ <span class="dt">X</span> <span class="op">.</span>alpha , <span class="dt">Y</span> <span class="op">.</span>alpha ]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>      g <span class="op">:</span> <span class="dt">B</span> [ <span class="dt">X</span> <span class="op">.</span>beta , <span class="dt">Y</span> <span class="op">.</span>beta ]</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>      commute <span class="op">:</span> <span class="dt">C</span> [ f <span class="op">&gt;&gt;</span> <span class="dt">Y</span> <span class="op">.</span>hom ] <span class="op">==</span> <span class="dt">C</span> [ <span class="dt">X</span> <span class="op">.</span>hom <span class="op">&gt;&gt;</span> g ]</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Arrow</span> <span class="op">:</span> <span class="dt">Category</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Obj</span> <span class="dt">Arrow</span> <span class="ot">=</span> <span class="dt">ArrowObj</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>  _<span class="op">~&gt;</span>_ <span class="dt">Arrow</span> <span class="ot">=</span> <span class="dt">ArrowArr</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span></code></pre></div>
<p>My implementation for <code>Arrow</code> is actually in terms of the arrow category, which is the same idea except it does some functor stuff. In the code accompanying this post, <code>ARROW {c}</code> is implemented as <code>COMMA {c} ID=&gt; ID=&gt;</code> where <code>ID=&gt;</code> is the identity functor.</p>
<h3 id="back-to-section-3"><a href="#back-to-section-3" class="header-link">Back to section 3<span class="header-link-emoji">🔗</span></a></h3>
<p>For convenience, the paper implicitly defines a type synonym for constructing arrows in the arrow category. This is called <code>_⮆_</code> in the paper, but I hate unicode, so mine is defined as <code>=&gt;&gt;</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infix</span> <span class="dv">0</span> <span class="ot">_</span>=&gt;&gt;<span class="ot">_</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>=&gt;&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>s1 t1 <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">{</span>s2 t2 <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>s1 <span class="ot">-&gt;</span> s2<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t1 <span class="ot">-&gt;</span> t2<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>g =&gt;&gt; h <span class="ot">=</span> ArrowArr <span class="ot">(</span>arrow-obj g<span class="ot">)</span> <span class="ot">(</span>arrow-obj h<span class="ot">)</span></span></code></pre></div>
<p>With all of this machinery in place, we’re now ready to continue on the paper. We can construct a morphism in the arrow category corresponding to the fact that <code>&lt;+&gt;</code> is a model for <code>&lt;+F&gt;</code>, as witnessed by <code>toN-+F</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>+=&gt;&gt; <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat × Nat<span class="ot">}</span> <span class="ot">-&gt;</span> toN2 <span class="ot">{</span> suc m , n <span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span> m + n <span class="ot">}</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>+=&gt;&gt; <span class="ot">=</span> arrow-hom &lt;+F&gt; &lt;+&gt; $ extensionality toN-+F</span></code></pre></div>
<p>Again, the necessity of <code>extensionality</code> here is a byproduct of me not having parameterized my <code>Category</code> by a notion of equivalence. The arrow category wants to use extensional equality, but I’ve hard-baked in propositional equality, and didn’t have time to fix it before my deadline to get this post out.</p>
<p>Although not presented in the paper, arrow categories also have a notion of “transposition,” corresponding to flipping which arrows (in <code>SET</code>) lay on the horizontal and vertical axes. Because <code>_=&gt;&gt;_</code> names two arrows, leaving the other two implicit, transposition changes the type of our arrows — making the implicit ones explicit and vice versa. We’ll need this later in section 7.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>transpose <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> CommaObj<span class="ot">}</span> <span class="ot">((</span>comma-hom f g <span class="ot">_)</span> <span class="ot">:</span> CommaArr A B<span class="ot">)</span> <span class="ot">-&gt;</span> f =&gt;&gt; g</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>transpose <span class="ot">{</span>comma-obj h<span class="ot">}</span> <span class="ot">{</span>comma-obj h&#39;<span class="ot">}</span> <span class="ot">(</span>comma-hom f g p<span class="ot">)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> comma-hom h h&#39; <span class="ot">(</span>sym p<span class="ot">)</span></span></code></pre></div>
<p>As an aside, it’s super cool that Agda can do this sort of pattern matching in a type signature.</p>
<h2 id="section-4-carry-in"><a href="#section-4-carry-in" class="header-link">Section 4: Carry-in<span class="header-link-emoji">🔗</span></a></h2>
<p>In order to make non-unary adders compositional, we need to support carrying-in. The play is familiar. Define what we want (the specifiation) over the naturals, write it over <code>Fin</code>, and then give an equivalence proof. The paper defines some type synonyms:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Nat3 <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>Nat3 <span class="ot">=</span> Nat × Nat2</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>Fin3 <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>Fin3 <span class="ot">(</span>m , n<span class="ot">)</span> <span class="ot">=</span> Fin m × Fin2 n</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>toN3 <span class="ot">:</span> <span class="ot">{(</span>c , m , n<span class="ot">)</span> <span class="ot">:</span> Nat3<span class="ot">}</span> <span class="ot">-&gt;</span> Fin3 <span class="ot">(</span>c , m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Nat3</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>toN3 <span class="ot">(</span>c , mn<span class="ot">)</span> <span class="ot">=</span> toN c , toN2 mn</span></code></pre></div>
<p>(where <code>Nat2</code> and <code>Fin2</code> are exactly what you’d expect.)</p>
<p>It’s easy to define the specification (<code>addN</code>), and implementation (<code>addF</code>), and the proof is trivial too:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>addN <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> Nat</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>addN <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c + a + b</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>addF <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> Fin3 <span class="ot">(</span><span class="dv">2</span> , m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>addF <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c +F a +F b</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>toN-addF <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>mn<span class="ot">@(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">→</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>     SET [ addF &gt;&gt; toN ] =o= SET [ toN3 &gt;&gt; addN ]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>toN-addF <span class="ot">{</span>mn<span class="ot">}</span> <span class="ot">(</span>c , a , b<span class="ot">)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>mn<span class="ot">}</span> <span class="ot">(</span>c +F a , b<span class="ot">)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="ot">|</span> toN-+F <span class="ot">(</span>c , a<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>Bundling these up into an arrow proves that <code>addN</code> is a model for <code>addF</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>add=&gt;&gt;0 <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN3 <span class="ot">{</span><span class="dv">2</span> , m , n<span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span>m + n<span class="ot">}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>add=&gt;&gt;0 <span class="ot">=</span> comma-hom addF addN $ extensionality toN-addF</span></code></pre></div>
<p>The paper also makes clear that we can show that <code>&lt;+&gt;</code> is a model for <code>addN</code> via <code>carryIn</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>carryIn <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> Nat2</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>carryIn <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c + a , b</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>addN=&gt;&gt; <span class="ot">:</span> carryIn =&gt;&gt; id <span class="ot">{</span>A <span class="ot">=</span> Nat<span class="ot">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>addN=&gt;&gt; <span class="ot">=</span> comma-hom addN &lt;+&gt; refl</span></code></pre></div>
<h2 id="commentary"><a href="#commentary" class="header-link">Commentary<span class="header-link-emoji">🔗</span></a></h2>
<p>At this point, it’s starting to become clear what this paper is really <em>about.</em> The idea is that we specify super simple pieces, and then build slightly more complicated things, showing equivalence to the last piece we built. In this way, we can slowly derive complexity. Not only does it give us a fool-proof means of getting results, but it also means we can reuse the proof work. As someone whose first real project in Agda was to implement and prove the correctness of a few adders, this is a godsend. I wrote a ripple-carry adder, but was unable to use my half-adder proof to prove it correctly implements addition. And then I had to throw all of that work away when I wanted to subsequently write and prove a carry-forward adder.</p>
<h2 id="section-5-category-stuff"><a href="#section-5-category-stuff" class="header-link">Section 5: Category stuff<span class="header-link-emoji">🔗</span></a></h2>
<p>This section shows we went through too much effort to implement <code>add=&gt;&gt;0</code>. Really what’s going on here is we’re doing three things in a row, for the specification, implementation and proof. First, we’re reassociating the tuple, from <code>N x (N x N)</code> to <code>(N x N) x N</code>. Then we’re doing addition on the first element of the pair, and then doing addition on the resulting pair.</p>
<p>This is all stuff you can do in any category with all finite products. But I was too lazy to implement that in full generality, so I hard-coded it. Because arrow categories lift products, and in <code>SET</code> products are just the product type, it’s easy to implement categorical objects:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>×C<span class="ot">_</span> <span class="ot">:</span> Obj Comma <span class="ot">-&gt;</span> Obj Comma <span class="ot">-&gt;</span> Obj Comma</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>×C<span class="ot">_</span> <span class="ot">(</span>comma-obj <span class="ot">{</span>A1<span class="ot">}</span> <span class="ot">{</span>B1<span class="ot">}</span> f<span class="ot">)</span> <span class="ot">(</span>comma-obj <span class="ot">{</span>A2<span class="ot">}</span> <span class="ot">{</span>B2<span class="ot">}</span> g<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  comma-obj <span class="ot">{</span>A1 × A2<span class="ot">}</span> <span class="ot">{</span>B1 × B2<span class="ot">}</span> <span class="ot">λ</span> <span class="ot">{</span> <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>f x , g y<span class="ot">)</span> <span class="ot">}</span></span></code></pre></div>
<p>And then we can implement <code>first</code> and <code>assoc</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>first <span class="ot">:</span>  <span class="ot">{</span>A B X <span class="ot">:</span> Obj Comma<span class="ot">}</span> <span class="ot">-&gt;</span> Comma [ A , B ] <span class="ot">-&gt;</span> Comma [ <span class="ot">(</span>A ×C X<span class="ot">)</span> , <span class="ot">(</span>B ×C X<span class="ot">)</span> ]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>first <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">{</span>X<span class="ot">}</span> <span class="ot">(</span>comma-hom f g p<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  comma-hom <span class="ot">(</span>do-first f<span class="ot">)</span> <span class="ot">(</span>do-first g<span class="ot">)</span> $ cong <span class="ot">(\</span>k <span class="ot">(</span>a , x<span class="ot">)</span> <span class="ot">-&gt;</span> k a , xf x<span class="ot">)</span> p</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    do-first <span class="ot">:</span> <span class="ot">{</span>A B X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> A × X <span class="ot">-&gt;</span> B × X</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    do-first f <span class="ot">=</span> <span class="ot">(λ</span> <span class="ot">{</span> <span class="ot">(</span>a , x<span class="ot">)</span> <span class="ot">→</span> f a , x <span class="ot">})</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>assoc <span class="ot">:</span> <span class="ot">{</span>A B X <span class="ot">:</span> Obj Comma<span class="ot">}</span> <span class="ot">-&gt;</span> Comma [ A ×C <span class="ot">(</span>B ×C X<span class="ot">)</span> , <span class="ot">(</span>A ×C B<span class="ot">)</span> ×C X ]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>assoc <span class="ot">=</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  comma-hom reassoc reassoc ?</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    reassoc <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> A × <span class="ot">(</span>B × C<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A × B<span class="ot">)</span> × C</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    reassoc <span class="ot">=</span> <span class="ot">(λ</span> <span class="ot">{</span> <span class="ot">(</span>a , b , c<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>a , b<span class="ot">)</span> , c <span class="ot">})</span></span></code></pre></div>
<p>where the proof is left as an exercise to the reader :)</p>
<p>We can now implement <code>add=&gt;&gt;</code> more succinctly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>add=&gt;&gt; <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN3 <span class="ot">{</span><span class="dv">2</span> , m , n<span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span>m + n<span class="ot">}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>add=&gt;&gt; <span class="ot">=</span> Comma [ Comma [ assoc &gt;&gt; first +=&gt;&gt; ] &gt;&gt; +=&gt;&gt; ]</span></code></pre></div>
<p>While this is cool, I must admit I’m a little confused. Do <code>first</code> and <code>assoc</code> have most-general types when expressd via <code>_=&gt;&gt;_</code>? Thinking aloud here, I think not. Using the <code>_=&gt;&gt;_</code> notation is for choosing two <em>particular</em> morphisms in <code>SET</code>, while using the more general <code>COMMA [ X , Y ]</code> is for <em>any</em> pair morphisms in <code>SET</code> with the right type. But I’m not confident about this.</p>
<h2 id="section-6-carrying-out"><a href="#section-6-carrying-out" class="header-link">Section 6: Carrying out<span class="header-link-emoji">🔗</span></a></h2>
<p>Carry-in is great, but what about going the other direction?</p>
<p>Elliott starts by makig the following observation: if we fix <code>m = n</code>, then the type of our finitary adder is <code>Fin2 (m , m) -&gt; Fin (m + m)</code>, which we can rewrite the codomain as <code>Fin (2 * m)</code> and then reinterpret as <code>Fin 2 x Fin m</code>. That is to say, the type of finitary adding is to output a single digit in base <code>m</code>, and a bit corresponding to whether or not a carry occurred. This is a great little reminder in the value of type isomorphisms. How cool is it that we can get carry-outs for free just with some algebraic manipulations?</p>
<p>Of course, the trick is to prove it. Start by defining two helper type synonyms:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>CarryIn <span class="ot">:</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>CarryIn m <span class="ot">=</span> Fin3 <span class="ot">(</span><span class="dv">2</span> , m , m<span class="ot">)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>CarryOut <span class="ot">:</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>CarryOut m <span class="ot">=</span> Fin2 <span class="ot">(</span><span class="dv">2</span> , m<span class="ot">)</span></span></code></pre></div>
<p>Elliott presents the following “puzzle” of a commutative diagram:</p>
<pre><code>              addF
CarryIn m   --------&gt; Fin (m + m)
   ^                      ^
id |                      | ?
   |           ?          |
CarryIn m   --------&gt; Fin (2 * m)
   ^                      ^
id |                      | ?
   |           ?          |
CarryIn m   --------&gt; CarryOut m</code></pre>
<p>It’s unclear how exactly one formulates these diagrams in the first place. I guess the top is pinned by <code>addF</code>, while the bottom corners are pinned by our desired carrying out. The middle is thus the isomorphism presented immediately before this. All of that makes sense, but I’m not convinced I could reproduce it on my own yet.</p>
<p>So the game now is to fill in the question marks. I don’t know how to get Agda to help me with this, so I’m just going to try literally putting question marks in and seeing what happens. When doing that, we get this:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>puzzle1 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>   <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                , comma-obj <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> <span class="ot">{</span>Fin <span class="ot">(</span>m + m<span class="ot">)}</span> ?</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>                ]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>puzzle1 <span class="ot">=</span> comma-hom ? addF ?</span></code></pre></div>
<p>Figuring out the first question-mark is simple enough, it’s an isomorphism on <code>Fin</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>n+zero <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> n + zero == n</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>n+zero zero <span class="ot">=</span> refl</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>n+zero <span class="ot">(</span>suc n<span class="ot">)</span> <span class="kw">rewrite</span> n+zero n <span class="ot">=</span> refl</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>2*m==m+m <span class="ot">:</span> <span class="ot">(</span>m <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)</span> == m + m</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>2*m==m+m zero <span class="ot">=</span> refl</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>2*m==m+m <span class="ot">(</span>suc m<span class="ot">)</span> <span class="kw">rewrite</span> 2*m==m+m m <span class="ot">|</span> n+zero m <span class="ot">=</span> refl</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>castF <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>m == n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin m <span class="ot">-&gt;</span> Fin n</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>castF p <span class="kw">rewrite</span> p <span class="ot">=</span> id</span></code></pre></div>
<p>Our first hole is thus <code>cast $ 2*m==m+m m</code>. Interestingly, this doesn’t refine our other hole, since it’s already fully specified by the vertial components of <code>idA</code> and the horizontal component of <code>addF</code>. However, as the paper points out, we can get the second hole for free. Because <code>cast</code> is invertable, we can make this square commute by taking <code>id &gt;&gt; addF &gt;&gt; cast-1</code>. It feels a bit like cheating, but it does indeed satisfy the commutativity diagram:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>puzzle1 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>   <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                , comma-obj <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> <span class="ot">{</span>Fin <span class="ot">(</span>m + m<span class="ot">)}</span> <span class="ot">(</span>cast $ 2*m==m+m m<span class="ot">)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                ]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>puzzle1 <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  comma-hom</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>SET [ addF &gt;&gt; cast $ sym $ 2*m==m+m m ]<span class="ot">)</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    addF</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    ?</span></code></pre></div>
<p>where the proof is trivial (but I don’t know how to make it terse):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>   SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; cast $ 2*m==m+m m ]</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>== SET [ id &gt;&gt; addF ]</span></code></pre></div>
<p>Probably there is a category of proofs, where I can just do <code>reassoc &gt;&gt; second sym (sym-is-id $ 2*m==m+m m) &gt;&gt; id-r addF &gt;&gt; sym (id-l addF)</code>. But I don’t have that setup, and this would be annoying to do in the equational reasoning style. So it remains a hole, and you, gentle reader, can fill it in if you are keen. Also, I’d love to know how to write a proof as simple as my sketch above.</p>
<p>So that gives us the first half of our puzzle. Now that we have the middle arrow, let’s play the same game:</p>
<pre><code>                          addF
CarryIn m   -------------------------------&gt; Fin (m + m)
   ^                                           ^
id |                                           | cast $ 2*m==m+m m
   |                                           |
   |          addF &gt;&gt; cast (sym (2*m==m+m m))  |
CarryIn m   -------------------------------&gt; Fin (2 * m)
   ^                                           ^
id |                                           | ?
   |                       ?                   |
CarryIn m   -----------------------------&gt; CarryOut m</code></pre>
<p>So how do we turn a <code>CarryOut m = Fin2 (2 , m)</code> into a <code>Fin (2 * m)</code>? Algebraically I think this is a bit tricky, but thankfully <code>Data.Fin.Base</code> has us covered:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>combine <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>n k<span class="ot">}</span> <span class="ot">→</span> Fin n <span class="ot">→</span> Fin k <span class="ot">→</span> Fin <span class="ot">(</span>n * k<span class="ot">)</span></span></code></pre></div>
<p>which we can uncurry:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>comb <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin2 <span class="ot">(</span>m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m * n<span class="ot">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>comb <span class="ot">(</span>f1 , f2<span class="ot">)</span> <span class="ot">=</span> combine f1 f2</span></code></pre></div>
<p>and then use this to fill in the vertical arrow. Because <code>comb</code> is one half of an isomorphism (the other half is formed by <code>remQuot : ∀ {n} k → Fin (n * k) → Fin n × Fin k</code>), we can do the same trick to get the horizontal arrow for free:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>puzzle2 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>  <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>               , comma-obj <span class="ot">{</span>CarryOut m<span class="ot">}</span> <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> comb</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>               ]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>puzzle2 <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  comma-hom</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; remQuot m ]<span class="ot">)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">(</span>SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ]<span class="ot">)</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    ?</span></code></pre></div>
<p>The proof is again trivial but verbose.</p>
<p>Let’s call the implementation arrow <code>addCarry</code>, because we’ll need it in section 8.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>addCarry <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> SET [ CarryIn m , CarryOut m ]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>addCarry <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; remQuot m ]</span></code></pre></div>
<h2 id="section-7-vertical-composition"><a href="#section-7-vertical-composition" class="header-link">Section 7: Vertical composition<span class="header-link-emoji">🔗</span></a></h2>
<p>Finally, we can use <em>vertical</em> composition to combine our two puzzles:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>puzzle <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> id =&gt;&gt; <span class="ot">(</span>cast <span class="ot">(</span>2*m==m+m m<span class="ot">)</span> ∘ comb <span class="ot">{</span><span class="dv">2</span><span class="ot">}</span> <span class="ot">{</span>m<span class="ot">})</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>puzzle <span class="ot">=</span> transpose $ Comma [ transpose puzzle2 &gt;&gt; transpose puzzle1 ]</span></code></pre></div>
<p>using our <code>transpose</code> machinery from earlier. Vertical composition composes along the axis of specification — if the implementation of one arrow matches the specification another, we can combine them into one.</p>
<h2 id="section-8-moving-away-from-unary-representations"><a href="#section-8-moving-away-from-unary-representations" class="header-link">Section 8: Moving away from unary representations<span class="header-link-emoji">🔗</span></a></h2>
<p>Unary sucks. Let’s generalize our adding machinery to any arbitrary type. First we’ll make types corresponding to <code>CarryIn</code> and <code>CarryOut</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>DIn <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>DIn t <span class="ot">=</span> Bool × t × t</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>DOut <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>DOut t <span class="ot">=</span> t × Bool</span></code></pre></div>
<p>I’m going to go rogue for a while, and try to do this section without referencing the paper. We want to make a morphism in the arrow category corresponding to using <code>addCarry</code> as the specification for addition over <code>DIn</code> and <code>DOut</code>. Let’s play the same puzzle game, and set up a commutative diagram.</p>
<p>At the top is our specification, <code>addCarry : CarryIn m -&gt; CarryOut m</code>. That then pins our top two objects, and obviously our bottom two are <code>DIn t</code> and <code>DOut t</code>:</p>
<pre><code>                          addCarry
              CarryIn m  ---------&gt;  CarryOut m
                 ^                      ^
 bval x (μ x μ)  |                      | μ x bval
                 |         addD         |
               DIn t  -------------&gt;  DOut t</code></pre>
<p>where <code>bval : Bool -&gt; Fin 2</code>. Here, <code>μ</code> plays the part of <code>toNat</code>, and <code>addD</code> is addition over <code>D t</code>-indexed numbers.</p>
<p>We can package this up into a record indexed by <code>μ</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">record</span> Adder <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">(</span>μ <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constructor</span> <span class="ot">_</span>-|<span class="ot">_</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">field</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    addD <span class="ot">:</span> DIn t <span class="ot">-&gt;</span> DOut t</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    is-adder <span class="ot">:</span> SET [ addD &gt;&gt; bimap μ bval ]</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>            == SET [ bimap bval <span class="ot">(</span>bimap μ μ<span class="ot">)</span> &gt;&gt; addCarry ]</span></code></pre></div>
<p>and trivially construct the desired commutative diagram from an <code>Adder</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Adder=&gt;&gt; <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">{</span>μ <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">}</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> Adder μ</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> bimap bval <span class="ot">(</span>bimap μ μ<span class="ot">)</span> =&gt;&gt; bimap μ bval</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>Adder=&gt;&gt; <span class="ot">(</span>addD -| proof<span class="ot">)</span> <span class="ot">=</span> comma-hom addD addCarry proof</span></code></pre></div>
<p>So let’s implement a full-adder. This is a “well-known” result, but I didn’t know it offhand. I’m sure I could have sussed this out on my own, but instead I just found it on Wikipedia:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>and <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>and true b <span class="ot">=</span> b</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>and false b <span class="ot">=</span> false</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>or <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>or true b <span class="ot">=</span> true</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>or false b <span class="ot">=</span> b</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>xor <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>xor true true <span class="ot">=</span> false</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>xor true false <span class="ot">=</span> true</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>xor false true <span class="ot">=</span> true</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>xor false false <span class="ot">=</span> false</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>full-add <span class="ot">:</span> DIn Bool <span class="ot">-&gt;</span> DOut Bool</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>full-add <span class="ot">(</span>cin , a , b<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> o <span class="ot">=</span> xor a b</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> xor o cin , or <span class="ot">(</span>and a b<span class="ot">)</span> <span class="ot">(</span>and o cin<span class="ot">)</span></span></code></pre></div>
<p>We can construct an <code>Adder</code> for <code>full-add</code> with observation <code>bval</code> by case-bashing our way through the proof:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>BitAdder <span class="ot">:</span> Adder bval</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>BitAdder <span class="ot">=</span> full-add -| extensionality</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">\</span> <span class="ot">{</span> <span class="ot">(</span>false , false , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>false , false , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>false , true , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>false , true , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>true , false , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>true , false , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>true , true , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">;</span> <span class="ot">(</span>true , true , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">}</span></span></code></pre></div>
<p>The next step is obviously to figure out how to compose <code>Adder</code>s — ideally to construct adders for vectors. But I don’t know how to do this offhand. So it’s time to look back at the paper.</p>
<p>OK, right. So we have an obvious tensor over <code>μ</code>, which is just to lift two of them over a pair:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>tensorμ</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>tm tn <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tm <span class="ot">-&gt;</span> Fin m<span class="ot">)</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tn <span class="ot">-&gt;</span> Fin n<span class="ot">)</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tm × tn <span class="ot">-&gt;</span> Fin <span class="ot">(</span>n * m<span class="ot">))</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>tensorμ μm μn <span class="ot">(</span>tm , tn<span class="ot">)</span> <span class="ot">=</span> comb $ μn tn , μm tm</span></code></pre></div>
<p>Likewise, we have one over the adding functions themselves, pushing the carry-out of one into the carry-in of the next:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>tensorAdd</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn m <span class="ot">-&gt;</span> DOut m<span class="ot">)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn n <span class="ot">-&gt;</span> DOut n<span class="ot">)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn <span class="ot">(</span>m × n<span class="ot">)</span> <span class="ot">-&gt;</span> DOut <span class="ot">(</span>m × n<span class="ot">))</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>tensorAdd addm addn <span class="ot">(</span>cin , <span class="ot">(</span>ma , na<span class="ot">)</span> , <span class="ot">(</span>mb , nb<span class="ot">))</span> <span class="ot">=</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="ot">(</span>m , cin&#39;<span class="ot">)</span> <span class="ot">=</span> addm $ cin  , ma , mb</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(</span>n , cout<span class="ot">)</span> <span class="ot">=</span> addn $ cin&#39; , na , nb</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="ot">(</span>m , n<span class="ot">)</span> , cout</span></code></pre></div>
<p>Allegedly these form a true adder as witnessed by <code>Adder (tensorμ μm μn)</code>, but the proof isn’t included in the paper, and I had a hard time tracking it down in the source code. So rather than taking this by fiat, let’s see if we can convince ourselves.</p>
<p>As a first attempt of convincing myself, I tried to construct <code>adder22 : Adder (tensorμ bval bval)</code> which is a tensor of two full-adders. I constructed a case bash for the proof, and Agda complained! After some sleuthing, I had missed a swap somewhere in the paper, and thus had my carry bit in the wrong place in <code>full-adder</code>.</p>
<p>After sorting that out, the case bash works on <code>adder22</code>. So that’s a good sanity check that this works as promised. But, why? Presuably I should be able to run my commutative diagram all the way to its specification to debug what’s going on.</p>
<p>A few hours later…</p>
<p>I came up with the following, which can run a commutative diagram:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>arrowOf <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> CommaObj<span class="ot">}</span> <span class="ot">-&gt;</span> CommaArr A B <span class="ot">-&gt;</span> CommaObj × CommaObj</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>arrowOf <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">_</span> <span class="ot">=</span> A , B</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>debug <span class="ot">:</span> <span class="ot">{</span>A B C D <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>f <span class="ot">:</span> A <span class="ot">-&gt;</span> B<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>g <span class="ot">:</span> C <span class="ot">-&gt;</span> D<span class="ot">}</span> <span class="ot">-&gt;</span> f =&gt;&gt; g <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> D</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>debug arr x <span class="ot">=</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="ot">(_</span> , comma-obj y<span class="ot">)</span> <span class="ot">=</span> arrowOf arr</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(</span>comma-hom f <span class="ot">_</span> <span class="ot">_)</span> <span class="ot">=</span> arr</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> y <span class="ot">(</span>f x<span class="ot">)</span></span></code></pre></div>
<p>Of course, the diagrams we get from <code>Adder=&gt;&gt;</code> only get us as far as <code>addCarry</code>. In order to get all the way to <code>Nat</code>s, we need to vertically compose a bunch of other diagrams too. In order, they’re <code>puzzle</code>, <code>addF=&gt;&gt;</code> and <code>addN=&gt;&gt;</code>. The actual diagram I came up with was this attrocious thing:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>Adder=&gt;&gt;N</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> Cat2<span class="ot">.</span>CommaArr<span class="ot">.</span>f</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">(</span>Comma [</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>         Comma [ Comma [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span> &gt;&gt; transpose puzzle ]</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>         &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>         &gt;&gt; transpose addN=&gt;&gt; ]<span class="ot">)</span> =&gt;&gt; Cat2<span class="ot">.</span>CommaArr<span class="ot">.</span>g</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">(</span>Comma [</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>                  Comma [ Comma [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                               &gt;&gt; transpose puzzle ]</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>                  &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>                  &gt;&gt; transpose addN=&gt;&gt; ]<span class="ot">)</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>Adder=&gt;&gt;N <span class="ot">=</span> transpose $</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>  Comma</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    [ Comma</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    [ Comma</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>   &gt;&gt; transpose puzzle ]</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>   &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>   &gt;&gt; transpose addN=&gt;&gt; ]</span></code></pre></div>
<p>and finally, I can evaluate the thing:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>debug&#39; <span class="ot">:</span> Nat</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>debug&#39; <span class="ot">=</span> debug Adder=&gt;&gt;N <span class="ot">(</span>false , <span class="ot">(</span>true , false<span class="ot">)</span> , <span class="ot">(</span>true , false<span class="ot">))</span></span></code></pre></div>
<p>Nice. OK, so back to answering the question. Each of the <code>Bool x Bool</code> tuples is a little-endian vector, which get added together, plus the carry. In the process of doing all of this work, I inadvertantly figured out how the tensoring works. What’s more interesting is tensoring together two different adders. For example, the <code>trivial-add</code> (section 8.3):</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> One <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  one <span class="ot">:</span> One</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>oneval <span class="ot">:</span> One <span class="ot">-&gt;</span> Fin <span class="dv">1</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>oneval one <span class="ot">=</span> zero</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>trivial-add <span class="ot">:</span> DIn One <span class="ot">-&gt;</span> DOut One</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>trivial-add <span class="ot">(</span>b , <span class="ot">_</span> , <span class="ot">_)</span> <span class="ot">=</span> one , b</span></code></pre></div>
<p>If we construct <code>tensorAdder trivial-add BitAdder</code>, we get an adder whose vectors are <code>One x Bool</code>. This is an extremely interesting representation, as it means our number system doesn’t need to have the same base for each digit. In fact, that’s where the compositionality comes from. We’re pretty comfortable assigning <code>2^i</code> to each digit position, but this representation makes it clear that there’s nothing stopping us from choosing arbitrary numbers. What’s really doing the work here is our old friend <code>comb : {m n : Nat} -&gt; Fin2 (m , n) -&gt; Fin (n * m)</code>. Expanding the type synonym makes it a little clearer <code>comb : {m n : Nat} -&gt; Fin m x Fin n -&gt; Fin (n * m)</code> — this thing is literally multiplying two finite numbers into one!</p>
<p>Looking at <code>tensorAdd</code> under this new lens makes it clearer too. Recall:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>tensorAdd addm addn <span class="ot">(</span>cin , <span class="ot">(</span>ma , na<span class="ot">)</span> , <span class="ot">(</span>mb , nb<span class="ot">))</span> <span class="ot">=</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="ot">(</span>m , cin&#39;<span class="ot">)</span> <span class="ot">=</span> addm $ cin  , ma , mb</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">(</span>n , cout<span class="ot">)</span> <span class="ot">=</span> addn $ cin&#39; , na , nb</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="ot">(</span>m , n<span class="ot">)</span> , cout</span></code></pre></div>
<p>Here we’re pointwise adding the digits, where <code>m</code> is the least significant of the two digits. Our carry-in goes into the <code>m</code>, and its carry-out goes into <code>n</code>. OK, so this thing is just doing adder-chaining.</p>
<p>Section 8.4 talks about extending this to vectors, but the trick is just to fold them via <code>tensorAdd</code>. The paper uses a right-fold. I’m curious about what happens if you do a left fold, but might circle back around to that question since I only have a few more hours to get this post out and I want to spend some time <em>in</em> Mexico while I’m here. Upon deeper thought, I don’t think anythig would change — we’d still get a ripple carry adder. Worth playing around with though.</p>
<h2 id="section-9-speculation"><a href="#section-9-speculation" class="header-link">Section 9: Speculation<span class="header-link-emoji">🔗</span></a></h2>
<p>Section 9 is the most exciting part of the paper in my eyes. It defines speculation, which Elliott uses to implement a carry-ahead adder. I think the paper cheats a bit in this section — and makes it clear that we might have been cheating a bit earlier too. But first some preliminaries. The paper defines <code>speculate</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>speculate <span class="ot">:</span> <span class="ot">{</span>A C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Bool × A <span class="ot">-&gt;</span> C<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Bool × A <span class="ot">-&gt;</span> C<span class="ot">)</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>speculate f <span class="ot">(</span>b , a<span class="ot">)</span> <span class="ot">=</span> if b then f <span class="ot">(</span>true , a<span class="ot">)</span> else f <span class="ot">(</span>false , a<span class="ot">)</span></span></code></pre></div>
<p>This looks like it should be a no-op, and indeed, there’s a trivial proof that <code>speculate f =o= f</code>. The trick then is to lift <code>speculate</code> over an adder:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>spec</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">{</span>μ <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">}</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> Adder μ</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> Adder μ</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">(</span>adder -| proof<span class="ot">)</span> <span class="ot">=</span> speculate adder -| ?</span></code></pre></div>
<p>and the claim is that if we now do the same vector fold over <code>spec a</code> instead of <code>a</code>, we will get a carry-ahead adder! Sorcery! Magic!</p>
<p>But also… wat? Is that actually true?</p>
<p>I think here is where the paper is playing fast and loose. In <code>SET</code>, <code>speculate a</code> is exactly <code>a</code>. But the paper shows us a circuit diagram for this speculated fold, and it does indeed show the right behavior. So what’s going on?</p>
<p>What’s going on is that the paper isn’t actually working in <code>SET</code>. Well, it is. Sorta. In fact, I think there’s some fancy-pants compiling-to-categories going on here. In the same way that <code>xor</code> presented above is a <code>SET</code>-equivalent version of the <code>xor</code> operation in the <code>CIRCUIT</code> category (but is not actually <code>xor</code> in <code>CIRCUIT</code>), <code>if_then_else_</code> is actually the <code>SET</code> version of an equivalent operation in <code>CIRCUIT</code>. In <code>CIRCUIT</code>, <code>if_then_else_</code> is actually implemented as inlining both its true and false branches, and switching between them by <code>and</code>ing their outputs against the conditional.</p>
<p>So, the carry-ahead adder is not nearly as simple as it’s presented in this paper. There’s a huge amount of work going on behind the scenes:</p>
<ol type="1">
<li>defining the <code>CIRCUIT</code> category</li>
<li>implementing <code>if_then_else_</code> in <code>CIRCUIT</code></li>
<li>showing that the arrow category lifts <code>if_then_else_</code></li>
</ol>
<p>Furthermore, I’m not exactly sure how this all <em>works.</em> Like, when we define <code>speculate</code> as <code>if b then f (true , a) else f (false , a)</code>, are we literally inlining <code>f</code> with the conditional fixed, and <em>simplfying</em> the resulting circuit? I mean, we could just fix <code>true</code> by tying it to <code>HIGH</code>, but the diagrams included in the paper don’t appear to do that. If so, who is responsible for simplfying? Does it matter? This is a big hole in the paper, and in my opinion, greatly diminishes its impact, since it’s the claim I was most excited about.</p>
<p>To the paper’s credit, the vector fold and speculative fold turn into nice combinators, and give us a little language for building adders, which is extremely cool.</p>
<h2 id="section-10-reusing-circuitry-over-time"><a href="#section-10-reusing-circuitry-over-time" class="header-link">Section 10: Reusing circuitry over time<span class="header-link-emoji">🔗</span></a></h2>
<p>Ripple-carry adders are slow but use few gates. Carry-ahead adders are much faster, but use asymptotically more gates. Clearly there is a tradeoff here between latency and manufacturing cost. Section 10 gives us another point in the design space where we just build one full-adder, and loop it into itself. This also sounds exciting, but I’m a bit wary after section 9.</p>
<p>And as presented, I don’t think I trust the paper to deliver on this front. There is some finagling, but at it’s core, we are given a looping construct:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>loop</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> <span class="ot">{</span>A B S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>S × A <span class="ot">-&gt;</span> B × S<span class="ot">)</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> S × Vec A n</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">-&gt;</span> Vec B n × S</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>loop f <span class="ot">(</span>s , nil<span class="ot">)</span> <span class="ot">=</span> nil , s</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>loop f <span class="ot">(</span>s , cons a v<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b , s&#39; <span class="ot">=</span> f <span class="ot">(</span>s , a<span class="ot">)</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> bimap <span class="ot">(</span>cons b<span class="ot">)</span> id <span class="ot">(</span>loop f <span class="ot">(</span>s&#39; , v<span class="ot">))</span></span></code></pre></div>
<p>Thinking about what this would mean in <code>CIRCUIT</code> makes it unclear how we would go about implementing such a thing in real hardware — especially so if the embedding sticks <code>f</code> into the hardware and then loops over it over time. You’re going to need some sort of ring buffer to read off the outputs and stick them in the resulting vector. You’re going to need timing signals to know when your ring buffer is consistent. There’s clearly a lot going on in this section that is left unsaid, and there aren’t even any pretty pictures to help us reverse engineer the missing bits.</p>
<p>So I’m going to leave it there.</p>
<h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion<span class="header-link-emoji">🔗</span></a></h2>
<p><em>Adders and Arrows</em> was a fun paper to go through. It forced me to up my category game, and I got a much better sense of what the arrow category does, and how it can be useful. Furthermore, just going through a non-trivial project aggressively improved my Agda competencies, and I’m excited to do more along these lines.</p>
<p>The paper itself is a bit too terse for my liking. I would have liked a section saying “here’s what we’re going to do, and here’s how we’re going to go about it,” rather than just being thrown in and trying to deduce this for myself. In particular, it took me an embarassing amount of time to realize how to get natural numbers out of my adder arrows, and why the first 6 sections were worth having done.</p>
<p>Technically, I found the ergonomics of working with arrow-category arrows very challenging. Two of the <code>SET</code> morphisms show up in the type, but the other two show up as values, and there is no easy way to see which diagrams can be vertically composed. My <code>Adder=&gt;&gt;N</code> arrow abve shows the pain of trying to give a type to such a thing.</p>
<p>I had two major points of complaint about this paper. The first is that the source code isn’t very accessible. It exists in a repo, but is scattered around a bunch of modules and whenever I wanted to find something I resorted to just looking at each — being unable to make rhyme or reason of how things were organized. Worse, a huge chunk of the underlying machinery is in a separate repo, one which is significantly more advanced in its Agda usage than I am. A proliferation of weird unicode symbols that aren’t the ones that show up in the PDF make this especially challenging to navigate.</p>
<p>My other major complaint is that sections 9 and 10 were extremely underwhelming, though. If the paper does what it promises, it doesn’t actually show <em>how.</em> There is a lot going on behind the scenes that aren’t even alluded to in the paper. Granted, the version I’m reading is a draft, so hopefully this will be cleared up.</p>
<p>I don’t yet have a major takeaway from this paper, other than that arrow categories are cool for specifying problems and proving that your implementations adhere to those specifications. But as implemented, for my given adeptness at Agda, they are too hard to use. Composition is tricky to wrap ones head around given the type signatures used in this paper, but hopefully that’s an aesthetic problem more than a fundamental issue. In particular, <code>tranpose</code> needs to have type <code>CommaArr A B C D -&gt; CommaArr C D A B</code> — this would make vertical and horizontal composition much easier to think about.</p>
<p>All in all, powering through this paper has given me some new tools for thought, and helped me see how category theory might be useful to mere mortals.</p>
<p><a href="https://github.com/isovector/agda-playground/blob/88dabf47b5e251cad55dd4cce3b54df5ab4aff13/AddArrows.agda">My implementation of this code is available on Github.</a></p>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        © 2015-2023 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

