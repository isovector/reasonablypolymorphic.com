<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Review: Syntax-Guided Synthesis :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/syntax-guided-synthesis/index.html#">Review: Syntax-Guided Synthesis</a></h1>
</header>
<p class="meta">
    <time>2022-03-19</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <!--
<pre class="Agda"><a id="153" class="Keyword">module</a> <a id="160" href="blog.syntax-guided-synthesis.html" class="Module">blog.syntax-guided-synthesis</a> <a id="189" class="Keyword">where</a>

<a id="196" class="Keyword">open</a> <a id="201" class="Keyword">import</a> <a id="208" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="249" class="Keyword">open</a> <a id="254" class="Keyword">import</a> <a id="261" href="Data.Product.html" class="Module">Data.Product</a>
<a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="345" class="Keyword">open</a> <a id="350" class="Keyword">import</a> <a id="357" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="374" class="Keyword">using</a> <a id="380" class="Symbol">(</a><a id="381" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="384" class="Symbol">;</a> <a id="386" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="389" class="Symbol">;</a> <a id="391" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="393" class="Symbol">;</a> <a id="395" href="Relation.Nullary.html#1559" class="InductiveConstructor Operator">_because_</a><a id="404" class="Symbol">;</a> <a id="406" href="Relation.Nullary.html#656" class="Function Operator">¬_</a><a id="408" class="Symbol">;</a> <a id="410" href="Relation.Nullary.html#902" class="InductiveConstructor">ofʸ</a><a id="413" class="Symbol">;</a> <a id="415" href="Relation.Nullary.html#939" class="InductiveConstructor">ofⁿ</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="442" class="Keyword">hiding</a> <a id="449" class="Symbol">(</a><a id="450" href="Data.Bool.Properties.html#1126" class="Function Operator">_≟_</a><a id="453" class="Symbol">;</a> <a id="455" href="Data.Bool.Base.html#672" class="Datatype Operator">_≤_</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Bool.Properties.html#1964" class="Function Operator">_≤?_</a><a id="464" class="Symbol">)</a>
<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.html" class="Module">Data.List</a> <a id="526" class="Keyword">hiding</a> <a id="533" class="Symbol">(</a><a id="534" href="Data.List.Base.html#4588" class="Function">and</a><a id="537" class="Symbol">;</a> <a id="539" href="Data.List.Base.html#5025" class="Function Operator">[_]</a><a id="542" class="Symbol">)</a>
<a id="544" class="Keyword">open</a> <a id="549" class="Keyword">import</a> <a id="556" href="Function.html" class="Module">Function</a> <a id="565" class="Keyword">hiding</a> <a id="572" class="Symbol">(</a><a id="573" href="Function.Base.html#636" class="Function">const</a><a id="578" class="Symbol">)</a>
<a id="580" class="Keyword">open</a> <a id="585" class="Keyword">import</a> <a id="592" href="Data.Maybe.html" class="Module">Data.Maybe</a>
</pre>-->
<p>I was describing my idea from <a href="/blog/generic-parallel-fp">last week</a> to <a href="/blog/generic-parallel-fp/#future-work">automatically optimize programs</a> to Colin, who pointed me towards <a href="https://sygus.org/assets/pdf/Journal_SyGuS.pdf">Syntax-Guided Synthesis</a> by Alur et al.</p>
<p>Syntax-Guided Synthesis is the idea that free-range program synthesis is really hard, so instead, let’s constrain the search space with a grammar of allowable programs. We can then enumerate those possible programs, attempting to find one that satisfies some constraints. The idea is quite straightforward when you see it, but that’s not to say it’s unimpressive; the paper has lots of quantitative results about exactly how well this approach does.</p>
<p>The idea is we want to find programs with type <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a></span> <code>→</code> <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a></span>, that satisfy some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>ification. We’ll do that by picking some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage of syntax, and trying to build our programs there.</p>
<p>All of this is sorta moot, because we assume we have some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> which can tell us if our program satisfies the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. But the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is probably some SMT solver, and is thus expensive to call, so we’d like to try hard not to call it if possible.</p>
<p>Let’s take an example, and say that we’d like to synthesize the <code>max</code> of two <code class="sourceCode agda">Nat</code>s. There are lots of ways of doing that! But we’d like to find a function that satisfies the following:</p>
<pre class="Agda"><a id="2068" class="Keyword">data</a> <a id="MaxSpec"></a><a id="2073" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2081" class="Symbol">(</a><a id="2082" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2084" class="Symbol">:</a> <a data-type="Set" id="2086" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2088" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="2090" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2092" class="Symbol">→</a> <a data-type="Set" id="2094" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2095" class="Symbol">)</a> <a id="2097" class="Symbol">:</a> <a data-type="Set" id="2099" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2101" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="2103" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2105" class="Symbol">→</a> <a data-type="Set₁" id="2107" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2111" class="Keyword">where</a>
  <a id="MaxSpec.is-max"></a><a id="2119" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">{</a><a id="2129" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2131" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2133" class="Symbol">:</a> <a data-type="Set" id="2135" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2136" class="Symbol">}</a>
         <a id="2147" class="Symbol">→</a> <a id="2149" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2151" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="2153" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2155" class="Symbol">(</a><a id="2156" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2158" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2160" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2161" class="Symbol">)</a>
         <a id="2172" class="Symbol">→</a> <a id="2174" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2176" href="Data.Nat.Base.html#1535" class="Datatype Operator">≤</a> <a id="2178" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2180" class="Symbol">(</a><a id="2181" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2183" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2185" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2186" class="Symbol">)</a>
         <a id="2197" class="Symbol">→</a> <a id="2199" class="Symbol">((</a><a id="2201" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2203" class="Symbol">(</a><a id="2204" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2206" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2208" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2209" class="Symbol">)</a> <a id="2211" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2213" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a><a id="2214" class="Symbol">)</a> <a id="2216" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="2218" class="Symbol">(</a><a id="2219" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2221" class="Symbol">(</a><a id="2222" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2224" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2226" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2227" class="Symbol">)</a> <a id="2229" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2231" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2232" class="Symbol">))</a>
         <a id="2244" class="Symbol">→</a> <a id="2246" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2254" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2256" class="Symbol">(</a><a id="2257" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2259" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2261" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2262" class="Symbol">)</a>
</pre>
<p>If we can successfully produce an element of <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code>, we have a proof that <code>f</code> is an implementation of <code>max</code>. Of course, actually producing such a thing is rather tricky; it’s equivalent to determining if <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code> is <span class="Agda"><a href="Relation.Nullary.html#1511" class="Record">Dec</a></span>idable for the given input.</p>
<p>In the first three cases, we have some conflicting piece of information, so we are unable to produce a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>:</p>
<pre class="Agda"><a id="decideMax"></a><a id="2679" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2689" class="Symbol">:</a> <a id="2691" class="Symbol">(</a><a id="2692" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2694" class="Symbol">:</a> <a data-type="Set" id="2696" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2698" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="2700" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2702" class="Symbol">→</a> <a data-type="Set" id="2704" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2705" class="Symbol">)</a> <a id="2707" class="Symbol">→</a> <a id="2709" class="Symbol">(</a><a id="2710" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a> <a id="2712" class="Symbol">:</a> <a data-type="Set" id="2714" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2716" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="2718" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2719" class="Symbol">)</a> <a id="2721" class="Symbol">→</a> <a id="2723" href="Relation.Nullary.html#1511" class="Record">Dec</a> <a id="2727" class="Symbol">(</a><a id="2728" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2736" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2738" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a><a id="2739" class="Symbol">)</a>
<a id="2741" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2751" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2753" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a><a id="2754" class="Symbol">@(</a><a id="2756" href="blog/syntax-guided-synthesis/index.html#2756" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="2758" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2760" href="blog/syntax-guided-synthesis/index.html#2760" class="Bound">y</a><a id="2761" class="Symbol">)</a> <a id="2763" class="Keyword">with</a> <a id="2768" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2770" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a> <a id="2772" class="Symbol">|</a> <a id="2774" href="Relation.Binary.PropositionalEquality.html#2382" class="Function">inspect</a> <a id="2782" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2784" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a>
<a id="2786" class="Symbol">...</a> <a id="2790" class="Symbol">|</a> <a id="2792" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2794" class="Symbol">|</a> <a id="2796" href="Relation.Binary.PropositionalEquality.html#2356" class="InductiveConstructor Operator">[</a> <a id="2798" href="blog/syntax-guided-synthesis/index.html#2798" class="Bound">fi≡o</a> <a id="2803" href="Relation.Binary.PropositionalEquality.html#2356" class="InductiveConstructor Operator">]</a> <a id="2805" class="Keyword">with</a> <a id="2810" class="Bound">x</a> <a id="2812" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="2815" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2817" class="Symbol">|</a> <a id="2819" class="Bound">y</a> <a id="2821" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="2824" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a>
<a id="2826" class="Symbol">...</a> <a id="2830" class="Symbol">|</a> <a id="2832" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2835" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2840" class="Symbol">|</a> <a id="2842" class="Symbol">_</a> <a id="2844" class="Symbol">=</a> <a id="2846" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2849" class="Symbol">λ</a> <a id="2851" class="Symbol">{</a> <a id="2853" class="Symbol">(</a><a id="2854" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2861" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2865" class="Symbol">_</a> <a id="2867" class="Symbol">_)</a> <a id="2870" class="Symbol">→</a>
        <a id="2880" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="2894" class="Symbol">(</a><a id="2895" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="2903" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2907" class="Symbol">(</a><a id="2908" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="2920" class="Bound">fi≡o</a><a id="2924" class="Symbol">))</a> <a id="2927" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2932" class="Symbol">}</a>
<a id="2934" class="Symbol">...</a> <a id="2938" class="Symbol">|</a> <a id="2940" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="2944" class="Symbol">_</a> <a id="2946" class="Symbol">|</a> <a id="2948" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2951" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="2956" class="Symbol">=</a> <a id="2958" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="2961" class="Symbol">λ</a> <a id="2963" class="Symbol">{</a> <a id="2965" class="Symbol">(</a><a id="2966" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2973" href="blog/syntax-guided-synthesis/index.html#2973" class="Bound">x</a> <a id="2975" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="2979" href="blog/syntax-guided-synthesis/index.html#2979" class="Bound">x₂</a><a id="2981" class="Symbol">)</a> <a id="2983" class="Symbol">→</a>
        <a id="2993" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3007" class="Symbol">(</a><a id="3008" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3016" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="3020" class="Symbol">(</a><a id="3021" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3033" class="Bound">fi≡o</a><a id="3037" class="Symbol">))</a> <a id="3040" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="3045" class="Symbol">}</a>
<a id="3047" class="Symbol">...</a> <a id="3051" class="Symbol">|</a> <a id="3053" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3057" href="blog/syntax-guided-synthesis/index.html#3057" class="Bound">x≤o</a> <a id="3061" class="Symbol">|</a> <a id="3063" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3067" href="blog/syntax-guided-synthesis/index.html#3067" class="Bound">y≤o</a> <a id="3071" class="Keyword">with</a> <a id="3076" class="Bound">o</a> <a id="3078" href="Data.Nat.Properties.html#2529" class="Function Operator">≟</a> <a id="3080" class="Bound">x</a> <a id="3082" class="Symbol">|</a> <a id="3084" class="Bound">o</a> <a id="3086" href="Data.Nat.Properties.html#2529" class="Function Operator">≟</a> <a id="3088" class="Bound">y</a>
<a id="3090" class="Symbol">...</a> <a id="3094" class="Symbol">|</a> <a id="3096" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3099" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a> <a id="3103" class="Symbol">|</a> <a id="3105" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3108" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a> <a id="3112" class="Symbol">=</a>
        <a id="3122" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3125" class="Symbol">λ</a> <a id="3127" class="Symbol">{</a> <a id="3129" class="Symbol">(</a><a id="3130" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3137" href="blog/syntax-guided-synthesis/index.html#3137" class="Bound">x</a> <a id="3139" href="blog/syntax-guided-synthesis/index.html#3139" class="Bound">x₁</a> <a id="3142" class="Symbol">(</a><a id="3143" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="3148" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3150" class="Symbol">))</a> <a id="3153" class="Symbol">→</a>
                  <a id="3173" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3187" class="Symbol">(</a><a id="3188" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3194" class="Symbol">(</a><a id="3195" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3199" class="Bound">fi≡o</a><a id="3203" class="Symbol">)</a> <a id="3205" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3207" class="Symbol">)</a> <a id="3209" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a>
             <a id="3226" class="Symbol">;</a> <a id="3228" class="Symbol">(</a><a id="3229" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3236" href="blog/syntax-guided-synthesis/index.html#3236" class="Bound">x</a> <a id="3238" href="blog/syntax-guided-synthesis/index.html#3238" class="Bound">x₁</a> <a id="3241" class="Symbol">(</a><a id="3242" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="3247" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3248" class="Symbol">))</a> <a id="3251" class="Symbol">→</a>
                  <a id="3271" href="Relation.Nullary.Negation.Core.html#778" class="Function">contradiction</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3292" class="Symbol">(</a><a id="3293" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3297" class="Bound">fi≡o</a><a id="3301" class="Symbol">)</a> <a id="3303" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3304" class="Symbol">)</a> <a id="3306" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a>
             <a id="3323" class="Symbol">}</a>
</pre>
<p>Otherwise, we have a proof that <code>o</code> is equal to either <code>y</code> or <code>x</code>:</p>
<pre class="Agda"><a id="3402" class="Symbol">...</a> <a id="3406" class="Symbol">|</a> <a id="3408" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="3411" href="blog/syntax-guided-synthesis/index.html#3411" class="Bound">proof</a> <a id="3417" class="Symbol">|</a> <a id="3419" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3423" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a> <a id="3427" class="Symbol">=</a> <a id="3429" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a>
        <a id="3441" class="Symbol">(</a><a id="3442" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3449" class="Symbol">(</a><a id="3450" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3458" class="Bound">x≤o</a> <a id="3462" class="Symbol">(</a><a id="3463" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3475" class="Symbol">(</a><a id="3476" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3480" class="Bound">fi≡o</a><a id="3484" class="Symbol">)))</a>
                <a id="3504" class="Symbol">(</a><a id="3505" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3513" class="Bound">y≤o</a> <a id="3517" class="Symbol">(</a><a id="3518" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3530" class="Symbol">(</a><a id="3531" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3535" class="Bound">fi≡o</a><a id="3539" class="Symbol">)))</a>
                <a id="3559" class="Symbol">(</a><a id="3560" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="3565" class="Symbol">(</a><a id="3566" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3572" class="Bound">fi≡o</a> <a id="3577" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a><a id="3580" class="Symbol">)))</a>
<a id="3584" class="Symbol">...</a> <a id="3588" class="Symbol">|</a> <a id="3590" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="3594" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a> <a id="3598" class="Symbol">|</a> <a id="3600" class="Symbol">_</a> <a id="3602" class="Symbol">=</a> <a id="3604" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a>
        <a id="3616" class="Symbol">(</a><a id="3617" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3624" class="Symbol">(</a><a id="3625" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3633" class="Bound">x≤o</a> <a id="3637" class="Symbol">(</a><a id="3638" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3650" class="Symbol">(</a><a id="3651" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3655" class="Bound">fi≡o</a><a id="3659" class="Symbol">)))</a>
                <a id="3679" class="Symbol">(</a><a id="3680" href="Data.Nat.Properties.html#4748" class="Function">≤-trans</a> <a id="3688" class="Bound">y≤o</a> <a id="3692" class="Symbol">(</a><a id="3693" href="Data.Nat.Properties.html#4459" class="Function">≤-reflexive</a> <a id="3705" class="Symbol">(</a><a id="3706" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a> <a id="3710" class="Bound">fi≡o</a><a id="3714" class="Symbol">)))</a>
                <a id="3734" class="Symbol">(</a><a id="3735" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="3740" class="Symbol">(</a><a id="3741" href="Relation.Binary.PropositionalEquality.Core.html#1729" class="Function">trans</a> <a id="3747" class="Bound">fi≡o</a> <a id="3752" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a><a id="3755" class="Symbol">)))</a>
</pre>
<p><span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> is a proof that our function is an implementation of <code>max</code>, and <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a></span> is a proof that “we’d know one if we saw one.” So that’s the specification taken care of. The next step is to define the syntax we’d like to guard our search.</p>
<p>The paper presents this syntax as a BNF grammar, but my thought is why use a grammar when we could instead use a type system? Our syntax is a tiny little branching calculus, capable of representing <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>s and branching <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a></span>itionals:</p>
<pre class="Agda"><a id="4279" class="Keyword">mutual</a>
  <a id="4288" class="Keyword">data</a> <a id="Term"></a><a id="4293" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4298" class="Symbol">:</a> <a data-type="Set₁" id="4300" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="4304" class="Keyword">where</a>
    <a id="Term.var-x"></a><a id="4314" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4320" class="Symbol">:</a> <a id="4322" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.var-y"></a><a id="4331" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4337" class="Symbol">:</a> <a id="4339" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.const"></a><a id="4348" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4354" class="Symbol">:</a> <a data-type="Set" id="4356" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4358" class="Symbol">→</a> <a id="4360" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.if-then-else"></a><a id="4369" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4382" class="Symbol">:</a> <a id="4384" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4389" class="Symbol">→</a> <a id="4391" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4396" class="Symbol">→</a> <a id="4398" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4403" class="Symbol">→</a> <a id="4405" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>

  <a id="4413" class="Keyword">data</a> <a id="Cond"></a><a id="4418" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4423" class="Symbol">:</a> <a data-type="Set₁" id="4425" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="4429" class="Keyword">where</a>
    <a id="Cond.leq"></a><a id="4439" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4443" class="Symbol">:</a> <a id="4445" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4450" class="Symbol">→</a> <a id="4452" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4457" class="Symbol">→</a> <a id="4459" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.and"></a><a id="4468" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="4472" class="Symbol">:</a> <a id="4474" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4479" class="Symbol">→</a> <a id="4481" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4486" class="Symbol">→</a> <a id="4488" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.invert"></a><a id="4497" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4511" class="Symbol">→</a> <a id="4513" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
</pre>
<p>All that’s left for our example is the ability to “compile” a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span> down to a candidate function. Just pattern match on the constructors and push the inputs around until we’re done:</p>
<pre class="Agda"><a id="4719" class="Keyword">mutual</a>
  <a id="eval"></a><a id="4728" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4733" class="Symbol">:</a> <a id="4735" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4740" class="Symbol">→</a> <a data-type="Set" id="4742" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4744" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="4746" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4748" class="Symbol">→</a> <a data-type="Set" id="4750" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="4754" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4759" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4765" class="Symbol">(</a><a id="4766" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="4768" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4770" href="blog/syntax-guided-synthesis/index.html#4770" class="Bound">y</a><a id="4771" class="Symbol">)</a> <a id="4773" class="Symbol">=</a> <a id="4775" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a>
  <a id="4779" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4784" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4790" class="Symbol">(</a><a id="4791" href="blog/syntax-guided-synthesis/index.html#4791" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="4793" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4795" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a><a id="4796" class="Symbol">)</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a>
  <a id="4804" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4809" class="Symbol">(</a><a id="4810" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4816" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a><a id="4817" class="Symbol">)</a> <a id="4819" class="Symbol">(</a><a id="4820" href="blog/syntax-guided-synthesis/index.html#4820" class="Bound">x</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="4822" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4824" href="blog/syntax-guided-synthesis/index.html#4824" class="Bound">y</a><a id="4825" class="Symbol">)</a> <a id="4827" class="Symbol">=</a> <a id="4829" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a>
  <a id="4833" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4838" class="Symbol">(</a><a id="4839" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4852" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4854" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4856" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a><a id="4857" class="Symbol">)</a> <a id="4859" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4861" class="Symbol">=</a>
    <a id="4867" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="4870" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4879" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4881" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4883" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="4888" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4893" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4895" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4897" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="4902" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4907" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a> <a id="4909" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a>

  <a id="evalCond"></a><a id="4914" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4923" class="Symbol">:</a> <a id="4925" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4930" class="Symbol">→</a> <a data-type="Set" id="4932" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4934" href="Data.Product.html#1167" class="Function Operator">×</a> <a data-type="Set" id="4936" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="4938" class="Symbol">→</a> <a data-type="Set" id="4940" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="4947" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4956" class="Symbol">(</a><a id="4957" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4961" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4963" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a><a id="4964" class="Symbol">)</a> <a id="4966" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a>   <a id="4970" class="Symbol">=</a> <a id="4972" href="Relation.Nullary.html#1581" class="Field">Dec.does</a> <a id="4981" class="Symbol">(</a><a id="4982" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4987" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4989" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a> <a id="4991" href="Data.Nat.Properties.html#5518" class="Function Operator">≤?</a> <a id="4994" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4999" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a> <a id="5001" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a><a id="5002" class="Symbol">)</a>
  <a id="5006" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5015" class="Symbol">(</a><a id="5016" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="5020" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5023" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a><a id="5025" class="Symbol">)</a> <a id="5027" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5029" class="Symbol">=</a> <a id="5031" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5040" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5043" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5045" href="Data.Bool.Base.html#986" class="Function Operator">∧</a> <a id="5047" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5056" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a> <a id="5059" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a>
  <a id="5063" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5072" class="Symbol">(</a><a id="5073" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="5080" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a><a id="5081" class="Symbol">)</a> <a id="5083" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a>  <a id="5086" class="Symbol">=</a> <a id="5088" href="Data.Bool.Base.html#932" class="Function">not</a> <a id="5092" class="Symbol">(</a><a id="5093" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5102" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a> <a id="5104" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a><a id="5105" class="Symbol">)</a>
</pre>
<p>So that’s most of the idea; we’ve specified what we’re looking for, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>, what our syntax is, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>, and a way of compiling our syntax into functions, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a></span>. This is the gist of the technique; the rest is just algorithms.</p>
<p>The paper presents several algorithms and evaluates their performances. But one is clearly better than the others in the included benchmarks, so we’ll just go through that one.</p>
<p>Our algorithm to synthesize code corresponding to the specification takes a few parameters. We’ve seen the first few:</p>
<pre class="Agda"><a id="5677" class="Keyword">module</a> <a id="Solver"></a><a id="5684" href="blog/syntax-guided-synthesis/index.html#5684" class="Module">Solver</a>
    <a id="5695" class="Symbol">{</a><a id="5696" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5701" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5703" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a> <a id="5705" class="Symbol">:</a> <a data-type="Set₁" id="5707" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5710" class="Symbol">}</a>
    <a id="5716" class="Symbol">(</a><a id="5717" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5722" class="Symbol">:</a> <a id="5724" class="Symbol">(</a><a id="5725" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5727" class="Symbol">→</a> <a id="5729" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5730" class="Symbol">)</a> <a id="5732" class="Symbol">→</a> <a id="5734" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5736" class="Symbol">→</a> <a data-type="Set₁" id="5738" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="5741" class="Symbol">)</a>
    <a id="5747" class="Symbol">(</a><a id="5748" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="5755" class="Symbol">:</a> <a id="5757" class="Symbol">(</a><a id="5758" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5760" class="Symbol">:</a> <a id="5762" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5764" class="Symbol">→</a> <a id="5766" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5767" class="Symbol">)</a> <a id="5769" class="Symbol">→</a> <a id="5771" class="Symbol">(</a><a id="5772" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a> <a id="5774" class="Symbol">:</a> <a id="5776" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="5777" class="Symbol">)</a> <a id="5779" class="Symbol">→</a> <a id="5781" href="Relation.Nullary.html#1511" class="Record">Dec</a> <a id="5785" class="Symbol">(</a><a id="5786" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5791" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5793" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a><a id="5794" class="Symbol">))</a>
    <a id="5801" class="Symbol">(</a><a id="5802" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="5810" class="Symbol">:</a> <a id="5812" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5817" class="Symbol">→</a> <a id="5819" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5824" class="Symbol">)</a>
</pre>
<p>However, we also need a way of synthesizing terms in our <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage. For that, we’ll use <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which maps a natural number to a term:</p>
<pre class="Agda">    <a id="5995" class="Symbol">(</a><a id="5996" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6006" class="Symbol">:</a> <a data-type="Set" id="6008" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="6010" class="Symbol">→</a> <a id="6012" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6016" class="Symbol">)</a>
</pre>
<p>Although it’s not necessary for the algorithm, we should be able to implement <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a></span> over <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which states every <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span> is eventually produced by <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>:</p>
<pre class="Agda">    <a id="6234" class="Symbol">(</a><a id="6235" href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a> <a id="6246" class="Symbol">:</a> <a id="6248" class="Symbol">(</a><a id="6249" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a> <a id="6251" class="Symbol">:</a> <a id="6253" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6257" class="Symbol">)</a> <a id="6259" class="Symbol">→</a> <a id="6261" href="Data.Product.html#916" class="Function">Σ[</a> <a id="6264" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6266" href="Data.Product.html#916" class="Function">∈</a> <a data-type="Set" id="6268" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="6270" href="Data.Product.html#916" class="Function">]</a> <a id="6272" class="Symbol">(</a><a id="6273" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6283" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6285" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="6287" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a><a id="6288" class="Symbol">))</a>
</pre>
<p>Finally, we need an <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> capable of telling us if our solution is correct. This might sound a bit like cheating, but behind the scenes it’s just a magic SMT solver. The idea is that SMT can either confirm that our program is correct, or produce a counterexample that violates the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. The type here is a bit crazy, so we’ll take it one step at a time.</p>
<p>An <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is a function that takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>…</p>
<pre class="Agda">    <a id="6742" class="Symbol">(</a><a id="6743" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a>
      <a id="6756" class="Symbol">:</a> <a id="6758" class="Symbol">(</a><a id="6759" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a> <a id="6763" class="Symbol">:</a> <a id="6765" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6769" class="Symbol">)</a>
</pre>
<p>and either gives back a function that can produce a <code>spec (compile exp)</code> for every input:</p>
<pre class="Agda">      <a id="6877" class="Symbol">→</a>   <a id="6881" class="Symbol">((</a><a id="6883" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a> <a id="6885" class="Symbol">:</a> <a id="6887" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="6888" class="Symbol">)</a> <a id="6890" class="Symbol">→</a> <a id="6892" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="6897" class="Symbol">(</a><a id="6898" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="6906" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="6909" class="Symbol">)</a> <a id="6911" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a><a id="6912" class="Symbol">)</a>
</pre>
<p>or gives back some input which is not a <code>spec (compile exp)</code>:</p>
<pre class="Agda">        <a id="6994" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="6996" href="Data.Product.html#916" class="Function">Σ[</a> <a id="6999" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a> <a id="7001" href="Data.Product.html#916" class="Function">∈</a> <a id="7003" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7005" href="Data.Product.html#916" class="Function">]</a> <a id="7007" href="Relation.Nullary.html#656" class="Function Operator">¬</a> <a id="7009" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="7014" class="Symbol">(</a><a id="7015" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="7023" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="7026" class="Symbol">)</a> <a id="7028" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a><a id="7029" class="Symbol">)</a>
    <a id="7035" class="Keyword">where</a>
</pre>
<p>The algorithm here is actually quite clever. The idea is that to try each <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d value in order, attempting to minimize the number of calls we make to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>, because they’re expensive. So instead, well keep a list of every counterexample we’ve seen so far, and ensure that our synthesized function passes all of them before sending it off to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>. First, we’ll need a data structure to store our search progress:</p>
<pre class="Agda">  <a id="7508" class="Keyword">record</a> <a id="Solver.SearchState"></a><a id="7515" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a> <a id="7527" class="Symbol">:</a> <a data-type="Set₁" id="7529" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="7533" class="Keyword">where</a>
    <a id="7543" class="Keyword">field</a>
      <a id="Solver.SearchState.iteration"></a><a id="7555" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7565" class="Symbol">:</a> <a data-type="Set" id="7567" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
      <a id="Solver.SearchState.cases"></a><a id="7575" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7581" class="Symbol">:</a> <a data-type="Set a → Set a" id="7583" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="7588" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a>
  <a id="7592" class="Keyword">open</a> <a id="7597" href="blog/syntax-guided-synthesis/index.html#7515" class="Module">SearchState</a>
</pre>
<p>The initial search state is one in which we start at the beginning, and have no counterexamples:</p>
<pre class="Agda">  <a id="Solver.start"></a><a id="7718" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7724" class="Symbol">:</a> <a id="7726" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
  <a id="7740" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7750" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7756" class="Symbol">=</a> <a id="7758" class="Number">0</a>
  <a id="7762" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7768" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7774" class="Symbol">=</a> <a data-type="List A" id="7776" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
</pre>
<p>We can try a function by testing every counterexample:</p>
<pre class="Agda">  <a id="Solver.try"></a><a id="7847" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7851" class="Symbol">:</a> <a id="7853" class="Symbol">(</a><a id="7854" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7856" class="Symbol">→</a> <a id="7858" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="7859" class="Symbol">)</a> <a id="7861" class="Symbol">→</a> <a data-type="Set a → Set a" id="7863" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="7868" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7870" class="Symbol">→</a> <a data-type="Set" id="7872" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="7879" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7883" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a> <a id="7885" class="Symbol">=</a> <a id="7887" href="Data.List.Base.html#4730" class="Function">all</a> <a id="7891" class="Symbol">(</a><a id="7892" href="Relation.Nullary.html#1581" class="Field">Dec.does</a> <a id="7901" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="7903" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="7910" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a><a id="7911" class="Symbol">)</a>
</pre>
<p>and finally, can now attempt to synthesize some code. Our function <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a></span>, and either gives back the next step of the search, or some program, and a proof that it’s what we’re looking for.</p>
<pre class="Agda">  <a id="Solver.check"></a><a id="8151" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a>
      <a id="8163" class="Symbol">:</a> <a id="8165" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
      <a id="8183" class="Symbol">→</a> <a id="8185" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="8207" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="8209" class="Symbol">(</a><a id="8210" href="Data.Product.html#916" class="Function">Σ[</a> <a id="8213" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a> <a id="8217" href="Data.Product.html#916" class="Function">∈</a> <a id="8219" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="8224" href="Data.Product.html#916" class="Function">]</a> <a id="8226" class="Symbol">((</a><a id="8228" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a> <a id="8230" class="Symbol">:</a> <a id="8232" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="8233" class="Symbol">)</a> <a id="8235" class="Symbol">→</a> <a id="8237" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="8242" class="Symbol">(</a><a id="8243" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8251" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a><a id="8254" class="Symbol">)</a> <a id="8256" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a><a id="8257" class="Symbol">))</a>
  <a id="8262" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="8268" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a>
</pre>
<p>We begin by getting and compiling the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d term:</p>
<pre class="Agda">           <a id="8361" class="Keyword">with</a> <a id="8366" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="8376" class="Symbol">(</a><a id="8377" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8387" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a><a id="8389" class="Symbol">)</a>
  <a id="8393" class="Symbol">...</a> <a id="8397" class="Symbol">|</a> <a id="8399" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a> <a id="8403" class="Keyword">with</a> <a id="8408" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8416" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a>
</pre>
<p>check if it passes all the previous counterexamples:</p>
<pre class="Agda">  <a id="8485" class="Symbol">...</a> <a id="8489" class="Symbol">|</a> <a id="8491" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8493" class="Keyword">with</a> <a id="8498" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="8502" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8504" class="Symbol">(</a><a id="8505" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8511" class="Bound">ss</a><a id="8513" class="Symbol">)</a>
</pre>
<p>if it doesn’t, just fail with the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a></span>:</p>
<pre class="Agda">  <a id="8586" class="Symbol">...</a> <a id="8590" class="Symbol">|</a> <a data-type="Bool" id="8592" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8598" class="Symbol">=</a> <a id="8600" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8605" class="Symbol">(</a><a id="8606" class="Keyword">record</a> <a id="8613" class="Symbol">{</a> <a id="8615" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8625" class="Symbol">=</a> <a data-type="Nat → Nat" id="8627" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8631" class="Symbol">(</a><a id="8632" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8642" class="Bound">ss</a><a id="8644" class="Symbol">)</a>
                             <a id="8675" class="Symbol">;</a> <a id="8677" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8683" class="Symbol">=</a> <a id="8685" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8691" class="Bound">ss</a>
                             <a id="8723" class="Symbol">})</a>
</pre>
<p>Otherwise, our proposed function might just be the thing we’re looking for, so it’s time to consult the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>:</p>
<pre class="Agda">  <a id="8859" class="Symbol">...</a> <a id="8863" class="Symbol">|</a> <a data-type="Bool" id="8865" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8870" class="Keyword">with</a> <a id="8875" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a> <a id="8882" class="Bound">exp</a>
</pre>
<p>which either gives a counterexample that we need to record:</p>
<pre class="Agda">  <a id="8958" class="Symbol">...</a> <a id="8962" class="Symbol">|</a> <a id="8964" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="8969" class="Symbol">(</a><a id="8970" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="8972" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8974" class="Symbol">_)</a> <a id="8977" class="Symbol">=</a>
          <a id="8989" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8994" class="Symbol">(</a><a id="8995" class="Keyword">record</a> <a id="9002" class="Symbol">{</a> <a id="9004" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9014" class="Symbol">=</a> <a data-type="Nat → Nat" id="9016" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9020" class="Symbol">(</a><a id="9021" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9031" class="Bound">ss</a><a id="9033" class="Symbol">)</a>
                       <a id="9058" class="Symbol">;</a> <a id="9060" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9066" class="Symbol">=</a> <a id="9068" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a data-type="A → List A → List A" id="9070" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9072" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9078" class="Bound">ss</a>
                       <a id="9104" class="Symbol">})</a>
</pre>
<p>or it confirms that our function satisfies the specification, and thus that were done:</p>
<pre class="Agda">  <a id="9206" class="Symbol">...</a> <a id="9210" class="Symbol">|</a> <a id="9212" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="9217" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a> <a id="9219" class="Symbol">=</a> <a id="9221" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="9226" class="Symbol">(</a><a id="9227" class="Bound">exp</a> <a data-type="(fst : A) (snd : B fst) → Σ A B" id="9231" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9233" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a><a id="9234" class="Symbol">)</a>
</pre>
<p>Pretty cool! The paper gives an optimization that caches the result of every counterexample on every synthesized program, and reuses these whenever that program appears as a subprogram of a larger one. The idea is that we can trade storage so we only ever need to evaluate each subprogram once — important for expensive computations.</p>
<p>Of course, pumping <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> by hand is annoying, so we can instead package it up as <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a></span> which takes a search depth, and iterates <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> until it runs out of gas or gets the right answer:</p>
<pre class="Agda">  <a id="Solver.solve"></a><a id="9797" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a>
      <a id="9809" class="Symbol">:</a> <a data-type="Set" id="9811" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
      <a id="9819" class="Symbol">→</a> <a data-type="Set a → Set a" id="9821" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="9827" class="Symbol">(</a><a id="9828" href="Data.Product.html#916" class="Function">Σ[</a> <a id="9831" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">lang</a> <a id="9836" href="Data.Product.html#916" class="Function">∈</a> <a id="9838" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9843" href="Data.Product.html#916" class="Function">]</a> <a id="9845" class="Symbol">((</a><a id="9847" href="blog/syntax-guided-synthesis/index.html#9847" class="Bound">i</a> <a id="9849" class="Symbol">:</a> <a id="9851" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="9852" class="Symbol">)</a> <a id="9854" class="Symbol">→</a> <a id="9856" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="9861" class="Symbol">(</a><a id="9862" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="9870" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">lang</a><a id="9874" class="Symbol">)</a> <a id="9876" href="blog/syntax-guided-synthesis/index.html#9847" class="Bound">i</a><a id="9877" class="Symbol">))</a>
  <a id="9882" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a> <a id="9888" class="Symbol">=</a> <a id="9890" href="blog/syntax-guided-synthesis/index.html#9915" class="Function">go</a> <a id="9893" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a>
    <a id="9903" class="Keyword">where</a>
      <a id="9915" href="blog/syntax-guided-synthesis/index.html#9915" class="Function">go</a>
          <a id="9928" class="Symbol">:</a> <a id="9930" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="9952" class="Symbol">→</a> <a data-type="Set" id="9954" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
          <a id="9966" class="Symbol">→</a> <a data-type="Set a → Set a" id="9968" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="9974" class="Symbol">(</a><a data-type="(A : Set a) (B : A → Set b) → Set (a ⊔ b)" id="9975" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="9977" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9982" class="Symbol">(λ</a> <a id="9985" href="blog/syntax-guided-synthesis/index.html#9985" class="Bound">lang</a> <a id="9990" class="Symbol">→</a> <a id="9992" class="Symbol">(</a><a id="9993" href="blog/syntax-guided-synthesis/index.html#9993" class="Bound">i</a> <a id="9995" class="Symbol">:</a> <a id="9997" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="9998" class="Symbol">)</a> <a id="10000" class="Symbol">→</a> <a id="10002" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="10007" class="Symbol">(</a><a id="10008" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="10016" href="blog/syntax-guided-synthesis/index.html#9985" class="Bound">lang</a><a id="10020" class="Symbol">)</a> <a id="10022" href="blog/syntax-guided-synthesis/index.html#9993" class="Bound">i</a><a id="10023" class="Symbol">))</a>
      <a id="10032" href="blog/syntax-guided-synthesis/index.html#9915" class="Function">go</a> <a id="10035" href="blog/syntax-guided-synthesis/index.html#10035" class="Bound">ss</a> <a data-type="Nat" id="10038" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="10043" class="Symbol">=</a> <a data-type="Maybe A" id="10045" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
      <a id="10059" href="blog/syntax-guided-synthesis/index.html#9915" class="Function">go</a> <a id="10062" href="blog/syntax-guided-synthesis/index.html#10062" class="Bound">ss</a> <a id="10065" class="Symbol">(</a><a data-type="Nat → Nat" id="10066" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10070" href="blog/syntax-guided-synthesis/index.html#10070" class="Bound">n</a><a id="10071" class="Symbol">)</a> <a id="10073" class="Keyword">with</a> <a id="10078" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="10084" href="blog/syntax-guided-synthesis/index.html#10062" class="Bound">ss</a>
      <a id="10093" class="Symbol">...</a> <a id="10097" class="Symbol">|</a> <a id="10099" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="10104" href="blog/syntax-guided-synthesis/index.html#10104" class="Bound">x</a> <a id="10106" class="Symbol">=</a> <a id="10108" href="blog/syntax-guided-synthesis/index.html#9915" class="Function">go</a> <a id="10111" class="Bound">ss</a> <a id="10114" class="Bound">n</a>
      <a id="10122" class="Symbol">...</a> <a id="10126" class="Symbol">|</a> <a id="10128" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="10133" href="blog/syntax-guided-synthesis/index.html#10133" class="Bound">y</a> <a id="10135" class="Symbol">=</a> <a data-type="A → Maybe A" id="10137" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10142" href="blog/syntax-guided-synthesis/index.html#10133" class="Bound">y</a>
</pre>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        © 2015-2022 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

