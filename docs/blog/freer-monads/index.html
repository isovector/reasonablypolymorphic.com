<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Freer Monads, More Better Programs :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/freer-monads/index.html#">Freer Monads, More Better Programs</a></h1>
</header>
<p class="meta">
    <time>2019-02-13</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <p>If you consider yourself a Haskell beginner, this post is not aimed at you! You‚Äôre going to want to understand <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion"><code>DataKinds</code></a> and <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism"><code>RankNTypes</code></a> in order to get things done. Feel free to read anyway, but keep in mind that the technical solutions described here are tricky.</p>
<p>Every two weeks in the <a href="https://functionalprogramming.slack.com">functional programming slack</a>, we get into a big argument about ‚Äúthe right way to structure programs.‚Äù The debate goes around and around in circles; names get called; feelings get hurt. We never get anywhere, and the whole process starts again 14 days later. Frankly, it‚Äôs exhausting.</p>
<p>As best I can tell, the community roughly fragments itself along four lines‚Äîthose who like <a href="https://github.com/haskell/mtl">mtl</a>, those who say ‚Äú<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">just do everything in Reader IO</a>‚Äù, those who like <a href="https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html">the three layer cake</a>, and those who think <a href="https://github.com/lexi-lambda/freer-simple">free(r) monads</a> are worth their weight in gold.</p>
<p>Being in the latter camp is frustrating, because everyone has strongly negative opinions on freer monads, and as best I can tell, nobody seems to have ever actually used them.</p>
<p>As one of the few people in the Haskell-sphere who has actually used freer monads in both anger <em>and</em> production, I wanted to set the record straight. So today, let‚Äôs talk about freer monads‚Äîwhat they are, what they buy you, how they work, and what wide-scale adoption could buy us. Yes, I‚Äôll also talk about what their weaknesses are.</p>
<h2 id="criminally-misunderstood"><a href="#criminally-misunderstood" class="header-link">Criminally Misunderstood<span class="header-link-emoji">üîó</span></a></h2>
<p>Freer monads are amazingly powerful. Much more so than I think anyone realizes‚Äîincluding many of the <em>people who maintain the libraries.</em> There‚Äôs a lot of free, super-common, crazy-generic functionality that exists, but isn‚Äôt anywhere useful.</p>
<p>Freer monads are <em>so much more</em> than just a different way of expressing monad transformers. They‚Äôre a completely orthogonal means of composition that doesn‚Äôt really exist anywhere else in the Haskell ecosystem. By not using them, you are condemning yourself to writing a significant amount more of significantly more complicated code than you need to be.</p>
<p>Traditional monad stacks can be understood as ‚Äúa small, established toolbox for side effects.‚Äù You say ‚ÄúI want some state, so I will add a <code>StateT</code> transformer,‚Äù with the understanding that <em>this is isomorphic to <code>s -&gt; (s, a)</code>.</em> That means it only ever does <em>local state.</em></p>
<p>I‚Äôd suggest we instead think about freer monads as ‚Äúimplementation mix-ins,‚Äù or equivalently, as ‚Äúcompiler passes.‚Äù Code written against freer monads is exceptionally high-level and doesn‚Äôt mix concerns. It‚Äôs all ‚Äúbusiness logic‚Äù, where the implementation details are handled in layers, each one performed by a pass that simplifies the representation.</p>
<p>These passes are type-safe, independent and composable. You can mix-and-match which ones you want‚Äîwhich means testing is often just swapping in a test pass somewhere near the bottom of the stack. By mocking out different layers, it‚Äôs easy to get 100% test coverage, without ever needing to write full-scale integration tests.</p>
<p>The beauty of this system is that the testability itself also composes. If your program runs properly under the test pass, and you can prove that both your test and real pass are also correct, this correctness composes to the entire program.</p>
<p>Having an exceptionally high-level representation of your program‚Äôs intent is valuable in another way. Let‚Äôs take a <code>State</code> capability as an example. This thing might correspond to local state, or a database, or maybe even just <code>GET</code>/<code>POST</code> HTTP requests. Who knows? But also, who <em>cares?</em></p>
<p>Most of the people reading the code, most of the time, don‚Äôt actually care what are the semantics behind the state. Those semantics are implementation details, interesting only to the people who care about the implementation. If you‚Äôre tracing a program flow, and <em>aren‚Äôt</em> interested in the database side of things, it‚Äôs a lot nicer to not need to wade through a bunch of irrelevant database code.</p>
<p>In short, freer monads let you separate the high-level ‚Äúwhat am I trying to do‚Äù from the low-level ‚Äúhow to actually do it.‚Äù</p>
<h2 id="understanding-freer-monads"><a href="#understanding-freer-monads" class="header-link">Understanding Freer Monads<span class="header-link-emoji">üîó</span></a></h2>
<p>The <code>Eff</code> monad is parameterized by a type-level list of <em>effects</em> (or <em>capabilities</em> as I will also call them.) This list is kept polymorphic, and constraints are enforced on it to ensure that certain effects are available.</p>
<p>For example, the type <code>StateT String (ReaderT Int IO) Bool</code> is analogous to <code>Eff &#39;[State String, Reader Int, IO] Bool</code>.</p>
<p>However, the type <code>(MonadState String m, MonadReader Int m, MonadIO m) =&gt; m Bool</code> in the <code>mtl</code> style also has an analogue: <code>(Member (State String) r, Member (Reader Int) r, Member IO r) =&gt; Eff r Bool</code>.</p>
<p>Freer monads are extensible in their effects‚Äîthat means you can write your own, and use them completely interchangeably with existing effects. It‚Äôs trivial to write a new effect, as they‚Äôre just GADTs:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Teletype</span> a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetLine</span><span class="ot"> ::</span>           <span class="dt">Teletype</span> <span class="dt">String</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PutLine</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Teletype</span> ()</span></code></pre></div>
<p>This is all it takes to define a new effect. We now have a <code>Teletype</code> effect, and we can use it after a small amount of (<a href="https://hackage.haskell.org/package/freer-simple-1.2.1.0/docs/Control-Monad-Freer-TH.html#v:makeEffect">freely derivable</a>) boilerplate:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r <span class="dt">String</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span> <span class="ot">=</span> send <span class="dt">GetLine</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putLine ::</span> <span class="dt">Member</span> <span class="dt">Teletype</span> r <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>putLine <span class="ot">=</span> send <span class="op">.</span> <span class="dt">PutLine</span></span></code></pre></div>
<p>Notice that the <code>a</code> in <code>Teletype a</code> describes <em>the type you get back from calling this operation.</em></p>
<p>Our new <code>Teletype</code> effect corresponds to a domain specific language that can talk about reading and writing lines on a teletype. It‚Äôs important to keep in mind that <em>there is no meaning associated with this effect.</em> We get no semantics, other than an implicit, unverified guarantee that ‚Äúit probably does what you expect.‚Äù</p>
<p>However, this lack of pre-established semantics is a feature, rather than a bug. The semantics are given after the fact by <em>interpretations</em> of the effects. One interpretation of <code>Teletype</code> might be to perform it in <code>IO</code>, interacting directly with the console. Another might be in the form of <code>POST</code>ing <code>putLine</code>s to an HTTP server, and returning the results of a <code>GET</code> for <code>getLine</code>. Another could just do everything purely in memory.</p>
<p>Freer monads are extensible not only in their effects, but also in their interpretations. You can give new interpretations for existing effects, and for your own.</p>
<p><code>freer-simple</code> offers several combinators for constructing new effects, which we‚Äôll explore in the example below.</p>
<h2 id="solving-problems-with-freer-monads"><a href="#solving-problems-with-freer-monads" class="header-link">Solving Problems with Freer Monads<span class="header-link-emoji">üîó</span></a></h2>
<blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</p>
<p>‚Äì‚ÄâMelvin Conway</p>
</blockquote>
<p>Freer monads are a data representation of your program, which then gets interpreted at finer-and-finer grained resolution until it‚Äôs just code.</p>
<p>In other words, they enforce a clean boundary between ‚Äúsaying what you mean‚Äù and ‚Äúsaying how to do it.‚Äù They let you focus on writing business logic, and relegate the implementation details to library code.</p>
<p>They give you composable, plug-and-play functionality for transforming a high-level business logic spec into an actual implementation.</p>
<p>As an example of how this works on a real-life application, let‚Äôs write a program that fetches a CSV file from FTP, decrypts it, streams its contents to an external pipeline, and tracks its stats in Redis.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ingest</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> ( <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Record</span>) r</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>       , <span class="dt">Member</span> (<span class="dt">Output</span> [<span class="dt">Record</span>]) r</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>       , <span class="dt">Member</span> (<span class="dt">Output</span> <span class="dt">Stat</span>) r</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>ingest <span class="ot">=</span> nextInput <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> record <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    output [record]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    output <span class="dt">ProcessedRecordStat</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    ingest</span></code></pre></div>
<p>Done!<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Pretty easy, hey?</p>
<p>‚ÄúNow hold on a minute, Sandy! That program you wrote doesn‚Äôt do what you said! It doesn‚Äôt fetch files from FTP, it doesn‚Äôt decrypt them, and it doesn‚Äôt do anything with Redis.‚Äù</p>
<p>That‚Äôs right. It doesn‚Äôt. What this does is exactly what the business people say they want‚Äîit moves data from one place to somewhere else, and lets you know about it. The rest are implementation details, and aren‚Äôt relevant to anyone except the particular engineers responsible for this piece of the system. Engineers on <em>other teams in your organization</em> probably don‚Äôt even care about the implementation details.</p>
<p>Written like this it‚Äôs easy for people to get a sense of what you‚Äôre trying to accomplish, without needing to know the nitty-gritty details connection management, credential management, performance enhancements, error handling, or database details. It concisely describes the goal, and leaves the irrelevant bits out of sight and out of mind.</p>
<p>Of course; not <em>everyone</em> wants this high-level picture. The people responsible for this service really and truly do care about how the thing actually works. At least, at some level of abstraction. The people whose job it is to ingest data probably care about the service‚Äôs performance and error handling, but likely don‚Äôt have strong opinions on the semantics of fetching data, the encryption schemes used, the database layout or the choice of the external streaming pipeline. They probably don‚Äôt even care that they‚Äôre ingesting CSV files‚Äîthey‚Äôd just as happily consume real-time JSON requests.</p>
<p>The goal is to make it easy for people to analyze the pieces they understand and are responsible for, and hide the noise of the underlying details to someone else.</p>
<p>So, how to do we get from our high-level description to a real program? We transform it into a slightly less-high-level program. For example, in order to get our <code>Input</code> of <code>Record</code>s, we do actually need to parse a CSV file. You‚Äôll notice that such a problem really doesn‚Äôt care where the file comes from; it just wants something to read.</p>
<p>So we write an interpretation of <code>Input Record</code> in terms of CSV files. This suggests we have some sort of <code>FileProvider</code> capability, whose job it is to actually get use the file in question.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>csvInput</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> ( <span class="dt">Member</span> <span class="dt">FileProvider</span> r</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>       , <span class="dt">FromCSVRow</span> i</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Input</span> i &#39;<span class="op">:</span> r) a</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>csvInput file m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    contents <span class="ot">&lt;-</span> getFile file</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> csvData <span class="ot">=</span> toList <span class="op">$</span> parseCSV contents</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    handleRelayS csvData (<span class="fu">const</span> <span class="fu">pure</span>) bind m  <span class="co">-- discussed immediately after</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">--  bind :: [i] -&gt; Input i x -&gt; ([i] -&gt; x -&gt; Eff r a) -&gt; Eff r a</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    bind (row <span class="op">:</span> rows) <span class="dt">NextInput</span> k <span class="ot">=</span> k rows <span class="op">$</span> <span class="dt">Just</span> row</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    bind rows<span class="op">@</span>[]      <span class="dt">NextInput</span> k <span class="ot">=</span> k rows <span class="dt">Nothing</span></span></code></pre></div>
<p><code>csvInput</code> takes a file name, reads that file in terms of some abstract <code>FileProvider</code> capability, and then returns one row of the result every time <code>nextInput</code> is called in the higher-level application.</p>
<p>This function is implemented in terms of the <a href="https://hackage.haskell.org/package/freer-simple-1.2.1.0/docs/Control-Monad-Freer-Internal.html#v:handleRelayS"><code>handleRelayS</code></a> combinator. You can think of <code>handleRelayS</code> as being parameterized on what <code>return</code> and <code>(&gt;&gt;=)</code> mean for the effect being interpreted. In addition, it allows you to thread a piece of state between binds and the final <code>return</code>.</p>
<p>Our implementation of <code>bind</code> is to return a new row of the CSV file for every subsequent call to <code>nextInput</code> in the original program. We accomplish this by returning the head of the list of rows, and then passing the tail as the next piece of state.</p>
<p>In effect, we‚Äôve described what it means to have an <code>Input</code> capability in terms of what it means to have a <code>FileProvider</code> capability. Notice that this isn‚Äôt the only interpretation of <code>Input</code>‚Äîit could just as well be implemented by reading from a streaming source, or by always giving back the same result, or by cycling through a static list.</p>
<p>The point is that the people writing the service don‚Äôt care where this data is coming from. All they care is that they can read it and pipe it to the right place. In fact, they might want to test that their service works by calling it on a constant stream of data‚Äîso instead they can interpret it purely:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pureInput</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> [i]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Input</span> i &#39;<span class="op">:</span> r) a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>pureInput is <span class="ot">=</span> handleRelayS is (<span class="fu">const</span> <span class="fu">pure</span>) bind</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">--  bind :: [i] -&gt; Input i x -&gt; ([i] -&gt; x -&gt; Eff r a) -&gt; Eff r a</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    bind (row <span class="op">:</span> rows) <span class="dt">NextInput</span> k <span class="ot">=</span> k rows <span class="op">$</span> <span class="dt">Just</span> row</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    bind rows<span class="op">@</span>[]      <span class="dt">NextInput</span> k <span class="ot">=</span> k rows <span class="dt">Nothing</span></span></code></pre></div>
<p>(for bonus points, you can implement <code>csvInput</code> in terms of <code>pureInput</code>)</p>
<p>Ok, great! The next step towards a working program is to give an interpretation of a <code>FileProvider</code>. We‚Äôll write two‚Äîone in terms of a lower level <code>FTP</code> capability, and one in terms of regular everyday <code>IO</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ftpFileProvider</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Member</span> <span class="dt">FTP</span> r</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">FileProvider</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ftpFileProvider <span class="ot">=</span> interpret <span class="op">$</span> \(<span class="dt">GetFile</span> filename) <span class="ot">-&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  ftpGet filename</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>localFileProvider</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Member</span> <span class="dt">IO</span> r</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">FileProvider</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>localFileProvider <span class="ot">=</span> interpret <span class="op">$</span> \(<span class="dt">GetFile</span> filename) <span class="ot">-&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  send <span class="op">$</span> Data.Bytestring.readFile filename</span></code></pre></div>
<p>Often you just want to reinterpret an effect in terms of some other effect you already have (here, <code>FTP</code> and <code>IO</code>, respectively). In this case, it‚Äôs sufficient to just use the <code>interpret</code> combinator, which takes implements your interpretation via a <em>natural transformation</em> (something of the form <code>forall x. effect x -&gt; Eff r x</code>.)</p>
<p>For testing, you might also want a mock filesystem‚Äî<code>pureFileProvider :: Map FilePath ByteString -&gt; _</code>.</p>
<p>Our program can now provide an <code>Input</code> capability via a <code>FileProvider</code> capability, via <code>IO</code> directly or via an <code>FTP</code> capability. You get the picture.</p>
<p>Something we haven‚Äôt yet handled is file decryption. It‚Äôs worth noting that this concern is largely orthogonal to <code>FileProvider</code>s; we‚Äôd like to be able to mix-in the capability to deal with encrypted files regardless of what the actual mechanism for files looks like.</p>
<p>For that, we‚Äôre exposed to yet another combinator for writing interpretations; <code>interpose</code>. This combinator allows us to interpret a capability in terms of itself. Which means, we can <em>intercept</em> calls to a capability without necessarily <em>handling</em> them. Providing decrypted files is a good use case for this‚Äîwe can intercept requests for files, and silently decrypt them before giving them back.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>decryptFileProvider</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Member</span> <span class="dt">Encryption</span> r</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Eff</span> (<span class="dt">FileProvider</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">FileProvider</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>decryptFileProvider <span class="ot">=</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  interpose <span class="op">$</span> \(<span class="dt">GetFile</span> filename) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    cyphertext <span class="ot">&lt;-</span> getFile filename</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    decrypt cyphertext</span></code></pre></div>
<p>We‚Äôve gained the ability to inject logic <em>around</em> other interpretations!</p>
<p>Assuming we have an FTP implementation, the <code>Input</code> side of the coin is done. Now to deal with the <code>Output</code>s of our ingestion program. Remember, we want to put our records into some external streaming service. We can naively provide an interpreter that <code>POST</code>s these records against our service.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>postOutput</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> ( <span class="dt">Member</span> <span class="dt">HTTP</span> r</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>       , <span class="dt">ToJSON</span> i</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">HttpRequest</span> <span class="dt">&#39;POST</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Output</span> i &#39;<span class="op">:</span> r) a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>postOutput mkReq <span class="ot">=</span> interpret <span class="op">$</span> \<span class="dt">Output</span> i <span class="ot">-&gt;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  postHttp <span class="op">$</span> mkReq i</span></code></pre></div>
<p>Assuming we have another interpretation <code>HTTP ~&gt; IO</code>, we‚Äôre now good to go!</p>
<p>This works, but accounting comes back a few days later and complains‚Äîour streaming bill is suddenly really big. Apparently we pay <em>per API call.</em> Uh oh. The good news is that the API can handle up to 500 records per <code>POST</code>. So, we can just write another interpret that batches writes before posting them.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>batch</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Output</span> [i] &#39;<span class="op">:</span> r) a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">Output</span> [i] &#39;<span class="op">:</span> r) a</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>batch size <span class="ot">=</span> interposeS (<span class="dv">0</span>, []) finalize bind</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- finalize :: (Int, [i]) -&gt; a -&gt; Eff (Writer [i] &#39;: r) a</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    finalize (_, acc) a <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      output acc</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">pure</span> a</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- bind</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">--     :: (Int, [i])</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">--     -&gt; Output [i] x</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">--     -&gt; ((Int, [i]) -&gt; x -&gt; Eff (Writer [i] &#39;: r) a)</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">--     -&gt; Eff (Writer [i] &#39;: r) a</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    bind (nacc, acc) (<span class="dt">Output</span> o) k <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> no     <span class="ot">=</span> <span class="fu">length</span> o</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>          total  <span class="ot">=</span> acc <span class="op">&lt;&gt;</span> o</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>          ntotal <span class="ot">=</span> nacc <span class="op">+</span> no</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> (ntotal <span class="op">&gt;=</span> size)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> (emit, acc&#39;) <span class="ot">=</span> <span class="fu">splitAt</span> size total</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>          output emit</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>          k (ntotal <span class="op">-</span> size, acc&#39;) ()</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> k (ntotal, total) ()</span></code></pre></div>
<p>Cool. Now sticking a <code>batch 500</code> pass before <code>postOutput</code> will batch all of our transactions sent to the API. Again, our business-logic doesn‚Äôt change, because it need to care about this implementation detail.</p>
<p>We could continue on, but at this point you‚Äôve seen most of the machinery freer monads give us. At the end of the day, <code>main</code> will end up looking like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runM</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> runRedis</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> runFTP</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> runHTTP</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> runEncryption</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> redisOuput <span class="op">@</span><span class="dt">Stat</span>   mkRedisKey</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> postOutput <span class="op">@</span><span class="dt">Record</span> mkApiCall</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> batch      <span class="op">@</span><span class="dt">Record</span> <span class="dv">500</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> ftpFileProvider</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> decryptFileProvider</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">.</span> csvInput <span class="st">&quot;file.csv&quot;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">$</span> ingest</span></code></pre></div>
<p>It composes nicely, and the compiler will yell at you if you forget to handle any of required capabilities.</p>
<p>Behavior can be mixed in at will; some other common things you might want include retry-with-backoff, service discovery, chaos-injection, etc.</p>
<p>Over time and scale, you‚Äôll realize that <em>most of your application code</em> is the same crap over and over again‚Äîread configuration, connect to a database, deal with retry, shuffle data from one buffer to another. It‚Äôs often hard to see this when it‚Äôs written with a traditional monad stack, because traditional monad stacks don‚Äôt give you the tools to abstract it away.</p>
<p>As you get into the habit of building new effects and interpretations for those effects, you‚Äôll see that new applications are often ready to ship after 25 lines of business logic and another 25 lines of choosing the right interpretations for it.</p>
<h2 id="bad-arguments-against-freer-monads"><a href="#bad-arguments-against-freer-monads" class="header-link">Bad Arguments Against Freer Monads<span class="header-link-emoji">üîó</span></a></h2>
<p>There are several arguments against freer monad, some of which are good, but most of which are terrible.</p>
<h3 id="free-monads-have-bad-performance"><a href="#free-monads-have-bad-performance" class="header-link">Free Monads Have Bad Performance<span class="header-link-emoji">üîó</span></a></h3>
<p><em>Free</em> monads suffer from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> complexity <a href="https://www.stackage.org/haddock/lts-11.7/kan-extensions-5.1/Control-Monad-Codensity.html#t:Codensity">when used naively</a>, which is unfortunately what you get by default. Freer monads are optimized via a queue which provides constant-time construction of the default case.</p>
<p>Yes, freer monads are today somewhere around 30x slower than the equivalent <code>mtl</code> code. That‚Äôs <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fast.html">roughly on par with Python</a>, but be honest, you‚Äôve deployed Python services in the past and they were fast enough. And besides, the network speed already dominates your performance‚Äîyou‚Äôre IO-bound anyway.</p>
<p>If you are writing real-time services maybe this will be an issue, but you‚Äôre probably not. And if you are, optimizing Haskell is likely a skill you already have.</p>
<p>A subtle point to notice is that it‚Äôs the <em>monadic</em> bits of the code that are 30x slower. Not ‚Äúyour program is 30x slower if you import <code>Control.Monad.Freer</code>‚Äù‚Äîbut simply that you will spend more time in binds than you would in another monad. But your program isn‚Äôt only monadic in <code>Eff</code>; it also needs to compute expressions and wait for <code>IO</code> and all of that stuff.</p>
<p>If it makes you feel better, <a href="https://github.com/lexi-lambda/freer-simple/pull/21">I recently got a 15% performance increase</a> by just more aggressively inlining some of the combinators. This suggests there‚Äôs a lot of low-hanging optimization wins for anyone willing to go through the work to pluck it.</p>
<p>In short: worry about writing good code first, and deal with performance if it becomes an issue.</p>
<h3 id="purescript-abandoned-eff"><a href="#purescript-abandoned-eff" class="header-link">Purescript Abandoned Eff<span class="header-link-emoji">üîó</span></a></h3>
<p>Purescript <em>had a thing called <code>Eff</code></em>, <em>but it was not the same as this.</em> From the <code>purescript-eff</code> <a href="https://github.com/purescript-deprecated/purescript-eff">readme</a>:</p>
<blockquote>
<p>As of PureScript 0.12 the default type for handling effects is Effect from purescript-effect. This differs from Eff by removing the row of effect types. This decision was made as getting the effect rows to line up was sometimes quite tricky, without providing a great deal of benefit.</p>
<p>There is also purescript-run now, which uses a similar effect row mechanic <strong>but provides true algebraic effect handling.</strong> [emphasis mine]</p>
</blockquote>
<p>The <code>Eff</code> described in this document is equivalent to <code>purescript-run</code>.</p>
<h2 id="reasonably-good-arguments-against-freer-monads"><a href="#reasonably-good-arguments-against-freer-monads" class="header-link">Reasonably Good Arguments Against Freer Monads<span class="header-link-emoji">üîó</span></a></h2>
<h3 id="contt-is-not-an-algebraic-effect"><a href="#contt-is-not-an-algebraic-effect" class="header-link"><code>ContT</code> is Not an Algebraic Effect<span class="header-link-emoji">üîó</span></a></h3>
<p>I never really understood this one as stated‚ÄîI‚Äôve never actually used <code>ContT</code> in a real monad stack. Have you?</p>
<p>But the sentiment behind this argument is better stated in human as ‚Äú<code>Eff</code> is unable to model resource bracketing.‚Äù Which is to say, it‚Äôs hard to make sure an <code>Eff</code> program calls all of its finalizers.</p>
<p>The good news is that there‚Äôs a solution if your allocation and cleanup code only requires <code>IO</code>‚Äîyou can just interpret your entire <code>Eff</code> monad directly into <a href="https://www.stackage.org/haddock/lts-13.7/resourcet-1.2.2/Control-Monad-Trans-Resource.html#t:ResourceT"><code>ResourceT</code></a>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>bracket</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Member</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>) r</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> ())</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r b)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r b</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>bracket alloc dealloc m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  (key, a) <span class="ot">&lt;-</span> send <span class="op">$</span> allocate alloc dealloc</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  result   <span class="ot">&lt;-</span> m a</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  send <span class="op">$</span> release key</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> result</span></code></pre></div>
<p>Specialize <code>bracket</code> with your own first two parameters to taste.</p>
<p>More annoyingly, the lack of <code>ContT</code>-support means that it‚Äôs hard to write effects that imply asynchronicity. That‚Äôs not to say it‚Äôs impossible, merely that it doesn‚Äôt compose in the same nice way that synchronous effects do.</p>
<p>This is bad, but not disastrously so. You can spin up a thread pool elsewhere, and add a capability that sends effects to it:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AsyncEff</span> capabilities a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">AsyncEff</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">      ::</span> <span class="dt">Members</span> capabilities r</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">AsyncEff</span> capabilities ()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>startAsyncTaskSlave</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Members</span> capabilities r</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Eff</span> r x <span class="ot">-&gt;</span> <span class="dt">IO</span> x)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- ^ An interpretation stack from `Eff r` into `IO`</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">InChan</span> (<span class="dt">AsyncEff</span> capabilities))</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>startThreadPool runEff <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">in</span>, out) <span class="ot">&lt;-</span> newChan <span class="dv">10</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  void <span class="op">.</span> async <span class="op">.</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">&lt;-</span> readChan out</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    void <span class="op">.</span> async <span class="op">$</span> runEff m</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="kw">in</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>asyncEff</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Member</span> <span class="dt">IO</span> r</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">InChan</span> (<span class="dt">AsyncEff</span> capabilities)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">AsyncEff</span> capabilities &#39;<span class="op">:</span> r) a</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>asyncEff chan <span class="ot">=</span> interpret <span class="op">$</span> send <span class="op">.</span> writeChan chan</span></code></pre></div>
<p>Changing the interface to fill an <code>MVar</code> upon completion of the task and make it available to the original <code>Eff</code> program is an exercise left to the reader.</p>
<h3 id="the-error-messages-are-bad-its-too-complicated"><a href="#the-error-messages-are-bad-its-too-complicated" class="header-link">The Error Messages Are Bad / It‚Äôs Too Complicated<span class="header-link-emoji">üîó</span></a></h3>
<p>This has historically been true. While <code>freer-simple</code> makes the situation significantly better, there is definitely room for improvement on this front.</p>
<p>First things first, <code>Eff</code> eschews the functional dependencies that <code>mtl</code> has. This means you can have multiple <code>Writer</code> effects in the same stack in <code>Eff</code> (but not in <code>mtl</code>) at the cost of type-inference.</p>
<p>This is both a feature, and, I won‚Äôt lie to you, <em>amazingly annoying at times.</em> It‚Äôs a feature because lots of things <em>are</em> just <code>Writer</code> effects. It‚Äôs annoying as heck because <em>polymorphism makes it eat shit.</em></p>
<p>For example, consider the following innocuous looking program:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Member</span> (<span class="dt">Writer</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> tell <span class="dv">15</span></span></code></pre></div>
<p>Seems fine, right? <em>Wrong.</em> Because <code>15</code> is actually <code>fromInteger 15 :: Num a =&gt; a</code>, this program will complain about not having a <code>Writer a</code> capability. You as a human know what should happen here, but the compiler is stupid.</p>
<p>Thankfully the solution is simple, but it requires knowing what‚Äôs wrong and how to fix it.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo&#39; ::</span> <span class="dt">Member</span> (<span class="dt">Writer</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>foo&#39; <span class="ot">=</span> tell <span class="op">@</span><span class="dt">Int</span> <span class="dv">15</span></span></code></pre></div>
<p>If you‚Äôre going to be doing a lot of work with polymorphic effects, a low-energy solution is to just provide a locally-bound monomorphic type:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo&#39;&#39; ::</span> <span class="dt">Member</span> (<span class="dt">Writer</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Eff</span> r ()</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>foo&#39;&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tellInt <span class="ot">=</span> tell <span class="op">@</span><span class="dt">Int</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  tellInt <span class="dv">1</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  tellInt <span class="dv">2</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  tellInt <span class="dv">3</span></span></code></pre></div>
<p>All of this is much less user-friendly than it should be. However, in my experience, people quickly learn how to debug problems like this. It was enough to have an ‚ÄúEff mentor‚Äù on our team, whose job it was to promptly reply to ‚ÄúI don‚Äôt know why this doesn‚Äôt work.‚Äù</p>
<h3 id="jesus-help-me-there-are-a-lot-of-unmaintained-freer-monad-packages"><a href="#jesus-help-me-there-are-a-lot-of-unmaintained-freer-monad-packages" class="header-link">Jesus Help Me There Are A Lot of Unmaintained Free(r) Monad Packages<span class="header-link-emoji">üîó</span></a></h3>
<p>Tell me about it. Even as someone who is keenly interested in this stuff I have a hard time keeping up with the situation.</p>
<p>Here‚Äôs the skinny‚ÄîI‚Äôd strongly recommend <a href="https://github.com/lexi-lambda/freer-simple"><code>freer-simple</code></a>. Failing that, if you <em>really, really, really</em> need the performance, take a look at <a href="https://github.com/robrix/fused-effects"><code>fused-effects</code></a>.</p>
<p>Ignore the other ones.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h2 id="conclusion"><a href="#conclusion" class="header-link">Conclusion<span class="header-link-emoji">üîó</span></a></h2>
<p>Freer monads are <em>fucking sick</em> and you‚Äôd be foolish to not at least consider them for your next project.</p>
<p>Furthermore, if you‚Äôre going to continue insisting on saying that $technology is better, I <strong>strongly</strong> encourage you to write up a similar argument stating your case. My mind is open on this; if you make a strong argument, I‚Äôm more than happy to denounce this article and jump on the $technology train too.</p>
<p>It‚Äôs worth keeping in mind that despite our small differences; we‚Äôre all on the same team here. We all love functional programming and want to do our best to make it more popular. As best I can tell, the best strategy towards that aim is to come up with a consensus on how to do things, and to stop the needless infighting.</p>
<p>One love.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><code>Input</code> and <code>Output</code> are called <code>Reader</code> and <code>Writer</code> respectively in <code>freer-simple</code>. I decided to not use this terminology in order to prevent people from thinking that these are the same monads they‚Äôre used to.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>If you‚Äôre the maintainer of another effects package and want me to include it here, shoot me an email and make an argument!<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        ¬© 2015-2023 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

