<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Review: Clowns to the Left of Me, Jokers to the Right :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/clowns-jokers/index.html#">Review: Clowns to the Left of Me, Jokers to the Right</a></h1>
</header>
<p class="meta">
    <time>2022-01-23</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <p>Another week, another paper. This week it‚Äôs McBride‚Äôs <a href="http://strictlypositive.org/CJ.pdf">Clowns to the Left of Me, Jokers to the Right</a> (CJ). At a high level, CJ generalizes the results from <a href="http://strictlypositive.org/diff.pdf">The Derivative of a Regular Type is its Type of One-Hole Contexts</a>, wondering about what happens to a zipper when we don‚Äôt require the elements on either side to have the same type. This turns out to be not just an idle curiosity; the technique can be used to automatically turn a <a href="/blog/recursion-schemes">catamorphism</a> into a tail-recursive function. Why is THAT useful? It lets us run functional programs on stock hardware.</p>
<p>The paper begins by reminding us that all algebraic types can be built out of compositions of functors. Furthermore, any recursive ADT can be represented as the fix-point of its base functor. For example, rather than writing</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>we can instead pull the recursive inlining of <code>Expr</code> out into a type argument:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span></code></pre></div>
<p>and then can tie the knot:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="op">~=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span></code></pre></div>
<p>This is all standard <a href="/blog/recursion-schemes">bananas and barbed wires</a>, machinery, so refer to that if you‚Äôd like a deeper presentation than I‚Äôve provided here.</p>
<p>Rather than go through the paper‚Äôs presentation of this section, I will merely point out that <code>GHC.Generics</code> witnesses the ‚Äúall ADTs can be built out of functor composition,‚Äù and give <code>ExprF</code> a <code>Generic1</code> instance:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic1</span>)</span></code></pre></div>
<h2 id="clowns-and-jokers"><a href="#clowns-and-jokers" class="header-link">Clowns and Jokers<span class="header-link-emoji">üîó</span></a></h2>
<p>The title of CJ is a throw-back to <a href="https://www.youtube.com/watch?v=8StG4fFWHqg">some boomer song</a>, whose lyrics go</p>
<blockquote>
<p>Clowns to the left of me! Jokers to the right! Here I am stuck in the middle with you.</p>
</blockquote>
<p>while this is an apt idea for what‚Äôs going on in the paper, it‚Äôs also an awful mnemonic for those of us who don‚Äôt have strong associations with the song. My mnemonic is that ‚Äúclowns‚Äù come sooner in a lexicographical ordering than ‚Äújokers‚Äù do. Likewise, work you‚Äôve already done comes before work you haven‚Äôt yet done, which is <em>really</em> what CJ is about.</p>
<p>So here‚Äôs the core idea of CJ: we can ‚Äúdissect‚Äù a traversal into work we‚Äôve already done, and work we haven‚Äôt yet done. The work we‚Äôve already done can have a different type than the stuff left to do. These dissections are a rather natural way of representing a suspended computation. Along with the dissection itself is the ability to make progress. A dissection is spiritually a zipper with different types on either side, so we can make progress by transforming the focused element from ‚Äúto-do‚Äù to ‚Äúdone‚Äù, and then focusing on the next element left undone.</p>
<p>CJ implements all of this as a typeclass with fundeps, but I prefer type families. And furthermore, since this is all generic anyway, why not implement it over <code>GHC.Generics</code>? So the game here is thus to compute the type of the dissection for each of the <code>Generic1</code> constructors.</p>
<p>Begin by building the associated type family. The dissected version of a functor is necessarily a bifunctor, since we want slots to store our clowns and our jokers:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>As usual, we lift <code>GDissectable</code> over <code>M1</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> f <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (<span class="dt">M1</span> _1 _2 f) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">M1</span> _1 _2 f) <span class="ot">=</span> <span class="dt">GDissected</span> f</span></code></pre></div>
<p>Because a dissection is a separation of the work we have and haven‚Äôt done yet, the cases for <code>U1</code> and <code>K1</code> are uninspired ‚Äî there is no work to do, since they‚Äôre constants!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> <span class="dt">U1</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> <span class="dt">U1</span> <span class="ot">=</span> <span class="dt">K2</span> <span class="dt">Void</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> (<span class="dt">K1</span> _1 a) <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">K1</span> _1 a) <span class="ot">=</span> <span class="dt">K2</span> <span class="dt">Void</span></span></code></pre></div>
<p>where <code>K2</code> is the constant bifunctor:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">K2</span> a x y <span class="ot">=</span> <span class="dt">K2</span> a</span></code></pre></div>
<p>A different way to think about these dissections is as generalized zippers, which are the derivatives of their underlying types. Since <code>U1</code> and <code>K1</code> are constants, their derivatives are zero, which we have shown here via <code>K2 Void</code>.</p>
<p>The <code>Par1</code> generic constructor is used to encode usages of the functor‚Äôs type parameter. Under the view of the derivative, this is a linear use of the variable, and thus its derivative is one:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> <span class="dt">Par1</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> <span class="dt">Par1</span> <span class="ot">=</span> <span class="dt">K2</span> ()</span></code></pre></div>
<p>We‚Äôre left with sums and products. Sums are easy enough: the dissection of the sum is the sum of the dissections.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GDissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:+:</span> g) <span class="ot">=</span> <span class="dt">Sum2</span> (<span class="dt">GDissected</span> f) (<span class="dt">GDissected</span> g)</span></code></pre></div>
<p>where</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sum2</span> f g a b <span class="ot">=</span> <span class="dt">L2</span> (f a b) <span class="op">|</span> <span class="dt">R2</span> (g a b)</span></code></pre></div>
<p>Again, this aligns with our notion of the derivative, as well as with our intuition. If I want to suspend a coproduct computation half way, I either have an <code>L1</code> I need to suspend, or I have an <code>R1</code>. Nifty.</p>
<p>Finally we come to products:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GDissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:*:</span> g) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:*:</span> g) <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>         (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g))</span></code></pre></div>
<p>where</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Clown</span> p a b <span class="ot">=</span> <span class="dt">Clown</span> (p a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Joker</span> p a b <span class="ot">=</span> <span class="dt">Joker</span> (p b)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Product2</span> f g a b <span class="ot">=</span> <span class="dt">Product2</span> (f a b) (g a b)</span></code></pre></div>
<p>Let‚Äôs reason by intuition here first. I have both an <code>f</code> and a <code>g</code> stuck together. If I‚Äôd like to suspend a traversal through this thing, either I am suspended in the <code>f</code>, with <code>g</code> not yet touched (<code>Joker g</code>), or I have made it through the <code>f</code> entirely (<code>Clown f</code>), and have suspended inside of <code>g</code>.</p>
<p>Rather unsurprisingly (but also surprisingly, depending on your point of view!), this corresponds exactly to the quotient chain rule:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>‚ãÖ</mo><mrow></mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>‚ãÖ</mo><mrow></mrow><msup><mi>g</mi><mo mathvariant="normal" lspace="0em" rspace="0em">‚Ä≤</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">‚Ä≤</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>‚ãÖ</mo><mrow></mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\frac{d}{dx}[f(x)\cdot{}g(x)] = f(x)\cdot{}g&#39;(x) + f&#39;(x)\cdot{}g(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">‚Äã</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚Ä≤</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0519em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">‚Ä≤</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">‚ãÖ</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p>
<p>Curry-Howard strikes in the most interesting of places!</p>
<h2 id="getting-started"><a href="#getting-started" class="header-link">Getting Started<span class="header-link-emoji">üîó</span></a></h2>
<p>With our dissected types defined, it‚Äôs now time to put them to use. The paper jumbles a bunch of disparate pieces together, but I‚Äôm going to split them up for my personal understanding. The first thing we‚Äôd like to be able to do is to begin traversing a structure, which is to say, to split it into its first <code>joker</code> and the resulting dissection.</p>
<p>We‚Äôll make a helper structure:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Suspension</span> p k c j</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Done</span> (p c)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">More</span> j (k c j)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>A <code>Suspension p k c j</code> is either a <code>p</code> fully saturated with clowns (that is, we‚Äôve finished traversing it), or a joker and more structure (<code>k c j</code>) to be traversed. <code>k</code> will always be <code>GDissected p</code>, but for technical reasons, we‚Äôre going to need to keep it as a second type parameter.</p>
<p>Armed with <code>Suspension</code>, we‚Äôre ready to add our first method to <code>GDissectable</code>. <code>gstart</code> takes a fully-saturated <code>p j</code> and gives us back a suspension:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span></code></pre></div>
<p>These instances are all pretty easy. Given a double natural transformation over <code>Suspension</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>bihoist</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> (<span class="kw">forall</span> x<span class="op">.</span> p x <span class="ot">-&gt;</span> p&#39; x)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> a b<span class="op">.</span> k a b <span class="ot">-&gt;</span> k&#39; a b)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p  k  c j</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p&#39; k&#39; c j</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>bihoist _ g (<span class="dt">More</span> j kcj) <span class="ot">=</span> <span class="dt">More</span> j (g kcj)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>bihoist f _ (<span class="dt">Done</span> pc)    <span class="ot">=</span> <span class="dt">Done</span> (f pc)</span></code></pre></div>
<p><a href="https://haskellwingman.dev">Wingman</a> can write <code>U1</code>, <code>K1</code>, <code>Par1</code>, <code>M1</code> and <code>:+:</code> all for us:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  gstart _ <span class="ot">=</span> <span class="dt">Done</span> <span class="dt">U1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">K1</span> a) <span class="ot">=</span> <span class="dt">Done</span> (<span class="dt">K1</span> a)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">Par1</span> j) <span class="ot">=</span> <span class="dt">More</span> j (<span class="dt">K2</span> ())</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">M1</span> fj) <span class="ot">=</span> bihoist <span class="dt">M1</span> <span class="fu">id</span> <span class="op">$</span> gstart fj</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">L1</span> fj) <span class="ot">=</span> bihoist <span class="dt">L1</span> <span class="dt">L2</span> <span class="op">$</span> gstart fj</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">R1</span> gj) <span class="ot">=</span> bihoist <span class="dt">R1</span> <span class="dt">R2</span> <span class="op">$</span> gstart gj</span></code></pre></div>
<p>For products, <code>gstart</code> attempts to start the first element, and hoists its continuation if it got <code>More</code>. Otherwise, it starts the second element. This is done with a couple of helper functions:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mindp</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">GDissectable</span> g</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Suspension</span> f (<span class="dt">GDissected</span> f) c j</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> g j</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> (f <span class="op">:*:</span> g)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                 (<span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                       (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g)))</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                 c j</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>mindp (<span class="dt">More</span> j pd) qj <span class="ot">=</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">L2</span> <span class="op">$</span> <span class="dt">Product2</span> pd <span class="op">$</span> <span class="dt">Joker</span> qj</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>mindp (<span class="dt">Done</span> pc) qj <span class="ot">=</span> mindq pc (gstart qj)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>mindq</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> f c</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> g (<span class="dt">GDissected</span> g) c j</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> (f <span class="op">:*:</span> g)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>                 (<span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>                       (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g)))</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>                 c j</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>mindq pc (<span class="dt">More</span> j qd) <span class="ot">=</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">R2</span> <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Clown</span> pc) qd</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>mindq pc (<span class="dt">Done</span> qc) <span class="ot">=</span> <span class="dt">Done</span> (pc <span class="op">:*:</span> qc)</span></code></pre></div>
<p>and then</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  gstart (pj <span class="op">:*:</span> qj) <span class="ot">=</span> mindp (gstart <span class="op">@</span>f pj) qj</span></code></pre></div>
<h2 id="making-progress"><a href="#making-progress" class="header-link">Making Progress<span class="header-link-emoji">üîó</span></a></h2>
<p>Getting started is nice, but it‚Äôs only the first step in the process. Once we have a <code>More</code> suspension, how do we move the needle? Enter <code>gproceed</code>, which takes a clown to fill the current hole and a suspension, and gives back a new suspension corresponding to the next joker.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  gproceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span></code></pre></div>
<p>By pumping <code>gproceed</code>, we can make our way through a suspension, transforming each joker into a clown. Eventually our suspension will be <code>Done</code>, at which point we‚Äôve traversed the entire data structure.</p>
<p>For the most part, <code>gproceed</code> is also Wingman-easy:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- U1</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  gproceed _ (<span class="dt">K2</span> v) <span class="ot">=</span> absurd v</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- K1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  gproceed _ (<span class="dt">K2</span> v) <span class="ot">=</span> absurd v</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  gproceed c _ <span class="ot">=</span> <span class="dt">Done</span> (<span class="dt">Par1</span> c)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>  gproceed fc <span class="ot">=</span> bihoist <span class="dt">M1</span> <span class="fu">id</span> <span class="op">.</span> gproceed fc</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  gproceed c (<span class="dt">L2</span> dis) <span class="ot">=</span> bihoist <span class="dt">L1</span> <span class="dt">L2</span> <span class="op">$</span> gproceed c dis</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  gproceed c (<span class="dt">R2</span> dis) <span class="ot">=</span> bihoist <span class="dt">R1</span> <span class="dt">R2</span> <span class="op">$</span> gproceed c dis</span></code></pre></div>
<p>Products are again a little tricky. If we‚Äôre still working on the left half, we want to proceed through it, unless we finish, in which case we want to start on the right half. When the right half finishes, we need to lift that success all the way through the product. Our helper functions <code>mindp</code> and <code>mindq</code> take care of this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  gproceed c (<span class="dt">L2</span> (<span class="dt">Product2</span> pd (<span class="dt">Joker</span> qj))) <span class="ot">=</span> mindp (gproceed <span class="op">@</span>f c pd) qj</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  gproceed c (<span class="dt">R2</span> (<span class="dt">Product2</span> (<span class="dt">Clown</span> pc) qd)) <span class="ot">=</span> mindq pc (gproceed <span class="op">@</span>g c qd)</span></code></pre></div>
<h2 id="plugging-holes"><a href="#plugging-holes" class="header-link">Plugging Holes<span class="header-link-emoji">üîó</span></a></h2>
<p>McBride points out that if we forget the distinction between jokers and clowns, what we have is a genuine zipper. In that case, we can just plug the existing hole, and give back a fully saturated type. This is witnessed by the final method of <code>GDissectable</code>, <code>gplug</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  gproceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  gplug ::</span> x <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p x x <span class="ot">-&gt;</span> p x</span></code></pre></div>
<p>Again, things are Wingman-easy. This time, we can even synthesize the product case for free:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- U1</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  gplug _ (<span class="dt">K2</span> vo) <span class="ot">=</span> absurd vo</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- K1</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  gplug _ (<span class="dt">K2</span> vo) <span class="ot">=</span> absurd vo</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  gplug x _ <span class="ot">=</span> <span class="dt">Par1</span> x</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  gplug x dis <span class="ot">=</span> <span class="dt">M1</span> <span class="op">$</span> gplug x dis</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  gplug x (<span class="dt">L2</span> dis) <span class="ot">=</span> <span class="dt">L1</span> (gplug x dis)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  gplug x (<span class="dt">R2</span> dis) <span class="ot">=</span> <span class="dt">R1</span> (gplug x dis)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  gplug x (<span class="dt">L2</span> (<span class="dt">Product2</span> f (<span class="dt">Joker</span> g))) <span class="ot">=</span> gplug x f <span class="op">:*:</span> g</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  gplug x (<span class="dt">R2</span> (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) g)) <span class="ot">=</span> f <span class="op">:*:</span> gplug x g</span></code></pre></div>
<p>This sums up <code>GDissectable</code>.</p>
<h2 id="nongeneric-representations"><a href="#nongeneric-representations" class="header-link">Nongeneric Representations<span class="header-link-emoji">üîó</span></a></h2>
<p><code>GDissectable</code> is great and all, but it would be nice to not need to deal with generic representations. This bit isn‚Äôt in the paper, but we can lift everything back into the land of real types by making a copy of <code>GDissectable</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> p, <span class="dt">Bifunctor</span> (<span class="dt">Dissected</span> p)) <span class="ot">=&gt;</span> <span class="dt">Dissectable</span> p <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Dissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  start ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) c j</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  proceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">Dissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) c j</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  plug ::</span> x <span class="ot">-&gt;</span> <span class="dt">Dissected</span> p x x <span class="ot">-&gt;</span> p x</span></code></pre></div>
<p>and then a little machinery to do <code>-XDerivingVia</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Generically</span> p a <span class="ot">=</span> <span class="dt">Generically</span> {<span class="ot"> unGenerically ::</span> p a }</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> ( <span class="dt">Generic1</span> p</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>         , <span class="dt">Functor</span> p</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>         , <span class="dt">Bifunctor</span> (<span class="dt">GDissected</span> (<span class="dt">Rep1</span> p))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>         , <span class="dt">GDissectable</span> (<span class="dt">Rep1</span> p)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>         )</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">Dissectable</span> (<span class="dt">Generically</span> p) <span class="kw">where</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Dissected</span> (<span class="dt">Generically</span> p) <span class="ot">=</span> <span class="dt">GDissected</span> (<span class="dt">Rep1</span> p)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  start (<span class="dt">Generically</span> pj) <span class="ot">=</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    bihoist (<span class="dt">Generically</span> <span class="op">.</span> to1) <span class="fu">id</span> <span class="op">$</span> gstart <span class="op">$</span> from1 pj</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  proceed x <span class="ot">=</span> bihoist (<span class="dt">Generically</span> <span class="op">.</span> to1) <span class="fu">id</span> <span class="op">.</span> gproceed x</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  plug x <span class="ot">=</span> <span class="dt">Generically</span> <span class="op">.</span> to1 <span class="op">.</span> gplug x</span></code></pre></div>
<p>With this out of the way, we can now get <code>Dissectable</code> for free on <code>ExprF</code> from above:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic</span>, <span class="dt">Generic1</span>, <span class="dt">Show</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">ExprF</span>)</span></code></pre></div>
<h2 id="dissectable-fmap-sequence-and-catamorphisms"><a href="#dissectable-fmap-sequence-and-catamorphisms" class="header-link">Dissectable Fmap, Sequence and Catamorphisms<span class="header-link-emoji">üîó</span></a></h2>
<p>Given a <code>Dissectable</code> constraint, we can write a version of <code>fmap</code> that explicitly walks the traversal, transforming each element as it goes. Of course, this is silly, since we already have <code>Functor</code> for any <code>Dissectable</code>, but it‚Äôs a nice little sanity check:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tmap ::</span> <span class="kw">forall</span> p a b<span class="op">.</span> <span class="dt">Dissectable</span> p <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a <span class="ot">-&gt;</span> p b</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>tmap fab <span class="ot">=</span> pump <span class="op">.</span> start</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    pump ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) b a <span class="ot">-&gt;</span> p b</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    pump (<span class="dt">More</span> a dis) <span class="ot">=</span> pump <span class="op">$</span> proceed (fab a) dis</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    pump (<span class="dt">Done</span> j) <span class="ot">=</span> j</span></code></pre></div>
<p>We start the dissection, and then pump its suspension until we‚Äôre done, applying <code>fab</code> as we go.</p>
<p>Perhaps more interestingly, we can <em>almost</em> get <code>Traversable</code> with this machinery:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tsequence ::</span> <span class="kw">forall</span> p f a<span class="op">.</span> (<span class="dt">Dissectable</span> p, <span class="dt">Monad</span> f) <span class="ot">=&gt;</span> p (f a) <span class="ot">-&gt;</span> f (p a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>tsequence <span class="ot">=</span> pump <span class="op">.</span> start</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    pump ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) a (f a) <span class="ot">-&gt;</span> f (p a)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    pump (<span class="dt">More</span> fa dis) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">&lt;-</span> fa</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>      pump <span class="op">$</span> proceed a dis</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    pump (<span class="dt">Done</span> pa) <span class="ot">=</span> <span class="fu">pure</span> pa</span></code></pre></div>
<p>It‚Äôs not quite <code>Traversable</code>, since it requires a <code>Monad</code> instance instead of merely <code>Applicative</code>. Why‚Äôs that? I don‚Äôt know, but <a href="https://monoidmusician.github.io/monoidmusician.html">MonoidMusician</a> suggested it‚Äôs because applicatives don‚Äôt care about the order in which you sequence them, but this <code>Dissectable</code> is very clearly an explicit ordering on the data dependencies in the container. Thanks MonoidMusician!</p>
<p>Finally, we can implement the stack-based, tail-recursive catamorphism that we‚Äôve been promised all along. The idea is simple ‚Äî we use the <code>Dissected</code> type as our stack, pushing them on as we unfold the functor fixpoint, and resuming them as we finish calls.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tcata ::</span> <span class="kw">forall</span> p v<span class="op">.</span> <span class="dt">Dissectable</span> p <span class="ot">=&gt;</span> (p v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">Fix</span> p <span class="ot">-&gt;</span> v</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>tcata f t <span class="ot">=</span> load&#39; t []</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    load&#39;</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Fix</span> p</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    load&#39; (<span class="dt">Fix</span> t) stk <span class="ot">=</span> next (start t) stk</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    next</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) v (<span class="dt">Fix</span> p)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    next (<span class="dt">More</span> p dis) stk <span class="ot">=</span> load&#39; p (dis <span class="op">:</span> stk)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    next (<span class="dt">Done</span> p) stk <span class="ot">=</span> unload&#39; (f p) stk</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    unload&#39;</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> v</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    unload&#39; v [] <span class="ot">=</span> v</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    unload&#39; v (pd <span class="op">:</span> stk) <span class="ot">=</span> next (proceed v pd) stk</span></code></pre></div>
<p>Compare this with the usual implementation of <code>cata</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>cata f (<span class="dt">Fix</span> fc) <span class="ot">=</span> f <span class="op">$</span> <span class="fu">fmap</span> (cata f) fc</span></code></pre></div>
<p>which just goes absolutely ham, expanding nodes and fmapping over them, destroying any chance at TCO.</p>
<p>The paper also has something to say about free monads, but it wasn‚Äôt able to hold my attention. It‚Äôs an application of this stuff, though in my opinion the approach is much more interesting than its applications. So we can pretend the paper is done here.</p>
<p>But that‚Äôs not all‚Ä¶</p>
<h2 id="functor-composition"><a href="#functor-composition" class="header-link">Functor Composition<span class="header-link-emoji">üîó</span></a></h2>
<p>Although the paper doesn‚Äôt present it, there should also be here another instance of <code>GDissectable</code> for functor composition. Based on the composite chain rule, it should be:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Dissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:.:</span> g) <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:.:</span> g) <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Product2</span> (<span class="dt">Compose2</span> (<span class="dt">Dissected</span> f) g)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>             (<span class="dt">GDissected</span> g)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Compose2</span> f g c j <span class="ot">=</span> <span class="dt">Compose2</span> (f (g c) (g j))</span></code></pre></div>
<p><code>GDissected</code> is clearly correct by the chain rule, but <code>Compose2</code> isn‚Äôt as clear. We stick the clowns in the left side of the composite of <code>f . g</code>, and the jokers on the right.</p>
<p>Intuitively, we‚Äôve done the same trick here as the stack machine example. The first element of the <code>Product2</code> in <code>GDissected</code> keeps track of the context of the <code>f</code> traversal, and the second element is the <code>g</code> traversal we‚Äôre working our way through. Whenever the <code>g</code> finishes, we can get a new <code>g</code> by continuing the <code>f</code> traversal!</p>
<p>It‚Äôs important to note that I didn‚Äôt actually reason this out‚ÄîI just wrote the chain rule from calculus and fought with everything until it typechecked. Then I rewrote my examples that used <code>:+:</code> and <code>:*:</code> to instead compose over <code>Either</code> and <code>(,)</code>, and amazingly <em>I got the same results!</em> Proof by typechecker!</p>
<p>After a truly devoted amount of time, I managed to work out <code>gstart</code> for composition as well.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">Comp1</span> fg) <span class="ot">=</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> start <span class="op">@</span>f <span class="op">$</span> fg <span class="kw">of</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">More</span> gj gd <span class="ot">-&gt;</span> continue gj gd</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Done</span> f <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> f</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      continue</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">          ::</span> g j</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Dissected</span> f (g c) (g j)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Suspension</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>               (f <span class="op">:.:</span> g)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>               (<span class="dt">Product2</span> (<span class="dt">Compose2</span> (<span class="dt">Dissected</span> f) g) (<span class="dt">GDissected</span> g))</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>               c j</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>      continue gj gd <span class="ot">=</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> gstart gj <span class="kw">of</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>          <span class="dt">More</span> j gd&#39; <span class="ot">-&gt;</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Compose2</span> gd) gd&#39;</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Done</span> g <span class="ot">-&gt;</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> progress <span class="op">@</span>f g gd <span class="kw">of</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>              <span class="dt">More</span> gj gd <span class="ot">-&gt;</span> continue gj gd</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Done</span> fg <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> fg</span></code></pre></div>
<p>The idea is that you start <code>f</code>, which gives you a <code>g</code> to start, and you need to keep starting <code>g</code> until you find one that isn‚Äôt immediately done.</p>
<p><code>gproceed</code> is similar, except dual. If all goes well, we can just proceed down the <code>g</code> we‚Äôre currently working on. The tricky part is now when we finish a <code>g</code> node, we need to keep proceeding down <code>f</code> nodes until we find one that admits a <code>More</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  gproceed c (<span class="dt">Product2</span> cfg<span class="op">@</span>(<span class="dt">Compose2</span> fg) gd) <span class="ot">=</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> gproceed <span class="op">@</span>g c gd <span class="kw">of</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">More</span> j gd <span class="ot">-&gt;</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> cfg gd</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Done</span> gc <span class="ot">-&gt;</span> finish gc</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- finish</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">--     :: g c</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">--     -&gt; Suspension</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">--          (f :.: g)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>      <span class="co">--          (Product2 (Compose2 (Dissected f) g) (GDissected g))</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">--          c j</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>      finish gc <span class="ot">=</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> proceed <span class="op">@</span>f gc fg <span class="kw">of</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>          <span class="dt">More</span> gj gd <span class="ot">-&gt;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> gstart gj <span class="kw">of</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>              <span class="dt">More</span> j gd&#39; <span class="ot">-&gt;</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Compose2</span> gd) gd&#39;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Done</span> gc <span class="ot">-&gt;</span> finish gc</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Done</span> f <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> f</span></code></pre></div>
<p>I‚Äôm particularly proud of this; not only did I get the type for <code>GDissected</code> right on my first try, I was also capable of working through these methods, which probably took upwards of two hours.</p>
<p><code>GHC.Generics</code> isn‚Äôt so kind as to just let us test it, however. Due to some quirk of the representation, we need to add an instance for <code>Rec1</code>, which is like <code>K1</code> but for types that use the functor argument. We can give an instance of <code>GDissectable</code> by transferring control back to <em><code>Dissectable</code></em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Generic1</span> f, <span class="dt">Dissectable</span> f) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (<span class="dt">Rec1</span> f) <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">Rec1</span> f) <span class="ot">=</span> <span class="dt">Dissected</span> f</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  gstart (<span class="dt">Rec1</span> f) <span class="ot">=</span> bihoist <span class="dt">Rec1</span> <span class="fu">id</span> <span class="op">$</span> start f</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  gproceed c f <span class="ot">=</span> bihoist <span class="dt">Rec1</span> <span class="fu">id</span> <span class="op">$</span> proceed c f</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  gplug x gd <span class="ot">=</span> <span class="dt">Rec1</span> <span class="op">$</span> plug x gd</span></code></pre></div>
<p>Now, a little work to be able to express <code>AddF</code> as a composition, rather than a product:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a <span class="ot">=</span> <span class="dt">Pair</span> a a</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>, <span class="dt">Generic1</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">Pair</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> via <span class="dt">Generically</span> (<span class="dt">Either</span> a) <span class="kw">instance</span> <span class="dt">Dissectable</span> (<span class="dt">Either</span> a)</span></code></pre></div>
<p>and we can rewrite <code>ExprF</code> as a composition of functors:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF&#39;</span> a <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Either</span> <span class="dt">Int</span> (<span class="dt">Pair</span> a))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic</span>, <span class="dt">Generic1</span>, <span class="dt">Show</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">ExprF&#39;</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ValF&#39;</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExprF&#39;</span> a</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">ValF&#39;</span> a <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Left</span> a)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">AddF&#39;</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ExprF&#39;</span> a</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">AddF&#39;</span> a b <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Right</span> (<span class="dt">Pair</span> a b))</span></code></pre></div>
<p>Everything typechecks, and <code>tcata</code> gives us the same results for equivalent values over <code>ExprF</code> and <code>ExprF&#39;</code>. As one final sanity check, we can compare the computer dissected types:</p>
<pre><code>*&gt; :kind! Dissected ExprF
Dissected ExprF :: * -&gt; * -&gt; *
= Sum2
    (K2 Void)
    (Sum2
       (Product2
          (K2 ())
          (Joker Par1))
       (Product2
          (Clown Par1)
          (K2 ())))

*&gt; :kind! Dissected ExprF&#39;
Dissected ExprF&#39; :: * -&gt; * -&gt; *
= Product2
    (Compose2 (Sum2 (K2 Void) (K2 ())) (Rec1 Pair))
    (Sum2
       (Product2
          (K2 ())
          (Joker Par1))
       (Product2
          (Clown Par1)
          (K2 ())))</code></pre>
<p>They‚Äôre not equal, but are they isomorphic? We should hope so! The first one is <code>Sum2 0 x</code>, which is clearly isomorphic to <code>x</code>. The second is harder:</p>
<p><code>Product (Compose2 (Sum2 (K2 Void) (K2 ())) (Rec1 Pair)) x</code></p>
<p>If that first argument to <code>Product</code> is 1, then these two types are isomorphic. So let‚Äôs see:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Compose2</span> (<span class="dt">Sum2</span> (<span class="dt">K2</span> <span class="dt">Void</span>) (<span class="dt">K2</span> ())) (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> symbolic rewriting</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Compose2</span> (<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>) (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">0</span> is an identity for <span class="op">+</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Compose2</span> <span class="dv">1</span> (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> definition <span class="kw">of</span> <span class="dt">Compose2</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">K2</span> () (<span class="dt">Rec1</span> <span class="dt">Pair</span> c) (<span class="dt">Rec1</span> <span class="dt">Pair</span> j)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">K2</span> () is still <span class="dv">1</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span></span></code></pre></div>
<p>Look at that, baby. Isomorphic types, that compute the same answer.</p>
<p>As usual, today‚Äôs code is available on <a href="https://gist.github.com/isovector/8a02f5c21bdb5ff5034b661ef9d28d10">Github</a>.</p>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        ¬© 2015-2022 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

