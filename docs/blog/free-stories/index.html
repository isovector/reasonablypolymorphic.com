<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <base href="/"></base>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Towards Procedurally Generated Stories via Free Monads :: Reasonably Polymorphic</title>
        <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
        <link href="/atom.xml" rel="alternate" title="Reasonably Polymorphic - Atom" type="application/atom+xml" />
        <link href="/feed.rss" rel="alternate" title="Reasonably Polymorphic - RSS" type="application/rss+xml" />

        <link rel="stylesheet" href="/css/style.css" />
        <link rel="stylesheet" href="/css/katex.min.css" />
        <link rel="stylesheet" href="/css/agda-cats.css" />

        <script src="/equations.js"></script>
        <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

        </head>
        <body>
<div class="main">

<article>
<header>
  <h1><a href="/blog/free-stories/index.html#">Towards Procedurally Generated Stories via Free Monads</a></h1>
</header>
<p class="meta">
    <time>2016-06-02</time>

    <span class="tags">
        
    </span>
</p>
<div class="content">
    <blockquote>
<p>Strongly inspired by Dave Laing‚Äôs fantastic series <a href="http://dlaing.org/cofun/">Cofun with cofree comonads</a>. This post and the next are mostly rehashes of (superior) blog posts of his, but there is novel material to be covered soon.</p>
</blockquote>
<p>I am eternally torn between a dichotomy I like to call ‚Äúfinish shit vs.¬†solve cool problems.‚Äù Finishing shit requires a lot of polish around the boring corners of a project, after all the cool stuff has been solved ‚Äì and there‚Äôs always another cool problem waiting to be solved.</p>
<p>In particular, this dichotomy has recently manifested itself as ‚ÄúI should make an RPG vs.¬†I already know how to make RPGs, it‚Äôd be fun creatively but gee that sounds like a lot of tedium and wouldn‚Äôt teach me much in the end, except for maybe the value of hard work.‚Äù</p>
<p><img src="/images/rpg.jpg" title="I should make an RPG" /></p>
<p>Then I realized making an RPG doesn‚Äôt need to be tedious and boring. I‚Äôll just teach a computer how to generate an RPG. Goldmine genius idea. I don‚Äôt know how to make a procedurally generated RPG, but really, how hard could it be?</p>
<p>This post is the first of many on just how hard it can be.</p>
<h2 id="the-motivation"><a href="#the-motivation" class="header-link">The Motivation<span class="header-link-emoji">üîó</span></a></h2>
<p>People have been making <a href="https://en.wikipedia.org/wiki/Roguelike">roguelikes</a> for decades. While roguelikes are spectacularly cool, they‚Äôre not really RPGs in the more common sense of the word. There‚Äôs no narrative to a roguelike, you just adventure around and kill shit.</p>
<p>The RPG that inspired me to make an RPG was <a href="https://en.wikipedia.org/wiki/EarthBound">Earthbound</a>, which is known for its quirky atmosphere and for managing to pull of some sort of weird-humorous-plot-mixed-with-lovecraftian-horror juxtaposition. Earthbound <em>feels</em> like it might have been made on drugs, but somehow manages to still be a fantastic experience.</p>
<p><em>This</em> is the kind of thing I want to generate. Lots of games have tried to generate interesting worlds and plots, but, at least when I was in the games industry, the state of the art was prefabricating modules and stitching them together. Sure, it‚Äôs hard to generate solid plots, but I don‚Äôt think its intractable.</p>
<p>I think the problem might have been this: this problem is fundamentally functional; any imperative approach is going to be a Bad time.</p>
<p>Maybe. Lots of this is vaporware still, but it <em>feels</em> right, and I have a plausible path to actually executing on it.</p>
<h2 id="the-idea"><a href="#the-idea" class="header-link">The Idea<span class="header-link-emoji">üîó</span></a></h2>
<p>Enough run-around. Are you ready to hear my revolutionary idea to generate procedural RPGs with coherent and interesting stories?</p>
<ol type="1">
<li>Build a datastructure representing a story.</li>
<li>Turn this datastructure into a game.</li>
</ol>
<p>Amazing, right?</p>
<p>Okay, not that amazing, but here‚Äôs the rub. Instead of building this datastructure by hand, we‚Äôll write a domain specific language (DSL) which will generate the datastructure for us. And then if we then embed this language into Haskell, we‚Äôll lift all of the expressiveness of Haskell into our DSL. If we limit the DSL to a few number of primitive operations, and implement all of the interesting pieces as combinators on top, it will be easy to abstract over, and more importantly, to interpret.</p>
<p>This interpretation step is, unsurprisingly, where the ‚Äúmagic‚Äù happens.</p>
<p>Separating the <em>structure</em> of what we want to do (which is what the DSL provides us) from <em>how</em> we do it means we can do different things with the same data. For example, given a basic plot skeleton, we can run over it, and with the help of a random number generator, determine a theme. Then, given the theme and the plot skeleton, build necessary locations to help advance the plot from one scene to the next. Then, with all of this, we can build intermediate landscapes to stitch the locations together. And so on and so forth.</p>
<p>There are lots of potential failure modes here, but the approach seems feasible.</p>
<h2 id="the-pieces"><a href="#the-pieces" class="header-link">The Pieces<span class="header-link-emoji">üîó</span></a></h2>
<p>So I went through a bunch of games whose stories I adore, and I attempted to deconstruct them into their primitive operations. A simplified datastructure of what I came up with is provided here:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Story</span> <span class="ot">=</span> [<span class="dt">StoryPrim</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StoryPrim</span> <span class="ot">=</span> <span class="dt">Change</span> <span class="dt">Character</span> <span class="dt">ChangeType</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Interrupt</span> <span class="dt">Story</span> <span class="dt">Story</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ChangeType</span> <span class="ot">=</span> <span class="dt">Introduce</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Die</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Leave</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Arrive</span> <span class="dt">Location</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Kill</span> <span class="dt">Character</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">|</span> <span class="dt">Learn</span> <span class="dt">ChangeResult</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ChangeResult</span> <span class="ot">=</span> <span class="dt">ChangeResult</span> <span class="dt">Character</span> <span class="dt">ChangeType</span></span></code></pre></div>
<p>which is to say, a <code>Story</code> is a list of <code>StoryPrim</code>s, which is either a change in character state, or one <code>Story</code> being interrupted by another (eg. if someone‚Äôs murder attempt is foiled by an unexpected arrival.)</p>
<p>This isn‚Äôt comprehensive enough to generate entire stories, but it‚Äôs definitely good enough to motivate the remainder of this post.</p>
<h2 id="free-monads"><a href="#free-monads" class="header-link">Free Monads<span class="header-link-emoji">üîó</span></a></h2>
<p>Let‚Äôs take a little break and talk some math.</p>
<p>Free monads are one of the neatest things I‚Äôve learned about recently. The definition (in Haskell) of a free monad over a functor <code>f</code> is this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> f a <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">Bind</span> (f (<span class="dt">Free</span> f a))</span></code></pre></div>
<p>Which can be thought of a recursive datastructure which bottoms out with a <code>Pure</code> or recurses with an <code>Bind</code>. The definition was hard for me to work my head around, so let‚Äôs give it a concrete functor and see what pops out:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> [] a <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Bind</span> [<span class="dt">Free</span> [] a]</span></code></pre></div>
<p>If we squint, this is actually just a tree where <code>Bind</code> is a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-ary</span> branch, and <code>Pure</code> is a value at a leaf. So a tree is just a special case of the free monad. That‚Äôs kinda hot, if you‚Äôre as into this stuff as much as I am.</p>
<p>But what‚Äôs more hot is that given any <code>instance Functor f</code>, <code>Free f</code> forms a monad:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bind</span> m <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Bind</span> (<span class="fu">fmap</span> (<span class="op">&gt;&gt;=</span> f) m)</span></code></pre></div>
<p>It‚Äôs probably the dumbest <code>Monad</code> instance imaginable, but hey, it adheres to the monad laws, and that‚Äôs really all we ask for. The laws are satisfied only in a very trivial sense, in that all we‚Äôve done here is encode the rules of <code>return</code> and <code>(&gt;&gt;=)</code> into our datastructure which is to say, we haven‚Äôt done any processing yet. We‚Äôll return to this in a moment.</p>
<p>It‚Äôs called ‚Äúfree‚Äù for exactly this reason of trivially satisfying the laws ‚Äì given any functor <code>f</code> we can get an (admittedly stupid) monad over <code>f</code> for free.</p>
<p>Because our free monad is just a datastructure in the exact shape of a computation we <em>would</em> want to carry out over its contents, it‚Äôs easy to write an interpreter for it. Or several.</p>
<p>See where I‚Äôm going with this?</p>
<p>Here‚Äôs the kicker: <strong>Free monads turn out to be the abstraction behind DSLs because they encode the <em>structure</em> of a computation, without imposing an <em>interpretation</em> over it.</strong></p>
<p>But remember, getting a free monad requires having a functor. If we can find a means of encoding our <code>Story</code> grammar above as a functor, we can lift it into a DSL via <code>Free</code>.</p>
<h2 id="the-command-functor"><a href="#the-command-functor" class="header-link">The Command Functor<span class="header-link-emoji">üîó</span></a></h2>
<p>So we need a means of getting a <code>Functor</code> instance for our <code>Story</code> type described above. But how?</p>
<p>Let‚Äôs start playing madlibs with what we know.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Story</span> a <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">StoryF</span> a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StoryF</span> a <span class="ot">=</span> <span class="co">-- ???</span></span></code></pre></div>
<p>Looking at the definition of <code>Free</code> specialized over our functor <code>StoryF</code> once again hints us in the right direction:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Story</span> a <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Bind</span> (<span class="dt">StoryF</span> (<span class="dt">Story</span> a))</span></code></pre></div>
<p>The polymorphic variable of our <code>StoryF</code> functor is only ever going to be a <code>Story a</code>, which is to say a pure <code>a</code> or a bind computing more of the final value.</p>
<p>So our polymorphic type variable is the type of the continuing computation. Because <code>Pure</code> from <code>Free</code> takes care of how computations terminate, our functor should always have a continuing computation. Voila:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StoryF</span> a <span class="ot">=</span> <span class="dt">Change</span> <span class="dt">Character</span> <span class="dt">ChangeType</span> (<span class="dt">ChangeResult</span> <span class="ot">-&gt;</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="dt">Interrupt</span> (<span class="dt">Story</span> ()) (<span class="dt">Story</span> ()) a</span></code></pre></div>
<p>contrasting this against our old <code>StoryPrim</code>, we‚Äôve just added a new product involving <code>a</code> to all each of our sum terms. Again, <code>a</code> should be considered to be the type of the continuing computation.</p>
<p>But what‚Äôs this funny <code>ChangeResult -&gt; a</code> thing? Well, recall that we wanted a <code>Change</code> to return a <code>ChangeResult</code> indicating what changed, which is to say this result should be a <em>parameter</em> to the rest of the computation ‚Äì thus our function type<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p><code>StoryF</code> is what‚Äôs known as our command functor, because as we will see, its constructors will eventually act as commands in our DSL.</p>
<p>But wait! Not so fast. We haven‚Äôt yet provided a <code>Functor</code> instance for <code>StoryF</code>. It‚Äôs trivial, but we present it here for completeness:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">StoryF</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Change</span> c ct k)    <span class="ot">=</span> <span class="dt">Change</span> c ct (f <span class="op">.</span> k)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Interrupt</span> s s&#39; k) <span class="ot">=</span> <span class="dt">Interrupt</span> s s&#39; (f k)</span></code></pre></div>
<p>And so <code>StoryF</code> is now a <code>Functor</code>, which means that <code>Free StoryF</code> is a <code>Monad</code>, which means that we can use <code>do</code> notation inside of it! We‚Äôre most of the way to our DSL!</p>
<p>All that‚Äôs left is to lift our <code>StoryF</code> data constructors into <code>Story</code> constructors. The details of this are a little messy, but luckily <code>liftF</code> from the <code>free</code> package does most of the manual labor for us.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">change ::</span> <span class="dt">Character</span> <span class="ot">-&gt;</span> <span class="dt">ChangeType</span> <span class="ot">-&gt;</span> <span class="dt">Story</span> <span class="dt">ChangeResult</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>change c ct <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Change</span> c ct <span class="fu">id</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">interrupt ::</span> <span class="dt">Story</span> () <span class="ot">-&gt;</span> <span class="dt">Story</span> () <span class="ot">-&gt;</span> <span class="dt">Story</span> ()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>interrupt s s&#39; <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Interrupt</span> s s&#39; ()</span></code></pre></div>
<p>and that‚Äôs it! Short of some helpful combinators, we‚Äôre done! We can now write basic stories in Haskell using <code>do</code> notation!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myStory ::</span> <span class="dt">Story</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>myStory <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mandalf <span class="ot">=</span> <span class="dt">Character</span> <span class="st">&quot;Mandalf the Wizard&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        orcLord <span class="ot">=</span> <span class="dt">Character</span> <span class="st">&quot;Orclord Lord of the Orcs&quot;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        orcBaby <span class="ot">=</span> <span class="dt">Character</span> <span class="st">&quot;Orclord&#39;s Child&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    sadness <span class="ot">&lt;-</span> kill mandalf orcLord</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    change orcBaby <span class="op">$</span> <span class="dt">Learn</span> sadness</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="dv">5</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">die ::</span> <span class="dt">Character</span> <span class="ot">-&gt;</span> <span class="dt">Story</span> <span class="dt">ChangeResult</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>die who <span class="ot">=</span> change who <span class="dt">Die</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="ot">kill ::</span> <span class="dt">Character</span> <span class="ot">-&gt;</span> <span class="dt">Character</span> <span class="ot">-&gt;</span> <span class="dt">Story</span> <span class="dt">ChangeResult</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>kill who whom <span class="ot">=</span> change who (<span class="dt">Kill</span> whom) <span class="op">&lt;*</span> die whom</span></code></pre></div>
<p>As far as stories go, one about a child learning of its father‚Äôs death is probably not going to win any feel-good-novella-of-the-year, but the example serves to showcase several things:</p>
<ul>
<li>We can build abstractions with standard Haskell combinators (eg. killing someone implies that they die.)</li>
<li>The fact that this typechecks shows that our language is expressive enough for characters to learn of the arbitrary actions of one another (including learning that they‚Äôve learned something.) Furthermore, knowledge is first-class and can be passed around the story however we see fit.</li>
<li>Like all monads, our DSL can describe things that happen <em>while</em> returning potentially unrelated data. The <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> above is meaningless, but allows us to interleave story descriptions with arbitrary computations.</li>
</ul>
<p>This seems like a good place to stop for today ‚Äì we‚Äôve covered a lot of ground. Next time we‚Äôll discuss how we can use cofree comonads (I am <em>not</em> kidding here) to build an interpreter for our DSL.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>If this isn‚Äôt immediately evident to you, <a href="https://en.wikibooks.org/wiki/Haskell/do_notation#Translating_the_bind_operator">make sure you understand</a> how <code>do</code> desugaring works.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

<p class="meta">
</p>

</div>

<div class="comments">
  <script src="https://utteranc.es/client.js" repo="isovector/reasonablypolymorphic.com" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</div>
</article>

</div>
    <nav>
        <h1><a href="/">REASONABLY<br />POLYMORPHIC</a></h1>
    
        <p> Hi there. I&#39;m <strong>Sandy Maguire</strong>. I like improving life and
        making cool things.</p>
    
        <p>If you want to get in touch, I&#39;d love to hear from you! Send me an
        email; you can contact me via <tt><b>sandy</b></tt> at <tt><b>sandymaguire.me</b></tt>.</p>
    
        <h2>SITE LINKS</h2>
        <ul>
            <li><a href="/">Archives</a></li>
            <li><a href="/talks">Talks</a></li>
        </ul>
    
        <h2>THINGS I MAKE</h2>
        <ul>
            <li>Code on <a href="http://github.com/isovector">github</a></li>
            <li>Book <a href="/book/preface.html">archive</a></li>
            <li>My other <a href="http://sandymaguire.me">blog</a></li>
        </ul>
    
        <h2>WHAT I&#39;M DOING</h2>
        <ul>
            <!-- <li><a href="/erdos">Erdos Project</a></li> -->
            <li>Music at <a href="http://last.fm/user/Paamayim">last.fm</a></li>
            <li>Books at <a href="https://www.goodreads.com/review/list/14945161-sandy-maguire?shelf=currently-reading">goodreads</a></li>
            <!-- <li>Papers at <a href="https://www.mendeley.com/groups/7295141/read/papers/">mendeley</a></li> -->
        </ul>
    
        <p>
        ¬© 2015-2022 Sandy Maguire
        </p>
    </nav>

    <!--
    <div id="smallnav">
      <div class="smallhome"><a href="/">REASONABLY POLYMORPHIC</a></div>
      <div class="smallarchives"><a href="/blog/archives/">ARCHIVES</a></div>
    </div>
    -->
</body>
</html>

