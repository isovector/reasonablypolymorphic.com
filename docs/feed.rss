<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
  <title>Reasonably Polymorphic</title>
  <link>https://reasonablypolymorphic.com</link>
  <atom:link href="https://reasonablypolymorphic.com/feed.rss" rel="self" type="application/rss+xml" />
  <description>Sandy Maguire's technical blog</description>
  <category>Programming</category>
  <copyright>2022 Sandy Maguire</copyright>
  <pubDate></pubDate>
  <language>en-us</language>
  <image>
      <url>https://reasonablypolymorphic.com/images/favicon.png</url>
    <title>Sandy Maguire</title>
    <link>https://reasonablypolymorphic.com</link>
  </image>
  <item>
      <title>Certainty by Construction Progress Report 3</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report3/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report3/index.html</guid>
      <pubDate>2023-05-25</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>Week three, and this update is coming in hot, a whole day early! This week I worked on the ring solving chapter, realizing that I can make a very much non-toy solver, and pack it into a chapter. We now build a multivariate semiring solver, discuss how and why it works, and then do some dependent-type shenanigans to put a delightful user interface in front of the whole thing.</p>
<p>In addition, it came with some excellent opportunities to discuss where semantics come from, and let me talk about homomorphisms earlier than I was otherwise hoping to.</p>
<p>My plan for the week was to tackle the remainder of the setoids chapter, but setoids are awful and it’s hard to motivate myself to do that, since I avoid using them in my day-to-day life whenever I can. Which is always. We’ll see what happens with this chapter, but maybe it’ll get melted down into something else. Nevertheless, understanding setoids <em>is</em> important for actually doing anything with the stdlib, so I dunno.</p>
<p>On the typesetting front, I spent an hour today fighting with Latex trying to ensure that it has glyphs for every unicode character in the book. I’ve got all but one of them sorted out now, and in the process, learned way more about Latex than any human should need to know.</p>
<p>The plan for next week is to cleanup the extremely WIP backmatter chapters. There’s a bunch of crap in there about me trying to do math math and failing, because math math doesn’t give two sniffs about constructability, and so none of it works out. If I’m feeling particularly plucky, I might try my hand at defining the reals, just because it might be fun.</p>
<p>As of today’s update, the book is now 360 pages long! I estimate it’ll be about 450 when it’s done, so we’re clearly making progress.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 2</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report2/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report2/index.html</guid>
      <pubDate>2023-05-18</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>It’s week two of regular updates on Certainty by Construction, baby! This week I made 17 commits to the repository, half of which were towards the goal of improving the book’s typesetting. Spurred on by a bug report asking “what the hell does <code>AgdaCmd:MakeCase</code> mean?” I decided to upgrade the book’s build system. Now you should see explicit keystrokes to press when the book asks you to run a command alongside.</p>
<p>You’ll also notice intra-prose syntax highlighting, meaning that if the book mentions a type, it will now be presented in a beautiful blue, among other things in other colors. Agda has some janky support for this, but I couldn’t get it working, which means I annotated each and every piece of syntax highlighting by hand. Please file a bug if you notice I’ve missed any.</p>
<p>Content-wise, the old chapter on “structured sets” has become “relations”, and it has several new sections fleshing out the idea and giving several more examples. I’m now in the middle of rewriting the setoids chapter, but it too has three new sections, and thus the whole thing is no longer <em>all</em> about modular arithmetic.</p>
<p>Next week I’m going to continue powering on with the setoids chapter—including a big digression on what congruence entails under a setoid—and then I think I’ll tackle the ring solving chapter.</p>
<p>For the first time, this book seems like I might not be working on it for the rest of my life. It’s nowhere near done, but the topic and style are finally hashed out, and the content is mostly in an alpha state. From here it’s really just to continue grinding, rewriting all the crap bits over and over again, until they’re no longer crap.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 1</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report1/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report1/index.html</guid>
      <pubDate>2023-05-12</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>As part of a new ~quarterly goal, I’m going to be publishing updates to Certainty by Construction every Friday. This is for a few reasons: one, things get done much more quickly when you’re not doing them in private; two, relatedly, it’s good to get some exposure here and keep myself accountable.</p>
<p>Anyway, there are 26 new pages since last week, although a good deal of that is code without any prose around it yet. I’m in the process of cannibalizing the sections on relations and setoids into a single chapter. It’s a discussion of mathematical relations, their properties, an several examples. We explore different pre-orders, partial orders and total orders, and have a length digression about effectively designing indices for <code>data</code> types.</p>
<p>This last point arose from me spending a few hours trying to work out under which circumstances exactly Agda gets confused about whether or not a computing index will give rise to a constructor. My findings are that it’s not really about computing indices, so much as it is about Agda running out of variables in which it can pack constraints. I suspect this knowledge can be exploited to make more interesting constructors than I thought possible, but I haven’t worked out how to do it yet.</p>
<p>I’ve also been working on how to simplify some bigger setoid proofs, where you have a bunch of equational reasoning you’d like to do under congruence. The folklore on this is generally to introduce a lemma somewhere else, but this has always struck me as a disappointing solution. Modulo the concrete syntax, this seems to work pretty well:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span>≈nested<span class="ot">_</span>[<span class="ot">_</span>]<span class="ot">_</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">:</span> A</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">{</span>f <span class="ot">:</span> A <span class="ot">→</span> A<span class="ot">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">(</span>cong <span class="ot">:</span> <span class="ot">{</span>x y <span class="ot">:</span> A<span class="ot">}</span> <span class="ot">→</span> x ≈ y <span class="ot">→</span> f x ≈ f y<span class="ot">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> <span class="ot">{</span>x y z <span class="ot">:</span> A<span class="ot">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> x IsRelatedTo y</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> f y IsRelatedTo z</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="ot">→</span> f x IsRelatedTo z</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">_</span> ≈nested cong [ relTo x=y ] <span class="ot">(</span>relTo fy=z<span class="ot">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> relTo <span class="ot">(</span>trans <span class="ot">(</span>cong x=y<span class="ot">)</span> fy=z<span class="ot">)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="ot">_</span>≈nested<span class="ot">_</span>[<span class="ot">_</span>]<span class="ot">_</span></span></code></pre></div>
<p>which lets you focus in on a particular sub-expression, and use a new equational reasoning block to rewrite that, before popping your results back to the full expression. As an example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  ⌊ <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c +H d *S a ⌋ * x + b * d</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>≈nested <span class="ot">(</span>+-congʳ ∘ *-congʳ<span class="ot">)</span> [  <span class="co">-- focus on subexpr</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ⌊ <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c +H d *S a ⌋</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>≈⟨ +H-+-hom <span class="ot">(((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c<span class="ot">)</span> <span class="ot">(</span>d *S a<span class="ot">)</span> x ⟩</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  ⌊<span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> +H b *S c ⌋ + ⟦ d *S a ⌋</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>≈⟨ +-congʳ <span class="ot">(</span>+H-+-hom <span class="ot">((</span>a *H c<span class="ot">)</span> *x+ 0#<span class="ot">)</span> <span class="ot">(</span>b *S c<span class="ot">)</span> x<span class="ot">)</span> ⟩</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  ⌊ a *H c ⌋ * x + 0# + ⌊ b *S c ⌋ + ⌊ d *S a ⌋</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>≈⟨ …via… *S-*-hom ⟩</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  ⌊ a *H c ⌋ * x + <span class="ot">(</span>b * ⌊ c ⌋<span class="ot">)</span> + <span class="ot">(</span>d * ⌊ a ⌋<span class="ot">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>≈⟨ +-congʳ <span class="ot">(</span>+-congʳ <span class="ot">(</span>*-congʳ <span class="ot">(</span>*H-*-hom a c x<span class="ot">)))</span> ⟩</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  ⌊ a ⌋ * ⌊ c ⌋ * x + b * ⌊ c ⌋ + d * ⌊ a ⌋</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>∎ ]                            <span class="co">-- pop back</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">(</span>⌊ a ⌋ * ⌊ c ⌋ * x + b * ⌊ c ⌋ + d * ⌊ a ⌋<span class="ot">)</span> * x + <span class="ot">(</span>b * d<span class="ot">)</span></span></code></pre></div>
<p>The attentive reader here will notice that I have also clearly been improving the chapter on ring solving. Maybe I’m just better at proofs these days, but the whole thing feels much less challenging than my first few times looking at it.</p>
<hr />
<p>Anyway, that’s all for today. If you’ve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven’t, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>The Co-Blub Paradox</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/coblub/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/coblub/index.html</guid>
      <pubDate>2023-03-24</pubDate>
      <content:encoded><![CDATA[
        <p>The following is an excerpt from <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I’m writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you’re excited about, please do let me know!</p>
<hr />
<p>It is widely acknowledged that the languages you speak shape the thoughts you can think; while this is true for natural language, it is doubly so in the case of programming languages. And it’s not hard to see why; while humans have dedicated neural circuitry for natural language, it would be absurd to suggest there is dedicated neural circuitry for fiddling around with the semantics of pushing around arcane symbol abstractly encoded as electrical potentials over a conductive metal.</p>
<p>Because programming—and mathematics more generally—does not come easily to us humans, it can be hard to see the forest for the trees. We have no built-in intuition as to what should be possible, and thus, this intuition is built by observing the artifacts created by more established practitioners. In these more “artificial” of human endeavors, newcomers to the field are truly constructivists—their methods for practicing the art are shaped only by their previously-observed patterns. Because different programming languages support different features and idioms, the imaginable shape of what programming <em>is</em> must be shaped by the languages we understand.</p>
<p>In a famous essay, “<a href="http://www.paulgraham.com/avg.html">Beating the Averages</a>,” Paul Graham points out the so-called <em>Blub paradox.</em> This, Graham says, is the ordering of programming languages by powerfulness; a programmer who thinks in a middle-of-the-road language along this ordering (call it Blub) can identify less powerful languages, but not those which are more powerful. The idea rings true; one can arrange languages in power by the features they support, and subsequently check to see if a language supports all the features felt to be important. If it doesn’t, it must be less powerful. However, this technique doesn’t work to identify more powerful languages—at best, you will see that the compared language supports all the features you’re looking for, but you don’t know enough to ask for more.</p>
<p>More formally, we can describe the Blub paradox as a semi-decision procedure. That is, given an ordering over programming languages (here, by “power”,) we can determine whether a language is less than our comparison language, but not whether it is more than. We can determine when the answer is definitely “yes,” but, not when it is “no!”</p>
<p>Over two decades of climbing this lattice of powerful languages, I have come to understand a lesser-known corollary of the Blub paradox, coining it the <em>Co-Blub paradox</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This is the observation that knowledge of lesser languages is <em>actively harmful</em> in the context of a more powerful language. The hoops you unwittingly jumped through in Blub due to lacking feature X are <em>anti-patterns</em> in the presence of feature X. This is obviously true when stated abstractly, but insidious when one is in the middle of it.</p>
<p>Let’s look at a few examples over the ages, to help motivate the problem before we get into our introspection proper. In the beginning, people programmed directly in machine code. Not assembly, mind you, but in raw binary-encoded op-codes. They had a book somewhere showing them what bits needed to be set in order to cajole the machine into performing any given instruction. Presumably if this were your job, you’d come to memorize the bit patterns for common operations, and it wouldn’t be nearly as tedious as it seems today.</p>
<p>Then came assembly languages, which provided human-meaningful mnemonics to the computer’s opcodes. No longer did we need to encode a jump as <code>11111000110000001100</code> — now it was <code>jl 16</code>. Still mysterious, to be sure, but significant gains are realized in legibility. When encoded directly in machine code, programs were, for the most part, write-only. But assembly languages don’t come for free; first you need to write an assembler: a program that reads the mnemonics and outputs the raw machine code. If you were already proficient writing machine code directly, you can imagine the task of implementing an assembler to feel like make work—a tool to automate a problem you don’t have. In the context of the Co-Blub paradox, knowing the direct encodings of your opcodes is an anti-pattern when you have an assembly language, as it makes your contributes inscrutable among your peers.</p>
<p>Programming directly in assembly eventually hit its limits. Every computer had a different assembly language, which meant if you wanted to run the same program on a different computer you’d have to completely rewrite the whole thing; often needing to translate between extremely different concepts and limitations. Ignoring a lot of history, C came around with the big innovation that software should be portable between different computers: the same C program should work regardless of the underlying machine architecture. If you were an assembly programmer, you ran into the anti-pattern that while you could squeeze more performance and perform clever optimizations if you were aware of the underlying architecture, this fundamentally limited you <em>to that platform.</em></p>
<p>By virtue of being, in many ways, a unifying assembly language, C runs very close to what we think of as “the metal.” Although different computer architectures have minor differences in registers and ways of doing things, they are all extremely similar variations on a theme. They all expose storable memory indexed by a number, operations for performing basic logic and arithmetic tasks, and means of jumping around to what the computer should consider to be the next instruction. As a result, C exposes this abstraction of what a computer <em>is</em> to its programmers, who are thus required to think about mutable memory and about how to encode complicated objects as sequences of bytes in that memory. But then came Java, whose contribution to mainstream programming was to popularize the idea that memory is cheap and abundant, and thus OK to waste some in order to alleviate the headache of needing to track it all yourself. As a C programmer coming to Java, you must unlearn the idea that memory is sacred and scarce, that you can do a better job of keeping track of it than the compiler can, and, hardest of all, that it is an important thing to track in the first place.</p>
<p>There is a clear line of progression here; as we move up the lattice of powerful languages, we notice that more and more details of what we thought were integral parts of programming turn out to be not particularly relevant to the actual task at hand. However, the examples thus discussed are already known to the modern programmer. Let’s take a few steps further, into languages deemed esoteric in the present day. It’s easy to see and internalize examples from the past, but those staring us in the face are much more difficult to spot.</p>
<p>Compare Java then to Lisp, which—among many things—makes the argument that functions, and even <em>programs themselves,</em> are just as meaningful objects as are numbers and records. Where Java requires the executable pieces to be packaged up and moved around with explicit dependencies on the data it requires, Lisp just lets you write and pass around functions, which automatically carry around all the data they reference. Java has a <em>design pattern</em> for this called the “command pattern,” which requires much ado and ink to be spilled, while in Lisp it just works in a way that is hard to understand if you are used to thinking about computer programs as static sequences of instructions. Indeed, the command pattern is bloated and ultimately unnecessary in Lisp, and practitioners must first unlearn it before they can begin to see the beauty of Lisp.</p>
<p>Haskell takes a step further than Lisp, in that it restricts when and where side-effects are allowed to occur in a program. This sounds like heresy (and feels like it for the first six months of programming in Haskell) until you come to appreciate that <em>almost none</em> of a program needs to perform side-effects. As it happens, side-effects are the only salient observation of the computer’s execution model, and by restricting their use, Haskell frees its programmers from needing to think about how the computer will execute their code—promising only that it will. As a result, Haskell code looks much more like mathematics than it looks like a traditional computer program. Furthermore, by abstracting away the execution model, the runtime is free to parallelize and reorder code, often even eliding unnecessary execution altogether. The programmer who refuses to acknowledge this reality and insists on coding with side-effects pays a great price, both on the amount of code they need to write, in its long-term reusability, and, most importantly, in the correctness of their computations.</p>
<p>All of this brings us to Agda, which is as far as I’ve gotten along the power lattice of programming languages. While Agda looks a great deal like Haskell, its powerful typesystem allows us to articulate many invariants that are impossible to write down in other languages. It’s tempting to think about Agda as Haskell-but-with-better-types, but this is missing the point. Agda’s type system is so precise we can <em>prove</em> that our solutions are correct, which alleviates the need to actually <em>run</em> the subsequent programs. In essence, programming in Agda abstracts away the notion of execution entirely. Following our argument about co-Blub programmers, they will come to Agda with the anti-pattern that thinking their hard-earned, battle-proven programming techniques for wrangling runtime performance will come in handy. But this is not the case; most of the techniques we have learned and consider “computer science” are in fact <em>implementation ideas:</em> that is, specific realizations from infinite classes of solutions, chosen not for their simplicity or clarity, but for their <em>efficiency.</em></p>
<p>Thus, the process of learning Agda, in many ways, is learning to separate the beautiful aspects of problem solving from the multitude of clever hacks we have accumulated over the years. Much like the fish who is unable to recognize the ubiquitous water around him, as classically-trained programmers, it is nigh-impossible to differentiate the salient points from the implementation details until we find ourselves in a domain where they do not overlap. Indeed, in Agda, you will often feel the pain of having accidentally conflated the two, when your proofs end up being much more difficult than you feel they deserve. Despite the pain and the frustration, this is in fact a feature, and not a bug. It is a necessary struggle, akin to the type-checker informing you that your program is wrong. While it can be tempting to blame the tool, the real fault is in the workmanship.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Although precisely speaking, the name should be the co-(Blub paradox), as the corollary applies to the paradox as a whole, not only the Blub piece. Alas, such is an awkward construction in English, and thus we will not use it.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
  <item>
      <title>Abusing Constraints for Automatic Documentation</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/abusing-constraints/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/abusing-constraints/index.html</guid>
      <pubDate>2023-01-03</pubDate>
      <content:encoded><![CDATA[
        <h2 id="constraints"><a href="#constraints" class="header-link">Constraints<span class="header-link-emoji">🔗</span></a></h2>
<p><a href="https://github.com/wireapp/wire-server/pull/2950">At work I was recently tasked with figuring out what API calls our program makes</a>, and more interestingly, which code-paths lead to those API calls. Determining this by hand is tedious and error-prone, and worse, doesn’t stay up to date with code changes. Instead, let’s see how we can use the type system to eliminate the pain.</p>
<p>The existing code was organized around a class <code>HasAPI</code> that looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">HasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">HasAPI</span> srv name <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> srv name</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  callAPI ::</span> <span class="dt">APICall</span> srv name</span></code></pre></div>
<p>Here, <code>HasAPI</code> is a type class with an associated type family <code>APICall</code> which gives the type for making the call. For example, there might be an instance:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  callAPI str <span class="ot">=</span> <span class="fu">pure</span> <span class="op">$</span> <span class="fu">fmap</span> <span class="fu">toUpper</span> str</span></code></pre></div>
<p>This is a silly example — the real codebase makes actual API calls — but it serves for demonstration.</p>
<p>Our goal is to document every codepath that makes any use of <code>callAPI</code>, in some sense, “infecting” every path with some marker of that fact. This is a common experience to Haskell programmers; in fact, <code>IO</code> has this same pattern of infectiousness. Whenever you make a function perform IO, every type in the callstack needs to document the fact it performs <code>IO</code>. This is the inspiration we will take, except that changing types is extremely expensive. What if we pushed a constraint around instead?</p>
<h3 id="propagating-constraints"><a href="#propagating-constraints" class="header-link">Propagating Constraints<span class="header-link-emoji">🔗</span></a></h3>
<p>The trick is to define a new class, of the same shape as <code>HasAPI</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">CallsAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">CallsAPI</span> srv name</span></code></pre></div>
<p>but crucially, we give <code>CallsAPI</code> <em>no instances.</em> On first blush, this seems insane: why introduce a class with no methods and no instances? Having no methods means it can’t do anything useful. Having no instances means GHC can never eliminate the constraint, and thus must propagate it upwards. This is the infectiousness we want; any function which makes an API call must document that fact in its type — failure to do so will result in GHC failing to compile with the message <code>No instance for (CallsAPI srv name)</code>.</p>
<p>The trick now is to ensure that <code>callsAPI</code> produces a <code>CallsAPI</code> constraint. The easy way to do this is a little renaming to ensure existing polymorphic code continues work:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span>  <span class="dt">UnsafeHasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">UnsafeHasAPI</span> srv name <span class="kw">where</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  unsafeCallAPI ::</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HasAPI</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HasAPI</span> <span class="ot">=</span> (<span class="dt">UnsafeHasAPI</span> srv name, <span class="dt">CallsAPI</span> srv name)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>callAPI</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="kw">forall</span> srv name</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">.</span> <span class="dt">HasAPI</span> srv name</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">APICall</span> srv name</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>callAPI <span class="ot">=</span> unsafeCallAPI</span></code></pre></div>
<p>Any code written against the old <code>HasAPI</code> constraint will continue to work (modulo the instance definitions,) but concrete calls to <code>callAPI</code> now result in a dangling, unsatisfiable <code>CallsAPI</code> constraint. You’ll need to go through the codebase now, and document every transitive call to the API with matching <code>CallsAPI</code> constraints. Thankfully, HLS can help with this task: it will underline the missing cases, and suggest a code action that will automatically add these constraints to the type. Rinse and repeat, until every code path is documented.</p>
<p>Great success! We have automatically found every codepath that makes an API call, and forced them to document that fact. Better yet, we have solved the problem once and for all; our coworkers also must document any new API calls they make, lest their code not compile. It seems like we’re done!</p>
<p>Except for one fact: GHC will rudely refuse to compile our project, even if we correctly track all of our API calls. The problem of course, is that all we have managed to do is force <code>main</code> to collect every <code>CallsAPI</code> constraint. But GHC will still complain <code>No instance for (CallsAPI srv name)</code>. Of course, you could just give an orphan instance in the same module that defines <code>main</code>, which would work, but this doesn’t give you any sort of <em>external documentation.</em> It’s nice when you read the code, but it doesn’t help the business people.</p>
<h2 id="solving-the-unsolvable"><a href="#solving-the-unsolvable" class="header-link">Solving The Unsolvable<span class="header-link-emoji">🔗</span></a></h2>
<p>A better approach here is to selectively solve the <code>CallsAPI</code> constraints, which we can do with some Haskell dark magic. The <code>Dict</code> type captures a constraint, giving us a convenient way to manipulate constraints:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Dict</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dict</span> c <span class="kw">where</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Dict</span><span class="ot"> ::</span> c <span class="ot">=&gt;</span> <span class="dt">Dict</span> c</span></code></pre></div>
<p>We can write an eliminator to bring the <code>c</code> from a <code>Dict c</code> into scope, which, importantly, allows us to solve otherwise-unsolved constraints:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(\\)<span class="ot"> ::</span> (c <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Dict</span> c <span class="ot">-&gt;</span> r</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>f \\ <span class="dt">Dict</span> <span class="ot">=</span> f</span></code></pre></div>
<p>If we can get our hands on a <code>Dict (CallsAPI Srv Name)</code>, we can use <code>(\\)</code> to convince GHC to compile our program.</p>
<p>GHC is happy to give us dictionaries for constraints it knows about:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showIntDict ::</span> <span class="dt">Dict</span> (<span class="dt">Show</span> <span class="dt">Int</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>showIntDict <span class="ot">=</span> <span class="dt">Dict</span></span></code></pre></div>
<p>but unfortunately, refuses to give us dictionaries for unsolved constraints:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">callsAPIDict ::</span> <span class="kw">forall</span> srv name<span class="op">.</span> <span class="dt">Dict</span> (<span class="dt">CallsAPI</span> srv name)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>callsAPIDict <span class="ot">=</span> <span class="dt">Dict</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Error: No instance for (CallsAPI srv name)</span></span></code></pre></div>
<p>It seems like we’re just as stuck, but we have a trick up our sleeve. The first step is to define another class with an instance in scope. GHC will happily give us a dictionary for such a thing:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Trivial</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Trivial</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">trivialDict ::</span> <span class="dt">Dict</span> <span class="dt">Trivial</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>trivialDict <span class="ot">=</span> <span class="dt">Dict</span></span></code></pre></div>
<p>and now for something naughty:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">callsAPIDict ::</span> <span class="kw">forall</span> srv name<span class="op">.</span> <span class="dt">Dict</span> (<span class="dt">CallsAPI</span> srv name)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>callsAPIDict <span class="ot">=</span> unsafeCoerce trivialDict</span></code></pre></div>
<p>Behind the scenes, GHC compiles classes into records, instances into values of these records, and replaces wanted constraints with function arguments taking those records. By ensuring that <code>Trivial</code> and <code>CallsAPI</code> are both empty classes, with no methods or super-classes, we can be certain the generated records for these classes will be identical, and thus that it is OK to coerce one into the other.</p>
<p>Armed with <code>withDict</code> and <code>callsAPIDict</code>, we can play the part of the constraint solver and satisfy constraints ourself. GHC will happily compile the following example:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ex ::</span> <span class="dt">HasAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>ex <span class="ot">=</span> callAPI <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span> <span class="st">&quot;hello world&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Look ma, no HasAPI constraint!</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> ex \\ callsAPIDict <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span></span></code></pre></div>
<p>So that’s the rough technique. But how do we actually use it in anger?</p>
<h3 id="automatically-documenting-the-server"><a href="#automatically-documenting-the-server" class="header-link">Automatically Documenting the Server<span class="header-link-emoji">🔗</span></a></h3>
<p>Our actual use case at work is to add these API calls to our swagger documentation. Swagger is this automatically generated manifest of an API surface; we want to document the fact that some API calls might call other ones. Our server is one big servant application, and servant is extensible. So the real technique is to build a servant combinator that eliminates <code>HasAPI</code> constraints when you document them in the API definition.</p>
<p>Getting into the nitty gritty bits of servant is beyond the scope of this post, but we can sketch the idea. Servant APIs use the type-level <code>(:&gt;)</code> operator to combine information about an endpoint. For example, we might expose another service:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ServantAPI</span> <span class="ot">=</span> <span class="st">&quot;api&quot;</span> <span class="op">:&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;echo&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span></code></pre></div>
<p>This definition states that we have a REST server with a single route, <code>api/echo</code> which responds to <code>POST</code> requests, returning a JSON-encoded string, which takes a JSON-encoded string as the request body.</p>
<p>A servant server for <code>ServantAPI</code> would have type <code>Server ServantAPI</code>, where <code>Server</code> is a type family given by <code>HasServer</code>. Evaluating the type family results in <code>String -&gt; Handler String</code>, so in order to implement this server, we would need to provide a function of that type.</p>
<p>Let’s implement our server endpoint:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>echo</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">CallsAPI</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=&gt;</span> <span class="dt">String</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>echo str <span class="ot">=</span> liftIO <span class="op">$</span> callAPI <span class="op">@</span><span class="dt">ShoutService</span> <span class="op">@</span><span class="st">&quot;shout&quot;</span> str</span></code></pre></div>
<p>Unfortunately, due to our earlier work, we can’t eliminate the <code>CallsAPI</code> constraint, and thus we can’t actually use <code>echo</code> as the handler for our endpoint.</p>
<p>It’s important to note that servant’s DSL is extensible, and we can add our own machinery here. The first step is to build a type that we can use in servant:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MakesAPICall</span><span class="ot"> ::</span> <span class="dt">Service</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MakesAPICall</span> srv name</span></code></pre></div>
<p>We can now build a second version of <code>ServantAPI</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ServantAPI</span> <span class="ot">=</span> <span class="st">&quot;api&quot;</span> <span class="op">:&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;echo&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">MakesAPICall</span> <span class="dt">ShoutService</span> <span class="st">&quot;shout&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">:&gt;</span> <span class="dt">Get</span> &#39;[<span class="dt">JSON</span>] <span class="dt">String</span></span></code></pre></div>
<p>In order to actually run our endpoint, we need to give an instance of <code>HasServer</code> for our new <code>MakesAPICall</code> combinator:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasServer</span> api ctx</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) ctx</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>         <span class="kw">where</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) m <span class="ot">=</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Dict</span> (<span class="dt">CallsFed</span> srv name) <span class="ot">-&gt;</span> <span class="dt">ServerT</span> api m</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  route _ ctx f <span class="ot">=</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    route (<span class="dt">Proxy</span> <span class="op">@</span>api) ctx <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">$</span> callsAPIDict <span class="op">@</span>srv <span class="op">@</span>name) f</span></code></pre></div>
<p>The <code>ServerT</code> instance here adds a <code>Dict (CallsFed srv name)</code> to the type of the handler required to satisfy this endpoint, while <code>route</code> automatically fills in the dictionary whenever the handler needs to be run. In an ideal world, we could give our <code>ServerT</code> instance as:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">MakesAPICall</span> srv name <span class="op">:&gt;</span> api) m <span class="ot">=</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CallsFed</span> srv name <span class="ot">=&gt;</span> <span class="dt">ServerT</span> api m</span></code></pre></div>
<p>but GHC doesn’t let us use quantified types on the right-hand sides of type families, so this is unfortunately a no-go. Playing games with <code>Dict</code> instead is the best approach I’ve found here, but I’d love to hear if anyone has a better idea.</p>
<p>We still can’t use <code>echo</code> as a handler, but we can use <code>makesCall echo</code> as one, where <code>makesCall</code> is given as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">makesCall ::</span> (c <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Dict</span> c <span class="ot">-&gt;</span> r</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>makesCall <span class="ot">=</span> (\\)</span></code></pre></div>
<p>Servers that document their API calls via <code>MakesAPICall</code> and which wrap their handlers with <code>makesCall</code> can now eliminate <code>CallsFed</code> constraints. Since this is the only way of eliminating <code>CallsFed</code> constraints, we can be sure that every API call is correctly documented in the servant DSL!</p>
<p>The final step here is to add an instance of <code>HasSwagger (MakesAPICall srv name :&gt; api)</code>, but the details are gory and devoid of educational value. Suffice it to say that this instance was written, and now we have automatically generated JSON documentation describing which server endpoints make which other API calls. This documentation is guaranteed to be correct, because updating it is the only way to convince GHC to compile your code.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Why Is the Web So Monotonous? Google.</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/monotonous-web/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/monotonous-web/index.html</guid>
      <pubDate>2022-08-04</pubDate>
      <content:encoded><![CDATA[
        <p>Does it ever feel like the internet is getting worse? That’s been my impression for the last decade. The internet feels now like it consists of ten big sites, plus fifty auxiliary sites that come up whenever you search for something outside of the everyday ten. It feels like it’s harder to find amateur opinions on matters, except if you look on social media, where amateur opinions are shared, unsolicited, with much more enthusiasm than they deserve. The accessibility of the top ten seems like it collapses the internet into a monoculture of extremism, and, perhaps even more disappointingly, a monoculture that echos the offline world.</p>
<p>Contrast this to the internet of yore. By virtue of being hard to access, the internet filtered away the mass appeal it has today. It was hard and expensive to get on, and in the absence of authoring tools, you were only creating internet content if you <em>had something to say.</em> Which meant that, as a consumer, if you found something, you had good reason to believe it was well-informed. Why would someone go through the hassle of making a website about something they weren’t interested in?</p>
<p>In 2022, we have a resoundingly sad answer to that question: advertising. The primary purpose of the web today is “engagement,” which is Silicon Valley jargon for “how many ads can we push through someone’s optical nerve?” Under the purview of engagement, it makes sense to publish webpages on every topic imaginable, regardless of whether or not you know what you’re talking about. In fact, engagement goes up if you <em>don’t</em> know what you’re talking about; your poor reader might mistakenly believe that they’ll find the answer they’re looking for elsewhere on your site. That’s twice the advertising revenue, baby!</p>
<p>But the spirit of the early web isn’t gone: the bookmarks I’ve kept these long decades mostly still work, and many of them still receive new content. There’s still weird, amateur, passion-project stuff out there. It’s just hard to find. Which brings us to our main topic: search.</p>
<p>Google is inarguably the front page of the internet. Maybe you already know where your next destination is, in which case you probably search for the website on Google and click on the first link, rather than typing in the address yourself. Or maybe you don’t already know your destination, and you search for it. Either way, you hit Google first.</p>
<p>When I say the internet is getting worse, what I really mean is that the Google search results are significantly less helpful than they used to be. This requires some qualification. Google has gotten exceedingly good at organizing everyday life. It reliably gets me news, recipes, bus schedules, tickets for local events, sports scores, simple facts, popular culture, official regulations, and access to businesses. It’s essentially the yellow pages and the newspaper put together. For queries like this, which are probably 95% of Googles traffic, Google does an excellent job.</p>
<p>The difficulties come in for that other 5%, the so-called “long tail.” The long tail is all those other things we want to know about. Things without well-established, factual answers. Opinions. Abstract ideas. Technical information. If you’re cynical, perhaps it’s all the stuff that doesn’t have wide-enough appeal to drive engagement. Whatever the reason, the long tail is the stuff that’s hard to find on the modern internet.</p>
<p>Notice that the long-tail is exactly the stuff we need search for. Mass-appeal queries are, almost by definition, not particularly hard to find. If I need a bus schedule, I know to talk to my local transit authority. If I’m looking to keep up with the Kardashians, I’m not going to have any problems (at least, no <em>search</em> problems.) On the other hand, it’s much less clear where to get information on why my phone starts overheating when I open the chess app.</p>
<p>So what happens if you search for the long tail on Google? If you’re like me, you flail around for ten minutes wasting your time reading crap articles before you remember that Google is awful for the long tail, and you come away significantly more frustrated, not having found what you were looking for in the first place.</p>
<p>Lets look at some examples. One of my favorite places in the world is Koh Lanta, Thailand. When traveling, <a href>I’m always on the lookout</a> for places that give off the Koh Lanta vibe. What does that mean? Hard to say, exactly, but having tourist amenities without being touristy. Charming, slow, cheap. I don’t know exactly; if I did, it’d be easier to find. Anyway, forgetting that Google is bad at long tails, I search for <code>what is the koh lanta of croatia?</code> and get:</p>
<ul>
<li>Koh-Lanta - Wikipedia [note: not the island, the game show]</li>
<li>Top 15 Unique Things to Do in Koh Lanta</li>
<li>Visit Koh Lanta on a trip to Thailand</li>
<li>Beautiful places to travel, Koh lanta, Sunset</li>
<li>Holiday Vacation to Koh Lanta: Our favourite beaches and …</li>
<li>Koh Lanta Activities: 20 Best Things to Do</li>
<li>etc</li>
</ul>
<p>With the exception of “find a flight from Dubrovnik to Koh Lanta” on page two, you need to get to page five before you see any results that even acknowledge I <em>also</em> searched for <code>croatia</code>. Not very impressive.</p>
<p>When you start paying attention, you’ll notice it on almost every search — Google isn’t actually giving you answers to things you searched for. Now, maybe the reason here is that there <em>aren’t</em> any good results for the query, but that’s a valuable thing to know as well. Don’t just hit me with garbage, it’s an insult to my intelligence and time.</p>
<h2 id="where-things-go-wrong"><a href="#where-things-go-wrong" class="header-link">Where Things Go Wrong<span class="header-link-emoji">🔗</span></a></h2>
<p>I wanted to figure out why exactly the internet is getting worse. What’s going on with Google’s algorithm that leads to such a monotonous, boring, corporate internet landscape? I thought I’d dig into search engine optimization (SEO) — essentially, techniques that improve a website’s ranking in Google searches. I’d always thought SEO was better at selling itself than it was at improving search results, but my god was I wrong.</p>
<p>SEO techniques are extremely potent, and their widespread adoption is what’s wrong with the modern web.</p>
<p>For example, have you ever noticed that the main content of most websites is something like 70% down the page? Every recipe site I’ve ever seen is like this — nobody cares about how this recipe was originally your great-grandmother’s. Just tell us what’s in it. Why is this so prevalent on the web?</p>
<p>Google rewards a website for how long a user stays on it, with the reasoning being that a bad website has the user immediately hit the back button. Seems reasonable, until you notice the problem of incentives here. Websites aren’t being rewarded for having good content under this scheme, they’re rewarded for wasting your time and making information hard to find. Outcome: websites that answer questions, but hide the information somewhere on a giant (ad-filled) page.</p>
<p>Relatedly, have you noticed how every website begins with a stupid paragraph overviewing the thing you’re searching for? It’s always followed by a stupid paragraph describing why you should care about the thing. For example, I just searched for <code>garden irrigation</code>, and the first result is:</p>
<blockquote>
<p>Water is vital to plant health, but watering by hand can be a hassle. You have to drag hoses between gardens, move sprinklers around, or take the time to water each plant. Our innovative watering systems take the hassle out of watering. They’re the easiest way to give plants the consistent moisture they need for your biggest harvest and most beautiful blooms.</p>
</blockquote>
<p><em>Water is vital to plant health.</em> Wow, who knew! Why in god’s name would I be searching for garden irrigation if I didn’t know that water was vital to plant health. Why is copy like this so prevalent on the web?</p>
<p>Things become clearer when you look at some of the context of this page:</p>
<blockquote>
<p>Url: https://[redacted]/how-to/how-to-choose-a-watering-system/8747.html</p>
<p>Title: How to Choose a Garden Irrigation System</p>
<p>Heading: Soak, Drip or Spray: Which is right for you?</p>
<p>Subheading: Choose the best of our easy, customizable, irrigation systems to help your plants thrive and save water</p>
</blockquote>
<p>As it happens, Google rewards websites which use keywords in their url, title, headings, and first 100 words. Just by eyeballing, we can see that this particular website is targeting the keywords “water”, “system”, “irrigation”, and “garden”. Pages like these hyper-optimized to come up for particular searches. The stupid expository stuff exists only to pack “important keywords” into the first 100 words.</p>
<p>But keyword targeting doesn’t stop there. As I was reading through this SEO stuff (that is, the first page of a Google search for <code>seo tricks</code>,) every single page offered 15-25 great, technical SEO tricks. And then, without fail, the final point on each page was “but really, the best SEO strategy is having great content!” That’s weird. “Great content” isn’t something an algorithm can identify; if it were, you wouldn’t be currently reading the ravings of a madman, angry about the state of the internet.</p>
<p>So, why do all of these highly-optimized SEO pages ubiquitously break form, switching from concrete techniques to platitudes? You guessed it, it’s a SEO technique! Google offers a keyword dashboard, where you can see which keywords group together, and (shudder) which keywords are <em>trending.</em> Google rewards you for having other keywords in the group on your page. And it extra rewards you for having trending keywords. You will not be surprised to learn that “quality content” is a keyword that clusters with “seo,” nor that it is currently a trending keyword.</p>
<p>Think about that for a moment. Under this policy, Google is incentivizing pages to become <em>less focused,</em> by adding text that is only tangentially related. But, how do related keywords come about? The only possible answer here is to find keywords that often cluster on other pages. But this is a classic death spiral, pulling every page in a topic to have the same content.</p>
<p>Another way of looking at it is that if you are being incentivized, you are being <em>disincentivized.</em> Webpages are being penalized for including original information, because original information can’t possibly be in the keyword cluster.</p>
<p>There are a multitude of perverse incentives from Google, but I’ll mention only two more. The first is that websites are penalized for having low-ranking pages. The conventional advice here is to delete “underperforming” pages, which only makes the search problem worse — sites are being rewarded for deleting pages that don’t align with the current search algorithm.</p>
<p>My last point: websites are penalized for even <em>linking</em> to low-ranking pages!</p>
<p>It’s not hard to put all of the pieces together and see why the modern web is so bland and monotonous. Not only is the front-page of the internet aggressively penalizing websites which <em>aren’t</em> bland and monotonous, it’s also punishing any site which has the audacity to link to more interesting parts of the web.</p>
<h2 id="how-culpable-is-google"><a href="#how-culpable-is-google" class="header-link">How Culpable is Google?<span class="header-link-emoji">🔗</span></a></h2>
<p>So the discoverable part of web sucks. But is that really Google’s fault? I’d argue no. By virtue of being the front-page, Google’s search results are under extreme scrutiny. In the eyes of the non-technical population, especially the older generations, the internet and Google are synonymous. The fact is that Google gets unfairly targeted by legislation because it’s a big, powerful tech company, and we as a society are uncomfortable with that.</p>
<p>Worse, the guys doing the regulation don’t exactly <a href="https://youtu.be/wmuROTmazco?t=71">have a grasp</a> on how internet things work.</p>
<p>Society at large has been getting very worried about disinformation. Who’s problem is that? Google’s — duh. Google is how we get information on the internet, so it’s up to them to defend us from disinformation.</p>
<p>Unfortunately it’s really hard to spot disinformation. Sometimes even the <em>government</em> lies to us (gasp!). I can think of two ways of avoiding getting in trouble with respect to disinformation. One: link only to <em>official sites,</em> thus changing the problem of trustworthiness to one of authority. If there is no authority, just give back the consensus. Two: don’t return any information whatsoever.</p>
<p>Google’s current strategy seems to be somewhere between one and two. For example, we can try a controversialish search like <code>long covid doesn&#39;t exist</code>. The top results at time of writing are:</p>
<ol type="1">
<li>The search for Long Covid (science.org)</li>
<li>Small Study Finds No Obvious Physical Causes for Long COVID (medscape.com)</li>
<li>Fact Check-‘Long COVID’ is not fake, quoted French study did … (reuters.com)</li>
<li>Harvard Medical School expert explains ‘long COVID’ (harvard.edu)</li>
<li>Claim that French study showed long COVID doesn’t exist … (healthfeedback.org)</li>
<li>What doctors wish patients knew about long COVID (ama-assn.org)</li>
</ol>
<p>I’m not particularly in the know, but I recognize most of these organizations. Science.org sounds official. Not only is one of the pages from Harvard, but also it’s from a Harvard Medical School <em>expert.</em> I especially like the fifth one, the metadata says:</p>
<blockquote>
<p>Claim: Long COVID is “mostly a mental disease”; the condition long COVID is solely due to a person’s belief, not actual disease; long COVID doesn’t exist</p>
<p>Fact check by Health Feedback: Inaccurate</p>
</blockquote>
<p>Every one of these websites comes off as <em>authoritative</em> — not in sense of “knowing what they’re talking about” because that’s hard to verify — but in the sense of being the sort of organization we’d trust to answer this question for us. Or, in the case of number five, at least telling us that they fact checked it.</p>
<p>Let’s try a search for something requiring less authority, like “best books.” In the past I would get a list of books considered the best. But now I get:</p>
<ol type="1">
<li>The Greatest Books: The Best Books of All Time - 1 to 50</li>
<li>The Best Books of All Time | chapters.indigo.ca</li>
<li>100 Best Books of All Time - Reader’s Digest</li>
<li>Best Book Lists - Goodreads</li>
<li>Best Books 2022: Books We Love : NPR</li>
</ol>
<p>You’ll notice there are no actual books here. There are only <em>lists</em> of best books. Cynical me notes that if you were to actually list a book, someone could find it controversial. Instead, you can link to institutional websites, and let them take the controversy for their picks.</p>
<p>This isn’t the way the web needs to be. Google could just as well given me personal blogs of people talking about long covid and their favorite books, except (says cynical me) that these aren’t authoritative sources, and thus, linking to them could be considered endorsement. And the web is too big and too fast moving to risk linking to anything that hasn’t been vetted in advance. It’s just too easy to accidentally give a <em>good</em> result to a controversial topic, and have the law makers pounce on you. Instead, punt the problem back to authorities.</p>
<p>The web promised us a democratic, decentralized public forum, and all we got was the stinking yellow pages in digital format. I hope the crypto people can learn a lesson here.</p>
<p>Anyway, all of this is to say that I think lawmakers and liability concerns are the real reason the web sucks. All things being equal, Google would like to give us good results, but it prefers making boatloads of money, and that would be hard to do if it got regulated into nothingness.</p>
<h2 id="a-note-on-other-search-engines"><a href="#a-note-on-other-search-engines" class="header-link">A Note on Other Search Engines<span class="header-link-emoji">🔗</span></a></h2>
<p>Google isn’t the only search engine around. There are others, but it’s fascinating that none of them compete on the basis of providing better results. DDG claims to have better privacy. Ecosia claims to plant trees. Bing exists to keep Microsoft relevant post-2010, and for some reason, ranks websites for being highly-shared on social media (again, things that are, by definition, not hard to find.)</p>
<p>Why don’t other search engines compete on search results? It can’t be hard to do better than Google for the long tail.</p>
<h2 id="what-can-we-do"><a href="#what-can-we-do" class="header-link">What Can We Do?<span class="header-link-emoji">🔗</span></a></h2>
<p>It’s interesting to note that the problems of regulatory-fear and SEO-capture are functions of Google’s cultural significance. If Google were smaller or less important, there’d be significantly less negative-optimization pressure on it. Google is a victim of its own success.</p>
<p>That is to say, I don’t think all search engines are doomed to fail in the same way that Google has. A small search engine doesn’t need to be authoritative, because nobody is paying attention to it. And it doesn’t have to worry about SEO for the same reason — there’s no money to be made in manipulating its results.</p>
<p>What I dream of is Google circa 2006. A time where a search engine searched what you asked for. A time before aggressive SEO. A time before social media, when the only people on the internet had a reason to be there. A time before sticky headers and full-screen modal pop-ups asking you to subscribe to a newsletter before reading the article. A time before click-bait and subscription-only websites which tease you with a paragraph before blurring out the rest of the content.</p>
<p>These problems are all solvable with by a search engine. But that search engine isn’t going to be Google. Let’s de-rank awful sites, and boost personal blogs of people with interesting things to say. Let’s de-rank any website that contains ads. Let’s not index any click-bait websites, which unfortunately in 2022 includes most of the news.</p>
<p>What we need is a search engine, by the people, and for the people. Fuck the corporate interests and the regulatory bullshit. None of this is hard to do. It just requires someone to get started.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Proof-Carrying Code</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/proof-carrying-code/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/proof-carrying-code/index.html</guid>
      <pubDate>2022-03-22</pubDate>
      <content:encoded><![CDATA[
        <!--
<pre class="Agda"><a id="146" class="Keyword">module</a> <a id="153" href="blog.proof-carrying-code.html" class="Module">blog.proof-carrying-code</a> <a id="178" class="Keyword">where</a>

<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="206" class="Keyword">open</a> <a id="211" class="Keyword">import</a> <a id="218" href="Data.Vec.html" class="Module">Data.Vec</a>
<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="Data.Fin.html" class="Module">Data.Fin</a>
</pre>-->
<p>A few months ago, the excellent <a href="https://davidrusu.github.io/">David Rusu</a> gave me an impromptu lecture on <a href="https://en.wikipedia.org/wiki/Ring_signature">ring signatures</a>, which are a way of signing something as an anonymous member of a group. That is, you can show someone in the signing pool was actually responsible for signing the thing, but can’t determine <em>which member of the pool actually signed it.</em> David walked me through all the math as to how that actually happens, but I was unable to follow it, because the math was hard and, perhaps more importantly, it felt like hand-compiling a proof.</p>
<p>What do I mean by “hand-compiling” a proof? Well, we have some mathematical object, something like</p>
<pre class="Agda"><a id="1003" class="Keyword">postulate</a>
  <a id="Identity"></a><a id="1015" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1024" class="Symbol">:</a> <a id="1026" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="Message"></a><a id="1032" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="1040" class="Symbol">:</a> <a id="1042" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="SignedBy"></a><a id="1048" href="blog/proof-carrying-code/index.html#1048" class="Postulate">SignedBy</a> <a id="1057" class="Symbol">:</a> <a id="1059" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="1067" class="Symbol">→</a> <a id="1069" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1078" class="Symbol">→</a> <a id="1080" href="Agda.Primitive.html#320" class="Primitive">Set</a>

  <a id="use-your-imagination"></a><a id="1087" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a> <a id="1108" class="Symbol">:</a> <a id="1110" class="Symbol">{</a><a id="1111" href="blog/proof-carrying-code/index.html#1111" class="Bound">A</a> <a id="1113" class="Symbol">:</a> <a id="1115" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="1118" class="Symbol">}</a> <a id="1120" class="Symbol">→</a> <a id="1122" href="blog/proof-carrying-code/index.html#1111" class="Bound">A</a>

<a id="1125" class="Keyword">record</a> <a id="SignedMessage"></a><a id="1132" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="1146" class="Symbol">{</a><a id="1147" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a> <a id="1149" class="Symbol">:</a> <a id="1151" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="1152" class="Symbol">}</a> <a id="1154" class="Symbol">(</a><a id="1155" href="blog/proof-carrying-code/index.html#1155" class="Bound">pool</a> <a id="1160" class="Symbol">:</a> <a id="1162" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="1166" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a> <a id="1175" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a><a id="1176" class="Symbol">)</a> <a id="1178" class="Symbol">:</a> <a id="1180" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1184" class="Keyword">where</a>
  <a id="1192" class="Keyword">field</a>
    <a id="SignedMessage.message"></a><a id="1202" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a> <a id="1210" class="Symbol">:</a> <a id="1212" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a>
    <a id="1224" class="Symbol">@</a><a id="1225" class="Symbol">erased</a>
      <a id="SignedMessage.signer"></a><a id="1238" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a> <a id="1245" class="Symbol">:</a> <a id="1247" href="Data.Fin.Base.html#1135" class="Datatype">Fin</a> <a id="1251" href="blog/proof-carrying-code/index.html#1147" class="Bound">n</a>
    <a id="SignedMessage.signature"></a><a id="1257" href="blog/proof-carrying-code/index.html#1257" class="Field">signature</a> <a id="1267" class="Symbol">:</a> <a id="1269" href="blog/proof-carrying-code/index.html#1048" class="Postulate">SignedBy</a> <a id="1278" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a> <a id="1286" class="Symbol">(</a><a id="1287" href="Data.Vec.Base.html#1614" class="Function">lookup</a> <a id="1294" href="blog/proof-carrying-code/index.html#1155" class="Bound">pool</a> <a id="1299" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a><a id="1305" class="Symbol">)</a>
</pre>
<p>where <code>@erased</code> is Agda’s <a href="https://agda.readthedocs.io/en/v2.6.2.1/language/runtime-irrelevance.html#runtime-irrelevance">runtime irrelevance</a> annotation, meaning the <span class="Agda"><a href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a></span> field won’t exist at runtime. In fact, attempting to write a function that would extract it results in the following error:</p>
<blockquote>
<p>Identifier <code>signer</code> is declared erased, so it cannot be used here<br />
when checking that the expression <code>signer x</code> has type <code>Fin n</code></p>
</blockquote>
<p>Nice one Agda!</p>
<p>Hand-compiling this thing is thus constructing some object that has the desired properties, but doing it in a way that requires BEING VERY SMART, and throwing away any chance at composability in the process. For example, it’d be nice to have the following:</p>
<pre class="Agda"><a id="2045" class="Keyword">open</a> <a id="2050" href="blog/proof-carrying-code/index.html#1132" class="Module">SignedMessage</a>

<a id="weakenL"></a><a id="2065" href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a> <a id="2073" class="Symbol">:</a> <a id="2075" class="Symbol">∀</a> <a id="2077" class="Symbol">{</a><a id="2078" href="blog/proof-carrying-code/index.html#2078" class="Bound">n</a> <a id="2080" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a> <a id="2085" href="blog/proof-carrying-code/index.html#2085" class="Bound">new-id</a><a id="2091" class="Symbol">}</a>
        <a id="2101" class="Symbol">→</a> <a id="2103" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2117" class="Symbol">{</a><a id="2118" href="blog/proof-carrying-code/index.html#2078" class="Bound">n</a><a id="2119" class="Symbol">}</a> <a id="2121" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a>
        <a id="2134" class="Symbol">→</a> <a id="2136" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2150" class="Symbol">(</a><a id="2151" href="blog/proof-carrying-code/index.html#2085" class="Bound">new-id</a> <a id="2158" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="2160" href="blog/proof-carrying-code/index.html#2080" class="Bound">pool</a><a id="2164" class="Symbol">)</a>
<a id="2166" href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a> <a id="2174" href="blog/proof-carrying-code/index.html#2174" class="Bound">x</a> <a id="2176" class="Symbol">=</a> <a id="2178" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>

<a id="weakenR"></a><a id="2200" href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a> <a id="2208" class="Symbol">:</a> <a id="2210" class="Symbol">∀</a> <a id="2212" class="Symbol">{</a><a id="2213" href="blog/proof-carrying-code/index.html#2213" class="Bound">n</a> <a id="2215" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a> <a id="2220" href="blog/proof-carrying-code/index.html#2220" class="Bound">new-id</a><a id="2226" class="Symbol">}</a>
        <a id="2236" class="Symbol">→</a> <a id="2238" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2252" class="Symbol">{</a><a id="2253" href="blog/proof-carrying-code/index.html#2213" class="Bound">n</a><a id="2254" class="Symbol">}</a> <a id="2256" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a>
        <a id="2269" class="Symbol">→</a> <a id="2271" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2285" class="Symbol">(</a><a id="2286" href="blog/proof-carrying-code/index.html#2215" class="Bound">pool</a> <a id="2291" href="Data.Vec.Base.html#2718" class="Function Operator">++</a> <a id="2294" href="Data.Vec.Base.html#5759" class="Function Operator">[</a> <a id="2296" href="blog/proof-carrying-code/index.html#2220" class="Bound">new-id</a> <a id="2303" href="Data.Vec.Base.html#5759" class="Function Operator">]</a><a id="2304" class="Symbol">)</a>
<a id="2306" href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a> <a id="2314" href="blog/proof-carrying-code/index.html#2314" class="Bound">x</a> <a id="2316" class="Symbol">=</a> <a id="2318" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>
</pre>
<p>which would allow us to arbitrarily extend the pool of a signed message. Then, we could trivially construct one:</p>
<pre class="Agda"><a id="sign"></a><a id="2462" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2467" class="Symbol">:</a> <a id="2469" href="blog/proof-carrying-code/index.html#1032" class="Postulate">Message</a> <a id="2477" class="Symbol">→</a> <a id="2479" class="Symbol">(</a><a id="2480" href="blog/proof-carrying-code/index.html#2480" class="Bound">who</a> <a id="2484" class="Symbol">:</a> <a id="2486" href="blog/proof-carrying-code/index.html#1015" class="Postulate">Identity</a><a id="2494" class="Symbol">)</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="blog/proof-carrying-code/index.html#1132" class="Record">SignedMessage</a> <a id="2512" href="Data.Vec.Base.html#5759" class="Function Operator">[</a> <a id="2514" href="blog/proof-carrying-code/index.html#2480" class="Bound">who</a> <a id="2518" href="Data.Vec.Base.html#5759" class="Function Operator">]</a>
<a id="2520" href="blog/proof-carrying-code/index.html#1202" class="Field">message</a>   <a id="2530" class="Symbol">(</a><a id="2531" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2536" href="blog/proof-carrying-code/index.html#2536" class="Bound">msg</a> <a id="2540" href="blog/proof-carrying-code/index.html#2540" class="Bound">who</a><a id="2543" class="Symbol">)</a> <a id="2545" class="Symbol">=</a> <a id="2547" href="blog/proof-carrying-code/index.html#2536" class="Bound">msg</a>
<a id="2551" href="blog/proof-carrying-code/index.html#1238" class="Field">signer</a>    <a id="2561" class="Symbol">(</a><a id="2562" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2567" href="blog/proof-carrying-code/index.html#2567" class="Bound">msg</a> <a id="2571" href="blog/proof-carrying-code/index.html#2571" class="Bound">who</a><a id="2574" class="Symbol">)</a> <a id="2576" class="Symbol">=</a> <a id="2578" href="Data.Fin.Base.html#1157" class="InductiveConstructor">zero</a>
<a id="2583" href="blog/proof-carrying-code/index.html#1257" class="Field">signature</a> <a id="2593" class="Symbol">(</a><a id="2594" href="blog/proof-carrying-code/index.html#2462" class="Function">sign</a> <a id="2599" href="blog/proof-carrying-code/index.html#2599" class="Bound">msg</a> <a id="2603" href="blog/proof-carrying-code/index.html#2603" class="Bound">who</a><a id="2606" class="Symbol">)</a> <a id="2608" class="Symbol">=</a> <a id="2610" href="blog/proof-carrying-code/index.html#1087" class="Postulate">use-your-imagination</a>
</pre>
<p>and then obfuscate who signed by some random choice of subsequent <span class="Agda"><a href="blog/proof-carrying-code/index.html#2065" class="Function">weakenL</a></span>s and <span class="Agda"><a href="blog/proof-carrying-code/index.html#2200" class="Function">weakenR</a></span>s.</p>
<p>Unfortunately, this is not the case with ring signatures. Ring signatures require you to “bake in” the signing pool when you construct your signature, and you can never again change that pool, short of doing all the work again. This behavior is non-composable, and thus, in my reckoning, unlikely to be a true solution to the problem.</p>
<p>The paper I chose to review this week is <a href="https://www.cs.jhu.edu/~fabian/courses/CS600.624/proof-carrying-code.pdf">Proof-Carrying Code</a> by George Necula, in an attempt to understand if the PL literature has anything to say about this problem.</p>
<p>PCC is an old paper (from 1997, egads!) but it was the first thing I found on the subject. I should really get better at vetting my literature before I go through the effort of going through it, but hey, what are you going to do?</p>
<p>The idea behind PCC is that we want to execute some untrusted machine code. But we don’t want to sacrifice our system security to do it. And we don’t want to evaluate some safe language into machine code, because that would be too slow. Instead, we’ll send the machine code, as well as a safety proof that verifies it’s safe to execute this code. The safety proof is tied to the machine code, such that you can’t just generate a safety proof for an unrelated problem, and then attach it to some malicious code. But the safety proof isn’t obfuscated or anything; the claim is that if you can construct a safety proof for a given program, that program is necessarily safe to run.</p>
<p>On the runtime side, there is a simple algorithm for checking the safety proof, and it is independent of the arguments that the program is run with; therefore, we can get away with checking code once and evaluating it many times. It’s important that the algorithm be simple, because it’s a necessarily trusted piece of code, and it would be bad news if it were to have bugs.</p>
<p>PCC’s approach is a bit… unimaginative. For every opcode we’d like to allow in the programs, we attach a safety precondition, and a postcondition. Then, we map the vector of opcodes we’d like to run into its pre/post conditions, and make sure they are confluent. If they are, we’re good to go. This vector of conditions is called the vector VC in the paper.</p>
<p>So, the compiler computes the VC and attaches it to the code. Think of the VC as a proposition of safety (that is, a type), and a proof of that proposition (the VC itself.) In order to validate this, the runtime does a safety typecheck, figuring out what the proposition of safety would have to be. It compares this against the attached proof, and if they match, it typechecks the VC to ensure it has the type it says. If it does, our code is safe.</p>
<p>The PCC paper is a bit light on details here, so it’s worth thinking about exactly what’s going on here. Presumably determining the safety preconditions is an easy problem if we can do it at runtime, but proving some code satisfies it is hard, <em>or else we could just do that at runtime too.</em></p>
<p>I’m a bit hesitant to dive into the details here, because I don’t really care about determining whether some blob of machine code is safe to run. It’s a big ball of poorly typed typing judgments about memory usage. Why do I say poorly typed? Well consider one of the rules from the paper:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>m</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi><mtext>list</mtext><mspace width="1em"></mspace><mspace width="1em"></mspace><mi>e</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><mrow><mi>m</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mtext>addr</mtext><mo>∧</mo><mo>…</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{m \vdash e : \tau \text{list} \quad \quad e \neq 0}
     {m \vdash e : \text{addr} \wedge \ldots}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord text"><span class="mord">addr</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner">…</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mord text"><span class="mord">list</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>Here we have that from <code>e : List τ</code> (and that <code>e</code> isn’t 0) we can derive <code>e : addr</code>. At best, if we are charitable in assuming <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">e \neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> means that <code>e</code> isn’t <code>nil</code>, there is a type preservation error here. If we are less charitable, there is also some awful type error here involving 0, which might be a null check or something? This seems sufficiently messy that I don’t care enough to decipher it.</p>
<p>How applicable is any of this to our original question around ring signatures? Not very, I think, unfortunately. We already have the ring signature math if we’d like to encode a proof, and the verification of it is easy enough. But it’s still not very composable, and I doubt this paper will add much there. Some more promising approaches would be to draw the mystery commutative diagrams ala <a href="/blog/adders-and-arrows">Adders and Arrows</a>, starting from a specification and deriving a chain of proofs that the eventual implementation satisfies the specification. The value there is in all the intermediary nodes of the commutative diagram, and whether we can prove weakening lemmas there.</p>
<p>But PCC isn’t entirely a loss; I learned about <code>@erased</code> in Agda.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Syntax-Guided Synthesis</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/syntax-guided-synthesis/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/syntax-guided-synthesis/index.html</guid>
      <pubDate>2022-03-19</pubDate>
      <content:encoded><![CDATA[
        <!--
<pre class="Agda"><a id="153" class="Keyword">module</a> <a id="160" href="blog.syntax-guided-synthesis.html" class="Module">blog.syntax-guided-synthesis</a> <a id="189" class="Keyword">where</a>

<a id="196" class="Keyword">open</a> <a id="201" class="Keyword">import</a> <a id="208" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="249" class="Keyword">open</a> <a id="254" class="Keyword">import</a> <a id="261" href="Data.Product.html" class="Module">Data.Product</a>
<a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="295" class="Keyword">open</a> <a id="300" class="Keyword">import</a> <a id="307" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
<a id="345" class="Keyword">open</a> <a id="350" class="Keyword">import</a> <a id="357" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="374" class="Keyword">using</a> <a id="380" class="Symbol">(</a><a id="381" href="Relation.Nullary.html#1520" class="Record">Dec</a><a id="384" class="Symbol">;</a> <a id="386" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a><a id="389" class="Symbol">;</a> <a id="391" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a><a id="393" class="Symbol">;</a> <a id="395" href="Relation.Nullary.html#1568" class="InductiveConstructor Operator">_because_</a><a id="404" class="Symbol">;</a> <a id="406" href="Relation.Nullary.html#665" class="Function Operator">¬_</a><a id="408" class="Symbol">;</a> <a id="410" href="Relation.Nullary.html#911" class="InductiveConstructor">ofʸ</a><a id="413" class="Symbol">;</a> <a id="415" href="Relation.Nullary.html#948" class="InductiveConstructor">ofⁿ</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="442" class="Keyword">hiding</a> <a id="449" class="Symbol">(</a><a id="450" href="Data.Bool.Properties.html#1135" class="Function Operator">_≟_</a><a id="453" class="Symbol">;</a> <a id="455" href="Data.Bool.Base.html#681" class="Datatype Operator">_≤_</a><a id="458" class="Symbol">;</a> <a id="460" href="Data.Bool.Properties.html#1973" class="Function Operator">_≤?_</a><a id="464" class="Symbol">)</a>
<a id="466" class="Keyword">open</a> <a id="471" class="Keyword">import</a> <a id="478" href="Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Data.List.html" class="Module">Data.List</a> <a id="526" class="Keyword">hiding</a> <a id="533" class="Symbol">(</a><a id="534" href="Data.List.Base.html#4597" class="Function">and</a><a id="537" class="Symbol">;</a> <a id="539" href="Data.List.Base.html#5034" class="Function Operator">[_]</a><a id="542" class="Symbol">)</a>
<a id="544" class="Keyword">open</a> <a id="549" class="Keyword">import</a> <a id="556" href="Function.html" class="Module">Function</a> <a id="565" class="Keyword">hiding</a> <a id="572" class="Symbol">(</a><a id="573" href="Function.Base.html#645" class="Function">const</a><a id="578" class="Symbol">)</a>
<a id="580" class="Keyword">open</a> <a id="585" class="Keyword">import</a> <a id="592" href="Data.Maybe.html" class="Module">Data.Maybe</a>
</pre>-->
<p>I was describing my idea from <a href="/blog/generic-parallel-fp">last week</a> to <a href="/blog/generic-parallel-fp/#future-work">automatically optimize programs</a> to Colin, who pointed me towards <a href="https://sygus.org/assets/pdf/Journal_SyGuS.pdf">Syntax-Guided Synthesis</a> by Alur et al.</p>
<p>Syntax-Guided Synthesis is the idea that free-range program synthesis is really hard, so instead, let’s constrain the search space with a grammar of allowable programs. We can then enumerate those possible programs, attempting to find one that satisfies some constraints. The idea is quite straightforward when you see it, but that’s not to say it’s unimpressive; the paper has lots of quantitative results about exactly how well this approach does.</p>
<p>The idea is we want to find programs with type <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a></span> <code>→</code> <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a></span>, that satisfy some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>ification. We’ll do that by picking some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage of syntax, and trying to build our programs there.</p>
<p>All of this is sorta moot, because we assume we have some <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> which can tell us if our program satisfies the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. But the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is probably some SMT solver, and is thus expensive to call, so we’d like to try hard not to call it if possible.</p>
<p>Let’s take an example, and say that we’d like to synthesize the <code>max</code> of two <code class="sourceCode agda">Nat</code>s. There are lots of ways of doing that! But we’d like to find a function that satisfies the following:</p>
<pre class="Agda"><a id="2068" class="Keyword">data</a> <a id="MaxSpec"></a><a id="2073" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2081" class="Symbol">(</a><a id="2082" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2084" class="Symbol">:</a> <a id="2086" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2088" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="2090" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2092" class="Symbol">→</a> <a id="2094" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2095" class="Symbol">)</a> <a id="2097" class="Symbol">:</a> <a id="2099" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2101" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="2103" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2105" class="Symbol">→</a> <a id="2107" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2111" class="Keyword">where</a>
  <a id="MaxSpec.is-max"></a><a id="2119" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">{</a><a id="2129" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2131" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2133" class="Symbol">:</a> <a id="2135" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2136" class="Symbol">}</a>
         <a id="2147" class="Symbol">→</a> <a id="2149" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2151" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤</a> <a id="2153" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2155" class="Symbol">(</a><a id="2156" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2158" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2160" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2161" class="Symbol">)</a>
         <a id="2172" class="Symbol">→</a> <a id="2174" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a> <a id="2176" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤</a> <a id="2178" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2180" class="Symbol">(</a><a id="2181" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2183" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2185" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2186" class="Symbol">)</a>
         <a id="2197" class="Symbol">→</a> <a id="2199" class="Symbol">((</a><a id="2201" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2203" class="Symbol">(</a><a id="2204" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2206" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2208" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2209" class="Symbol">)</a> <a id="2211" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2213" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a><a id="2214" class="Symbol">)</a> <a id="2216" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="2218" class="Symbol">(</a><a id="2219" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2221" class="Symbol">(</a><a id="2222" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2224" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2226" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2227" class="Symbol">)</a> <a id="2229" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2231" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2232" class="Symbol">))</a>
         <a id="2244" class="Symbol">→</a> <a id="2246" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2254" href="blog/syntax-guided-synthesis/index.html#2082" class="Bound">f</a> <a id="2256" class="Symbol">(</a><a id="2257" href="blog/syntax-guided-synthesis/index.html#2129" class="Bound">x</a> <a id="2259" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2261" href="blog/syntax-guided-synthesis/index.html#2131" class="Bound">y</a><a id="2262" class="Symbol">)</a>
</pre>
<p>If we can successfully produce an element of <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code>, we have a proof that <code>f</code> is an implementation of <code>max</code>. Of course, actually producing such a thing is rather tricky; it’s equivalent to determining if <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> <code>f</code> is <span class="Agda"><a href="Relation.Nullary.html#1520" class="Record">Dec</a></span>idable for the given input.</p>
<p>In the first three cases, we have some conflicting piece of information, so we are unable to produce a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>:</p>
<pre class="Agda"><a id="decideMax"></a><a id="2679" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2689" class="Symbol">:</a> <a id="2691" class="Symbol">(</a><a id="2692" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2694" class="Symbol">:</a> <a id="2696" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2698" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="2700" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2702" class="Symbol">→</a> <a id="2704" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2705" class="Symbol">)</a> <a id="2707" class="Symbol">→</a> <a id="2709" class="Symbol">(</a><a id="2710" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a> <a id="2712" class="Symbol">:</a> <a id="2714" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2716" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="2718" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="2719" class="Symbol">)</a> <a id="2721" class="Symbol">→</a> <a id="2723" href="Relation.Nullary.html#1520" class="Record">Dec</a> <a id="2727" class="Symbol">(</a><a id="2728" href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a> <a id="2736" href="blog/syntax-guided-synthesis/index.html#2692" class="Bound">f</a> <a id="2738" href="blog/syntax-guided-synthesis/index.html#2710" class="Bound">i</a><a id="2739" class="Symbol">)</a>
<a id="2741" href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a> <a id="2751" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2753" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a><a id="2754" class="Symbol">@(</a><a id="2756" href="blog/syntax-guided-synthesis/index.html#2756" class="Bound">x</a> <a id="2758" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2760" href="blog/syntax-guided-synthesis/index.html#2760" class="Bound">y</a><a id="2761" class="Symbol">)</a> <a id="2763" class="Keyword">with</a> <a id="2768" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2770" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a> <a id="2772" class="Symbol">|</a> <a id="2774" href="Relation.Binary.PropositionalEquality.html#2391" class="Function">inspect</a> <a id="2782" href="blog/syntax-guided-synthesis/index.html#2751" class="Bound">f</a> <a id="2784" href="blog/syntax-guided-synthesis/index.html#2753" class="Bound">i</a>
<a id="2786" class="Symbol">...</a> <a id="2790" class="Symbol">|</a> <a id="2792" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2794" class="Symbol">|</a> <a id="2796" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">[</a> <a id="2798" href="blog/syntax-guided-synthesis/index.html#2798" class="Bound">fi≡o</a> <a id="2803" href="Relation.Binary.PropositionalEquality.html#2365" class="InductiveConstructor Operator">]</a> <a id="2805" class="Keyword">with</a> <a id="2810" class="Bound">x</a> <a id="2812" href="Data.Nat.Properties.html#5527" class="Function Operator">≤?</a> <a id="2815" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a> <a id="2817" class="Symbol">|</a> <a id="2819" class="Bound">y</a> <a id="2821" href="Data.Nat.Properties.html#5527" class="Function Operator">≤?</a> <a id="2824" href="blog/syntax-guided-synthesis/index.html#2792" class="Bound">o</a>
<a id="2826" class="Symbol">...</a> <a id="2830" class="Symbol">|</a> <a id="2832" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="2835" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2840" class="Symbol">|</a> <a id="2842" class="Symbol">_</a> <a id="2844" class="Symbol">=</a> <a id="2846" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="2849" class="Symbol">λ</a> <a id="2851" class="Symbol">{</a> <a id="2853" class="Symbol">(</a><a id="2854" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2861" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2865" class="Symbol">_</a> <a id="2867" class="Symbol">_)</a> <a id="2870" class="Symbol">→</a>
        <a id="2880" href="Relation.Nullary.Negation.Core.html#787" class="Function">contradiction</a> <a id="2894" class="Symbol">(</a><a id="2895" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="2903" href="blog/syntax-guided-synthesis/index.html#2861" class="Bound">x≤o</a> <a id="2907" class="Symbol">(</a><a id="2908" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="2920" class="Bound">fi≡o</a><a id="2924" class="Symbol">))</a> <a id="2927" href="blog/syntax-guided-synthesis/index.html#2835" class="Bound">¬x≤o</a> <a id="2932" class="Symbol">}</a>
<a id="2934" class="Symbol">...</a> <a id="2938" class="Symbol">|</a> <a id="2940" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="2944" class="Symbol">_</a> <a id="2946" class="Symbol">|</a> <a id="2948" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="2951" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="2956" class="Symbol">=</a> <a id="2958" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="2961" class="Symbol">λ</a> <a id="2963" class="Symbol">{</a> <a id="2965" class="Symbol">(</a><a id="2966" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="2973" href="blog/syntax-guided-synthesis/index.html#2973" class="Bound">x</a> <a id="2975" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="2979" href="blog/syntax-guided-synthesis/index.html#2979" class="Bound">x₂</a><a id="2981" class="Symbol">)</a> <a id="2983" class="Symbol">→</a>
        <a id="2993" href="Relation.Nullary.Negation.Core.html#787" class="Function">contradiction</a> <a id="3007" class="Symbol">(</a><a id="3008" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="3016" href="blog/syntax-guided-synthesis/index.html#2975" class="Bound">y≤o</a> <a id="3020" class="Symbol">(</a><a id="3021" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="3033" class="Bound">fi≡o</a><a id="3037" class="Symbol">))</a> <a id="3040" href="blog/syntax-guided-synthesis/index.html#2951" class="Bound">¬y≤o</a> <a id="3045" class="Symbol">}</a>
<a id="3047" class="Symbol">...</a> <a id="3051" class="Symbol">|</a> <a id="3053" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="3057" href="blog/syntax-guided-synthesis/index.html#3057" class="Bound">x≤o</a> <a id="3061" class="Symbol">|</a> <a id="3063" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="3067" href="blog/syntax-guided-synthesis/index.html#3067" class="Bound">y≤o</a> <a id="3071" class="Keyword">with</a> <a id="3076" class="Bound">o</a> <a id="3078" href="Data.Nat.Properties.html#2538" class="Function Operator">≟</a> <a id="3080" class="Bound">x</a> <a id="3082" class="Symbol">|</a> <a id="3084" class="Bound">o</a> <a id="3086" href="Data.Nat.Properties.html#2538" class="Function Operator">≟</a> <a id="3088" class="Bound">y</a>
<a id="3090" class="Symbol">...</a> <a id="3094" class="Symbol">|</a> <a id="3096" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="3099" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a> <a id="3103" class="Symbol">|</a> <a id="3105" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="3108" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a> <a id="3112" class="Symbol">=</a>
        <a id="3122" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="3125" class="Symbol">λ</a> <a id="3127" class="Symbol">{</a> <a id="3129" class="Symbol">(</a><a id="3130" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3137" href="blog/syntax-guided-synthesis/index.html#3137" class="Bound">x</a> <a id="3139" href="blog/syntax-guided-synthesis/index.html#3139" class="Bound">x₁</a> <a id="3142" class="Symbol">(</a><a id="3143" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="3148" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3150" class="Symbol">))</a> <a id="3153" class="Symbol">→</a>
                  <a id="3173" href="Relation.Nullary.Negation.Core.html#787" class="Function">contradiction</a> <a id="3187" class="Symbol">(</a><a id="3188" href="Relation.Binary.PropositionalEquality.Core.html#1738" class="Function">trans</a> <a id="3194" class="Symbol">(</a><a id="3195" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3199" class="Bound">fi≡o</a><a id="3203" class="Symbol">)</a> <a id="3205" href="blog/syntax-guided-synthesis/index.html#3148" class="Bound">x₂</a><a id="3207" class="Symbol">)</a> <a id="3209" href="blog/syntax-guided-synthesis/index.html#3099" class="Bound">x≠o</a>
             <a id="3226" class="Symbol">;</a> <a id="3228" class="Symbol">(</a><a id="3229" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3236" href="blog/syntax-guided-synthesis/index.html#3236" class="Bound">x</a> <a id="3238" href="blog/syntax-guided-synthesis/index.html#3238" class="Bound">x₁</a> <a id="3241" class="Symbol">(</a><a id="3242" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="3247" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3248" class="Symbol">))</a> <a id="3251" class="Symbol">→</a>
                  <a id="3271" href="Relation.Nullary.Negation.Core.html#787" class="Function">contradiction</a> <a id="3285" class="Symbol">(</a><a id="3286" href="Relation.Binary.PropositionalEquality.Core.html#1738" class="Function">trans</a> <a id="3292" class="Symbol">(</a><a id="3293" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3297" class="Bound">fi≡o</a><a id="3301" class="Symbol">)</a> <a id="3303" href="blog/syntax-guided-synthesis/index.html#3247" class="Bound">y</a><a id="3304" class="Symbol">)</a> <a id="3306" href="blog/syntax-guided-synthesis/index.html#3108" class="Bound">y≠o</a>
             <a id="3323" class="Symbol">}</a>
</pre>
<p>Otherwise, we have a proof that <code>o</code> is equal to either <code>y</code> or <code>x</code>:</p>
<pre class="Agda"><a id="3402" class="Symbol">...</a> <a id="3406" class="Symbol">|</a> <a id="3408" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="3411" href="blog/syntax-guided-synthesis/index.html#3411" class="Bound">proof</a> <a id="3417" class="Symbol">|</a> <a id="3419" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="3423" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a> <a id="3427" class="Symbol">=</a> <a id="3429" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a>
        <a id="3441" class="Symbol">(</a><a id="3442" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3449" class="Symbol">(</a><a id="3450" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="3458" class="Bound">x≤o</a> <a id="3462" class="Symbol">(</a><a id="3463" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="3475" class="Symbol">(</a><a id="3476" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3480" class="Bound">fi≡o</a><a id="3484" class="Symbol">)))</a>
                <a id="3504" class="Symbol">(</a><a id="3505" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="3513" class="Bound">y≤o</a> <a id="3517" class="Symbol">(</a><a id="3518" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="3530" class="Symbol">(</a><a id="3531" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3535" class="Bound">fi≡o</a><a id="3539" class="Symbol">)))</a>
                <a id="3559" class="Symbol">(</a><a id="3560" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="3565" class="Symbol">(</a><a id="3566" href="Relation.Binary.PropositionalEquality.Core.html#1738" class="Function">trans</a> <a id="3572" class="Bound">fi≡o</a> <a id="3577" href="blog/syntax-guided-synthesis/index.html#3423" class="Bound">o≡y</a><a id="3580" class="Symbol">)))</a>
<a id="3584" class="Symbol">...</a> <a id="3588" class="Symbol">|</a> <a id="3590" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="3594" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a> <a id="3598" class="Symbol">|</a> <a id="3600" class="Symbol">_</a> <a id="3602" class="Symbol">=</a> <a id="3604" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a>
        <a id="3616" class="Symbol">(</a><a id="3617" href="blog/syntax-guided-synthesis/index.html#2119" class="InductiveConstructor">is-max</a> <a id="3624" class="Symbol">(</a><a id="3625" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="3633" class="Bound">x≤o</a> <a id="3637" class="Symbol">(</a><a id="3638" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="3650" class="Symbol">(</a><a id="3651" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3655" class="Bound">fi≡o</a><a id="3659" class="Symbol">)))</a>
                <a id="3679" class="Symbol">(</a><a id="3680" href="Data.Nat.Properties.html#4757" class="Function">≤-trans</a> <a id="3688" class="Bound">y≤o</a> <a id="3692" class="Symbol">(</a><a id="3693" href="Data.Nat.Properties.html#4468" class="Function">≤-reflexive</a> <a id="3705" class="Symbol">(</a><a id="3706" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="3710" class="Bound">fi≡o</a><a id="3714" class="Symbol">)))</a>
                <a id="3734" class="Symbol">(</a><a id="3735" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="3740" class="Symbol">(</a><a id="3741" href="Relation.Binary.PropositionalEquality.Core.html#1738" class="Function">trans</a> <a id="3747" class="Bound">fi≡o</a> <a id="3752" href="blog/syntax-guided-synthesis/index.html#3594" class="Bound">o≡x</a><a id="3755" class="Symbol">)))</a>
</pre>
<p><span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span> is a proof that our function is an implementation of <code>max</code>, and <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2679" class="Function">decideMax</a></span> is a proof that “we’d know one if we saw one.” So that’s the specification taken care of. The next step is to define the syntax we’d like to guard our search.</p>
<p>The paper presents this syntax as a BNF grammar, but my thought is why use a grammar when we could instead use a type system? Our syntax is a tiny little branching calculus, capable of representing <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>s and branching <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a></span>itionals:</p>
<pre class="Agda"><a id="4279" class="Keyword">mutual</a>
  <a id="4288" class="Keyword">data</a> <a id="Term"></a><a id="4293" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4298" class="Symbol">:</a> <a id="4300" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4304" class="Keyword">where</a>
    <a id="Term.var-x"></a><a id="4314" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4320" class="Symbol">:</a> <a id="4322" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.var-y"></a><a id="4331" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4337" class="Symbol">:</a> <a id="4339" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.const"></a><a id="4348" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4354" class="Symbol">:</a> <a id="4356" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4358" class="Symbol">→</a> <a id="4360" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>
    <a id="Term.if-then-else"></a><a id="4369" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4382" class="Symbol">:</a> <a id="4384" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4389" class="Symbol">→</a> <a id="4391" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4396" class="Symbol">→</a> <a id="4398" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4403" class="Symbol">→</a> <a id="4405" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a>

  <a id="4413" class="Keyword">data</a> <a id="Cond"></a><a id="4418" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4423" class="Symbol">:</a> <a id="4425" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4429" class="Keyword">where</a>
    <a id="Cond.leq"></a><a id="4439" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4443" class="Symbol">:</a> <a id="4445" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4450" class="Symbol">→</a> <a id="4452" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4457" class="Symbol">→</a> <a id="4459" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.and"></a><a id="4468" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="4472" class="Symbol">:</a> <a id="4474" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4479" class="Symbol">→</a> <a id="4481" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4486" class="Symbol">→</a> <a id="4488" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
    <a id="Cond.invert"></a><a id="4497" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="4504" class="Symbol">:</a> <a id="4506" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4511" class="Symbol">→</a> <a id="4513" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a>
</pre>
<p>All that’s left for our example is the ability to “compile” a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span> down to a candidate function. Just pattern match on the constructors and push the inputs around until we’re done:</p>
<pre class="Agda"><a id="4719" class="Keyword">mutual</a>
  <a id="eval"></a><a id="4728" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4733" class="Symbol">:</a> <a id="4735" href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a> <a id="4740" class="Symbol">→</a> <a id="4742" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4744" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="4746" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4748" class="Symbol">→</a> <a id="4750" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
  <a id="4754" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4759" href="blog/syntax-guided-synthesis/index.html#4314" class="InductiveConstructor">var-x</a> <a id="4765" class="Symbol">(</a><a id="4766" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a> <a id="4768" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4770" href="blog/syntax-guided-synthesis/index.html#4770" class="Bound">y</a><a id="4771" class="Symbol">)</a> <a id="4773" class="Symbol">=</a> <a id="4775" href="blog/syntax-guided-synthesis/index.html#4766" class="Bound">x</a>
  <a id="4779" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4784" href="blog/syntax-guided-synthesis/index.html#4331" class="InductiveConstructor">var-y</a> <a id="4790" class="Symbol">(</a><a id="4791" href="blog/syntax-guided-synthesis/index.html#4791" class="Bound">x</a> <a id="4793" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4795" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a><a id="4796" class="Symbol">)</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="blog/syntax-guided-synthesis/index.html#4795" class="Bound">y</a>
  <a id="4804" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4809" class="Symbol">(</a><a id="4810" href="blog/syntax-guided-synthesis/index.html#4348" class="InductiveConstructor">const</a> <a id="4816" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a><a id="4817" class="Symbol">)</a> <a id="4819" class="Symbol">(</a><a id="4820" href="blog/syntax-guided-synthesis/index.html#4820" class="Bound">x</a> <a id="4822" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4824" href="blog/syntax-guided-synthesis/index.html#4824" class="Bound">y</a><a id="4825" class="Symbol">)</a> <a id="4827" class="Symbol">=</a> <a id="4829" href="blog/syntax-guided-synthesis/index.html#4816" class="Bound">c</a>
  <a id="4833" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4838" class="Symbol">(</a><a id="4839" href="blog/syntax-guided-synthesis/index.html#4369" class="InductiveConstructor">if-then-else</a> <a id="4852" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4854" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4856" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a><a id="4857" class="Symbol">)</a> <a id="4859" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4861" class="Symbol">=</a>
    <a id="4867" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="4870" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4879" href="blog/syntax-guided-synthesis/index.html#4852" class="Bound">c</a> <a id="4881" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4883" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="4888" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4893" href="blog/syntax-guided-synthesis/index.html#4854" class="Bound">t</a> <a id="4895" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a> <a id="4897" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="4902" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4907" href="blog/syntax-guided-synthesis/index.html#4856" class="Bound">f</a> <a id="4909" href="blog/syntax-guided-synthesis/index.html#4859" class="Bound">i</a>

  <a id="evalCond"></a><a id="4914" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4923" class="Symbol">:</a> <a id="4925" href="blog/syntax-guided-synthesis/index.html#4418" class="Datatype">Cond</a> <a id="4930" class="Symbol">→</a> <a id="4932" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4934" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="4936" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4938" class="Symbol">→</a> <a id="4940" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
  <a id="4947" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="4956" class="Symbol">(</a><a id="4957" href="blog/syntax-guided-synthesis/index.html#4439" class="InductiveConstructor">leq</a> <a id="4961" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4963" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a><a id="4964" class="Symbol">)</a> <a id="4966" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a>   <a id="4970" class="Symbol">=</a> <a id="4972" href="Relation.Nullary.html#1590" class="Field">Dec.does</a> <a id="4981" class="Symbol">(</a><a id="4982" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4987" href="blog/syntax-guided-synthesis/index.html#4961" class="Bound">m</a> <a id="4989" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a> <a id="4991" href="Data.Nat.Properties.html#5527" class="Function Operator">≤?</a> <a id="4994" href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a> <a id="4999" href="blog/syntax-guided-synthesis/index.html#4963" class="Bound">n</a> <a id="5001" href="blog/syntax-guided-synthesis/index.html#4966" class="Bound">i</a><a id="5002" class="Symbol">)</a>
  <a id="5006" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5015" class="Symbol">(</a><a id="5016" href="blog/syntax-guided-synthesis/index.html#4468" class="InductiveConstructor">and</a> <a id="5020" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5023" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a><a id="5025" class="Symbol">)</a> <a id="5027" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5029" class="Symbol">=</a> <a id="5031" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5040" href="blog/syntax-guided-synthesis/index.html#5020" class="Bound">c1</a> <a id="5043" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a> <a id="5045" href="Data.Bool.Base.html#995" class="Function Operator">∧</a> <a id="5047" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5056" href="blog/syntax-guided-synthesis/index.html#5023" class="Bound">c2</a> <a id="5059" href="blog/syntax-guided-synthesis/index.html#5027" class="Bound">i</a>
  <a id="5063" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5072" class="Symbol">(</a><a id="5073" href="blog/syntax-guided-synthesis/index.html#4497" class="InductiveConstructor">invert</a> <a id="5080" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a><a id="5081" class="Symbol">)</a> <a id="5083" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a>  <a id="5086" class="Symbol">=</a> <a id="5088" href="Data.Bool.Base.html#941" class="Function">not</a> <a id="5092" class="Symbol">(</a><a id="5093" href="blog/syntax-guided-synthesis/index.html#4914" class="Function">evalCond</a> <a id="5102" href="blog/syntax-guided-synthesis/index.html#5080" class="Bound">c</a> <a id="5104" href="blog/syntax-guided-synthesis/index.html#5083" class="Bound">i</a><a id="5105" class="Symbol">)</a>
</pre>
<p>So that’s most of the idea; we’ve specified what we’re looking for, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#2073" class="Datatype">MaxSpec</a></span>, what our syntax is, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4293" class="Datatype">Term</a></span>, and a way of compiling our syntax into functions, via <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#4728" class="Function">eval</a></span>. This is the gist of the technique; the rest is just algorithms.</p>
<p>The paper presents several algorithms and evaluates their performances. But one is clearly better than the others in the included benchmarks, so we’ll just go through that one.</p>
<p>Our algorithm to synthesize code corresponding to the specification takes a few parameters. We’ve seen the first few:</p>
<pre class="Agda"><a id="5677" class="Keyword">module</a> <a id="Solver"></a><a id="5684" href="blog/syntax-guided-synthesis/index.html#5684" class="Module">Solver</a>
    <a id="5695" class="Symbol">{</a><a id="5696" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5701" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5703" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a> <a id="5705" class="Symbol">:</a> <a id="5707" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="5710" class="Symbol">}</a>
    <a id="5716" class="Symbol">(</a><a id="5717" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5722" class="Symbol">:</a> <a id="5724" class="Symbol">(</a><a id="5725" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5727" class="Symbol">→</a> <a id="5729" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5730" class="Symbol">)</a> <a id="5732" class="Symbol">→</a> <a id="5734" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5736" class="Symbol">→</a> <a id="5738" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="5741" class="Symbol">)</a>
    <a id="5747" class="Symbol">(</a><a id="5748" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="5755" class="Symbol">:</a> <a id="5757" class="Symbol">(</a><a id="5758" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5760" class="Symbol">:</a> <a id="5762" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5764" class="Symbol">→</a> <a id="5766" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5767" class="Symbol">)</a> <a id="5769" class="Symbol">→</a> <a id="5771" class="Symbol">(</a><a id="5772" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a> <a id="5774" class="Symbol">:</a> <a id="5776" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="5777" class="Symbol">)</a> <a id="5779" class="Symbol">→</a> <a id="5781" href="Relation.Nullary.html#1520" class="Record">Dec</a> <a id="5785" class="Symbol">(</a><a id="5786" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="5791" href="blog/syntax-guided-synthesis/index.html#5758" class="Bound">f</a> <a id="5793" href="blog/syntax-guided-synthesis/index.html#5772" class="Bound">i</a><a id="5794" class="Symbol">))</a>
    <a id="5801" class="Symbol">(</a><a id="5802" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="5810" class="Symbol">:</a> <a id="5812" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="5817" class="Symbol">→</a> <a id="5819" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="5824" class="Symbol">)</a>
</pre>
<p>However, we also need a way of synthesizing terms in our <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>uage. For that, we’ll use <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which maps a natural number to a term:</p>
<pre class="Agda">    <a id="5995" class="Symbol">(</a><a id="5996" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6006" class="Symbol">:</a> <a id="6008" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="6010" class="Symbol">→</a> <a id="6012" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6016" class="Symbol">)</a>
</pre>
<p>Although it’s not necessary for the algorithm, we should be able to implement <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a></span> over <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>, which states every <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span> is eventually produced by <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>:</p>
<pre class="Agda">    <a id="6234" class="Symbol">(</a><a id="6235" href="blog/syntax-guided-synthesis/index.html#6235" class="Bound">exhaustive</a> <a id="6246" class="Symbol">:</a> <a id="6248" class="Symbol">(</a><a id="6249" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a> <a id="6251" class="Symbol">:</a> <a id="6253" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6257" class="Symbol">)</a> <a id="6259" class="Symbol">→</a> <a id="6261" href="Data.Product.html#925" class="Function">Σ[</a> <a id="6264" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6266" href="Data.Product.html#925" class="Function">∈</a> <a id="6268" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="6270" href="Data.Product.html#925" class="Function">]</a> <a id="6272" class="Symbol">(</a><a id="6273" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="6283" href="blog/syntax-guided-synthesis/index.html#6264" class="Bound">n</a> <a id="6285" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="6287" href="blog/syntax-guided-synthesis/index.html#6249" class="Bound">x</a><a id="6288" class="Symbol">))</a>
</pre>
<p>Finally, we need an <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> capable of telling us if our solution is correct. This might sound a bit like cheating, but behind the scenes it’s just a magic SMT solver. The idea is that SMT can either confirm that our program is correct, or produce a counterexample that violates the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a></span>. The type here is a bit crazy, so we’ll take it one step at a time.</p>
<p>An <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span> is a function that takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a></span>…</p>
<pre class="Agda">    <a id="6742" class="Symbol">(</a><a id="6743" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a>
      <a id="6756" class="Symbol">:</a> <a id="6758" class="Symbol">(</a><a id="6759" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a> <a id="6763" class="Symbol">:</a> <a id="6765" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a><a id="6769" class="Symbol">)</a>
</pre>
<p>and either gives back a function that can produce a <code>spec (compile exp)</code> for every input:</p>
<pre class="Agda">      <a id="6877" class="Symbol">→</a>   <a id="6881" class="Symbol">((</a><a id="6883" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a> <a id="6885" class="Symbol">:</a> <a id="6887" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="6888" class="Symbol">)</a> <a id="6890" class="Symbol">→</a> <a id="6892" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="6897" class="Symbol">(</a><a id="6898" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="6906" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="6909" class="Symbol">)</a> <a id="6911" href="blog/syntax-guided-synthesis/index.html#6883" class="Bound">i</a><a id="6912" class="Symbol">)</a>
</pre>
<p>or gives back some input which is not a <code>spec (compile exp)</code>:</p>
<pre class="Agda">        <a id="6994" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="6996" href="Data.Product.html#925" class="Function">Σ[</a> <a id="6999" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a> <a id="7001" href="Data.Product.html#925" class="Function">∈</a> <a id="7003" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7005" href="Data.Product.html#925" class="Function">]</a> <a id="7007" href="Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="7009" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="7014" class="Symbol">(</a><a id="7015" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="7023" href="blog/syntax-guided-synthesis/index.html#6759" class="Bound">exp</a><a id="7026" class="Symbol">)</a> <a id="7028" href="blog/syntax-guided-synthesis/index.html#6999" class="Bound">i</a><a id="7029" class="Symbol">)</a>
    <a id="7035" class="Keyword">where</a>
</pre>
<p>The algorithm here is actually quite clever. The idea is that to try each <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d value in order, attempting to minimize the number of calls we make to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>, because they’re expensive. So instead, well keep a list of every counterexample we’ve seen so far, and ensure that our synthesized function passes all of them before sending it off to the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>. First, we’ll need a data structure to store our search progress:</p>
<pre class="Agda">  <a id="7508" class="Keyword">record</a> <a id="Solver.SearchState"></a><a id="7515" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a> <a id="7527" class="Symbol">:</a> <a id="7529" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="7533" class="Keyword">where</a>
    <a id="7543" class="Keyword">field</a>
      <a id="Solver.SearchState.iteration"></a><a id="7555" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7565" class="Symbol">:</a> <a id="7567" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
      <a id="Solver.SearchState.cases"></a><a id="7575" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7581" class="Symbol">:</a> <a id="7583" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="7588" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a>
  <a id="7592" class="Keyword">open</a> <a id="7597" href="blog/syntax-guided-synthesis/index.html#7515" class="Module">SearchState</a>
</pre>
<p>The initial search state is one in which we start at the beginning, and have no counterexamples:</p>
<pre class="Agda">  <a id="Solver.start"></a><a id="7718" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7724" class="Symbol">:</a> <a id="7726" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
  <a id="7740" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="7750" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7756" class="Symbol">=</a> <a id="7758" class="Number">0</a>
  <a id="7762" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="7768" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a> <a id="7774" class="Symbol">=</a> <a id="7776" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
</pre>
<p>We can try a function by testing every counterexample:</p>
<pre class="Agda">  <a id="Solver.try"></a><a id="7847" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7851" class="Symbol">:</a> <a id="7853" class="Symbol">(</a><a id="7854" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7856" class="Symbol">→</a> <a id="7858" href="blog/syntax-guided-synthesis/index.html#5703" class="Bound">O</a><a id="7859" class="Symbol">)</a> <a id="7861" class="Symbol">→</a> <a id="7863" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="7868" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a> <a id="7870" class="Symbol">→</a> <a id="7872" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
  <a id="7879" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="7883" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a> <a id="7885" class="Symbol">=</a> <a id="7887" href="Data.List.Base.html#4739" class="Function">all</a> <a id="7891" class="Symbol">(</a><a id="7892" href="Relation.Nullary.html#1590" class="Field">Dec.does</a> <a id="7901" href="Function.Base.html#1040" class="Function Operator">∘</a> <a id="7903" href="blog/syntax-guided-synthesis/index.html#5748" class="Bound">decide</a> <a id="7910" href="blog/syntax-guided-synthesis/index.html#7883" class="Bound">f</a><a id="7911" class="Symbol">)</a>
</pre>
<p>and finally, can now attempt to synthesize some code. Our function <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> takes a <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a></span>, and either gives back the next step of the search, or some program, and a proof that it’s what we’re looking for.</p>
<pre class="Agda">  <a id="Solver.check"></a><a id="8151" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a>
      <a id="8163" class="Symbol">:</a> <a id="8165" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
      <a id="8183" class="Symbol">→</a> <a id="8185" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="8207" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="8209" class="Symbol">(</a><a id="8210" href="Data.Product.html#925" class="Function">Σ[</a> <a id="8213" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a> <a id="8217" href="Data.Product.html#925" class="Function">∈</a> <a id="8219" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="8224" href="Data.Product.html#925" class="Function">]</a> <a id="8226" class="Symbol">((</a><a id="8228" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a> <a id="8230" class="Symbol">:</a> <a id="8232" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="8233" class="Symbol">)</a> <a id="8235" class="Symbol">→</a> <a id="8237" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="8242" class="Symbol">(</a><a id="8243" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8251" href="blog/syntax-guided-synthesis/index.html#8213" class="Bound">exp</a><a id="8254" class="Symbol">)</a> <a id="8256" href="blog/syntax-guided-synthesis/index.html#8228" class="Bound">i</a><a id="8257" class="Symbol">))</a>
  <a id="8262" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="8268" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a>
</pre>
<p>We begin by getting and compiling the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a></span>d term:</p>
<pre class="Agda">           <a id="8361" class="Keyword">with</a> <a id="8366" href="blog/syntax-guided-synthesis/index.html#5996" class="Bound">enumerate</a> <a id="8376" class="Symbol">(</a><a id="8377" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8387" href="blog/syntax-guided-synthesis/index.html#8268" class="Bound">ss</a><a id="8389" class="Symbol">)</a>
  <a id="8393" class="Symbol">...</a> <a id="8397" class="Symbol">|</a> <a id="8399" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a> <a id="8403" class="Keyword">with</a> <a id="8408" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="8416" href="blog/syntax-guided-synthesis/index.html#8399" class="Bound">exp</a>
</pre>
<p>check if it passes all the previous counterexamples:</p>
<pre class="Agda">  <a id="8485" class="Symbol">...</a> <a id="8489" class="Symbol">|</a> <a id="8491" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8493" class="Keyword">with</a> <a id="8498" href="blog/syntax-guided-synthesis/index.html#7847" class="Function">try</a> <a id="8502" href="blog/syntax-guided-synthesis/index.html#8491" class="Bound">f</a> <a id="8504" class="Symbol">(</a><a id="8505" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8511" class="Bound">ss</a><a id="8513" class="Symbol">)</a>
</pre>
<p>if it doesn’t, just fail with the next <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a></span>:</p>
<pre class="Agda">  <a id="8586" class="Symbol">...</a> <a id="8590" class="Symbol">|</a> <a id="8592" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a> <a id="8598" class="Symbol">=</a> <a id="8600" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="8605" class="Symbol">(</a><a id="8606" class="Keyword">record</a> <a id="8613" class="Symbol">{</a> <a id="8615" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8625" class="Symbol">=</a> <a id="8627" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="8631" class="Symbol">(</a><a id="8632" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="8642" class="Bound">ss</a><a id="8644" class="Symbol">)</a>
                             <a id="8675" class="Symbol">;</a> <a id="8677" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8683" class="Symbol">=</a> <a id="8685" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="8691" class="Bound">ss</a>
                             <a id="8723" class="Symbol">})</a>
</pre>
<p>Otherwise, our proposed function might just be the thing we’re looking for, so it’s time to consult the <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a></span>:</p>
<pre class="Agda">  <a id="8859" class="Symbol">...</a> <a id="8863" class="Symbol">|</a> <a id="8865" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a> <a id="8870" class="Keyword">with</a> <a id="8875" href="blog/syntax-guided-synthesis/index.html#6743" class="Bound">oracle</a> <a id="8882" class="Bound">exp</a>
</pre>
<p>which either gives a counterexample that we need to record:</p>
<pre class="Agda">  <a id="8958" class="Symbol">...</a> <a id="8962" class="Symbol">|</a> <a id="8964" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="8969" class="Symbol">(</a><a id="8970" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a id="8972" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="8974" class="Symbol">_)</a> <a id="8977" class="Symbol">=</a>
          <a id="8989" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="8994" class="Symbol">(</a><a id="8995" class="Keyword">record</a> <a id="9002" class="Symbol">{</a> <a id="9004" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9014" class="Symbol">=</a> <a id="9016" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="9020" class="Symbol">(</a><a id="9021" href="blog/syntax-guided-synthesis/index.html#7555" class="Field">iteration</a> <a id="9031" class="Bound">ss</a><a id="9033" class="Symbol">)</a>
                       <a id="9058" class="Symbol">;</a> <a id="9060" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9066" class="Symbol">=</a> <a id="9068" href="blog/syntax-guided-synthesis/index.html#8970" class="Bound">y</a> <a id="9070" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9072" href="blog/syntax-guided-synthesis/index.html#7575" class="Field">cases</a> <a id="9078" class="Bound">ss</a>
                       <a id="9104" class="Symbol">})</a>
</pre>
<p>or it confirms that our function satisfies the specification, and thus that were done:</p>
<pre class="Agda">  <a id="9206" class="Symbol">...</a> <a id="9210" class="Symbol">|</a> <a id="9212" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="9217" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a> <a id="9219" class="Symbol">=</a> <a id="9221" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="9226" class="Symbol">(</a><a id="9227" class="Bound">exp</a> <a id="9231" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9233" href="blog/syntax-guided-synthesis/index.html#9217" class="Bound">x</a><a id="9234" class="Symbol">)</a>
</pre>
<p>Pretty cool! The paper gives an optimization that caches the result of every counterexample on every synthesized program, and reuses these whenever that program appears as a subprogram of a larger one. The idea is that we can trade storage so we only ever need to evaluate each subprogram once — important for expensive computations.</p>
<p>Of course, pumping <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> by hand is annoying, so we can instead package it up as <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a></span> which takes a search depth, and iterates <span class="Agda"><a href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a></span> until it runs out of gas or gets the right answer:</p>
<pre class="Agda">  <a id="Solver.solve"></a><a id="9797" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a>
      <a id="9809" class="Symbol">:</a> <a id="9811" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
      <a id="9819" class="Symbol">→</a> <a id="9821" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="9827" class="Symbol">(</a><a id="9828" href="Data.Product.html#925" class="Function">Σ[</a> <a id="9831" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">exp</a> <a id="9835" href="Data.Product.html#925" class="Function">∈</a> <a id="9837" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9842" href="Data.Product.html#925" class="Function">]</a> <a id="9844" class="Symbol">((</a><a id="9846" href="blog/syntax-guided-synthesis/index.html#9846" class="Bound">i</a> <a id="9848" class="Symbol">:</a> <a id="9850" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="9851" class="Symbol">)</a> <a id="9853" class="Symbol">→</a> <a id="9855" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="9860" class="Symbol">(</a><a id="9861" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="9869" href="blog/syntax-guided-synthesis/index.html#9831" class="Bound">exp</a><a id="9872" class="Symbol">)</a> <a id="9874" href="blog/syntax-guided-synthesis/index.html#9846" class="Bound">i</a><a id="9875" class="Symbol">))</a>
  <a id="9880" href="blog/syntax-guided-synthesis/index.html#9797" class="Function">solve</a> <a id="9886" class="Symbol">=</a> <a id="9888" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="9891" href="blog/syntax-guided-synthesis/index.html#7718" class="Function">start</a>
    <a id="9901" class="Keyword">where</a>
      <a id="9913" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a>
          <a id="9926" class="Symbol">:</a> <a id="9928" href="blog/syntax-guided-synthesis/index.html#7515" class="Record">SearchState</a>
          <a id="9950" class="Symbol">→</a> <a id="9952" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
          <a id="9964" class="Symbol">→</a> <a id="9966" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a>
              <a id="9986" class="Symbol">(</a><a id="9987" href="Agda.Builtin.Sigma.html#148" class="Record">Σ</a> <a id="9989" href="blog/syntax-guided-synthesis/index.html#5696" class="Bound">Lang</a> <a id="9994" class="Symbol">(λ</a> <a id="9997" href="blog/syntax-guided-synthesis/index.html#9997" class="Bound">exp</a> <a id="10001" class="Symbol">→</a> <a id="10003" class="Symbol">(</a><a id="10004" href="blog/syntax-guided-synthesis/index.html#10004" class="Bound">i</a> <a id="10006" class="Symbol">:</a> <a id="10008" href="blog/syntax-guided-synthesis/index.html#5701" class="Bound">I</a><a id="10009" class="Symbol">)</a> <a id="10011" class="Symbol">→</a> <a id="10013" href="blog/syntax-guided-synthesis/index.html#5717" class="Bound">spec</a> <a id="10018" class="Symbol">(</a><a id="10019" href="blog/syntax-guided-synthesis/index.html#5802" class="Bound">compile</a> <a id="10027" href="blog/syntax-guided-synthesis/index.html#9997" class="Bound">exp</a><a id="10030" class="Symbol">)</a> <a id="10032" href="blog/syntax-guided-synthesis/index.html#10004" class="Bound">i</a><a id="10033" class="Symbol">))</a>
      <a id="10042" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10045" href="blog/syntax-guided-synthesis/index.html#10045" class="Bound">ss</a> <a id="10048" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a> <a id="10053" class="Symbol">=</a> <a id="10055" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
      <a id="10069" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10072" href="blog/syntax-guided-synthesis/index.html#10072" class="Bound">ss</a> <a id="10075" class="Symbol">(</a><a id="10076" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="10080" href="blog/syntax-guided-synthesis/index.html#10080" class="Bound">n</a><a id="10081" class="Symbol">)</a> <a id="10083" class="Keyword">with</a> <a id="10088" href="blog/syntax-guided-synthesis/index.html#8151" class="Function">check</a> <a id="10094" href="blog/syntax-guided-synthesis/index.html#10072" class="Bound">ss</a>
      <a id="10103" class="Symbol">...</a> <a id="10107" class="Symbol">|</a> <a id="10109" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="10114" href="blog/syntax-guided-synthesis/index.html#10114" class="Bound">x</a> <a id="10116" class="Symbol">=</a> <a id="10118" href="blog/syntax-guided-synthesis/index.html#9913" class="Function">go</a> <a id="10121" class="Bound">ss</a> <a id="10124" class="Bound">n</a>
      <a id="10132" class="Symbol">...</a> <a id="10136" class="Symbol">|</a> <a id="10138" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="10143" href="blog/syntax-guided-synthesis/index.html#10143" class="Bound">y</a> <a id="10145" class="Symbol">=</a> <a id="10147" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="10152" href="blog/syntax-guided-synthesis/index.html#10143" class="Bound">y</a>
</pre>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Generic Parallel Functional Programming</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/generic-parallel-fp/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/generic-parallel-fp/index.html</guid>
      <pubDate>2022-03-12</pubDate>
      <content:encoded><![CDATA[
        <!--
<pre class="Agda"><a id="164" class="Keyword">module</a> <a id="171" href="blog.generic-parallel-fp.html" class="Module">blog.generic-parallel-fp</a> <a id="196" class="Keyword">where</a>

<a id="203" class="Keyword">open</a> <a id="208" class="Keyword">import</a> <a id="215" href="Agda.Primitive.html" class="Module">Agda.Primitive</a>

<a id="231" class="Keyword">private</a>
  <a id="241" class="Keyword">variable</a>
    <a id="254" href="blog.generic-parallel-fp.html#254" class="Generalizable">A</a> <a id="256" class="Symbol">:</a> <a id="258" href="Agda.Primitive.html#320" class="Primitive">Set</a>
    <a id="266" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="268" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="270" class="Symbol">:</a> <a id="272" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="276" class="Symbol">→</a> <a id="278" href="Agda.Primitive.html#320" class="Primitive">Set</a>
    <a id="286" href="blog.generic-parallel-fp.html#286" class="Generalizable">𝓁</a> <a id="288" class="Symbol">:</a> <a id="290" href="Agda.Primitive.html#591" class="Postulate">Level</a>

<a id="297" class="Keyword">record</a> <a id="Monoid"></a><a id="304" href="blog.generic-parallel-fp.html#304" class="Record">Monoid</a> <a id="311" class="Symbol">(</a><a id="312" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="314" class="Symbol">:</a> <a id="316" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="319" class="Symbol">)</a> <a id="321" class="Symbol">:</a> <a id="323" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="327" class="Keyword">where</a>
  <a id="335" class="Keyword">infixr</a> <a id="342" class="Number">6</a> <a id="344" href="blog.generic-parallel-fp.html#376" class="Field Operator">_&lt;&gt;_</a>
  <a id="351" class="Keyword">field</a>
    <a id="Monoid.mempty"></a><a id="361" href="blog.generic-parallel-fp.html#361" class="Field">mempty</a> <a id="368" class="Symbol">:</a> <a id="370" href="blog.generic-parallel-fp.html#312" class="Bound">A</a>
    <a id="Monoid._&lt;&gt;_"></a><a id="376" href="blog.generic-parallel-fp.html#376" class="Field Operator">_&lt;&gt;_</a> <a id="381" class="Symbol">:</a> <a id="383" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="385" class="Symbol">→</a> <a id="387" href="blog.generic-parallel-fp.html#312" class="Bound">A</a> <a id="389" class="Symbol">→</a> <a id="391" href="blog.generic-parallel-fp.html#312" class="Bound">A</a>
<a id="393" class="Keyword">open</a> <a id="398" href="blog.generic-parallel-fp.html#304" class="Module">Monoid</a> <a id="405" class="Symbol">⦃</a> <a id="407" class="Symbol">...</a> <a id="411" class="Symbol">⦄</a>


<a id="415" class="Keyword">open</a> <a id="420" class="Keyword">import</a> <a id="427" href="Function.html" class="Module">Function</a>
<a id="436" class="Keyword">open</a> <a id="441" class="Keyword">import</a> <a id="448" href="Data.Product.html" class="Module">Data.Product</a> <a id="461" class="Keyword">hiding</a> <a id="468" class="Symbol">(</a><a id="469" href="Data.Product.html#3069" class="Function">zip</a><a id="472" class="Symbol">)</a>
</pre>-->
<p>Today we’re heading back into the Elliottverse — a beautiful world where programming is principled and makes sense. The paper of the week is Conal Elliott’s <a href="http://conal.net/papers/generic-parallel-functional/generic-parallel-functional.pdf">Generic Parallel Functional Programming</a>, which productively addresses the duality between “easy to reason about” and “fast to run.”</p>
<p>Consider the case of a right-associated list, we can give a scan of it in linear time and constant space:</p>
<pre class="Agda"><a id="989" class="Keyword">module</a> <a id="ExR"></a><a id="996" href="blog/generic-parallel-fp/index.html#996" class="Module">ExR</a> <a id="1000" class="Keyword">where</a>
  <a id="1008" class="Keyword">data</a> <a id="ExR.RList"></a><a id="1013" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1019" class="Symbol">(</a><a id="1020" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1022" class="Symbol">:</a> <a id="1024" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="1027" class="Symbol">)</a> <a id="1029" class="Symbol">:</a> <a id="1031" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1035" class="Keyword">where</a>
    <a id="ExR.RList.RNil"></a><a id="1045" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a> <a id="1050" class="Symbol">:</a> <a id="1052" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1058" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a>
    <a id="ExR.RList._◁_"></a><a id="1064" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">_◁_</a> <a id="1068" class="Symbol">:</a> <a id="1070" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1072" class="Symbol">→</a> <a id="1074" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1080" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a> <a id="1082" class="Symbol">→</a> <a id="1084" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1090" href="blog/generic-parallel-fp/index.html#1020" class="Bound">A</a>

  <a id="1095" class="Keyword">infixr</a> <a id="1102" class="Number">5</a> <a id="1104" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">_◁_</a>

  <a id="ExR.scanR"></a><a id="1111" href="blog/generic-parallel-fp/index.html#1111" class="Function">scanR</a> <a id="1117" class="Symbol">:</a> <a id="1119" class="Symbol">⦃</a> <a id="1121" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1128" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1130" class="Symbol">⦄</a> <a id="1132" class="Symbol">→</a> <a id="1134" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1140" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1142" class="Symbol">→</a> <a id="1144" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1150" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="1154" href="blog/generic-parallel-fp/index.html#1111" class="Function">scanR</a> <a id="1160" class="Symbol">=</a> <a id="1162" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1165" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
    <a id="1176" class="Keyword">where</a>
      <a id="1188" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1191" class="Symbol">:</a> <a id="1193" class="Symbol">⦃</a> <a id="1195" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1202" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1204" class="Symbol">⦄</a> <a id="1206" class="Symbol">→</a> <a id="1208" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1210" class="Symbol">→</a> <a id="1212" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1218" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1220" class="Symbol">→</a> <a id="1222" href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a> <a id="1228" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
      <a id="1236" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1239" href="blog/generic-parallel-fp/index.html#1239" class="Bound">acc</a> <a id="1243" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a> <a id="1248" class="Symbol">=</a> <a id="1250" href="blog/generic-parallel-fp/index.html#1045" class="InductiveConstructor">RNil</a>
      <a id="1261" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1264" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1268" class="Symbol">(</a><a id="1269" href="blog/generic-parallel-fp/index.html#1269" class="Bound">x</a> <a id="1271" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">◁</a> <a id="1273" href="blog/generic-parallel-fp/index.html#1273" class="Bound">xs</a><a id="1275" class="Symbol">)</a> <a id="1277" class="Symbol">=</a> <a id="1279" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1283" href="blog/generic-parallel-fp/index.html#1064" class="InductiveConstructor Operator">◁</a> <a id="1285" href="blog/generic-parallel-fp/index.html#1188" class="Function">go</a> <a id="1288" class="Symbol">(</a><a id="1289" href="blog/generic-parallel-fp/index.html#1264" class="Bound">acc</a> <a id="1293" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="1296" href="blog/generic-parallel-fp/index.html#1269" class="Bound">x</a><a id="1297" class="Symbol">)</a> <a id="1299" href="blog/generic-parallel-fp/index.html#1273" class="Bound">xs</a>
</pre>
<p>This is a nice functional algorithm that runs in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> time, and requires <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> space. However, consider the equivalent algorithm over left-associative lists:</p>
<pre class="Agda"><a id="1473" class="Keyword">module</a> <a id="ExL"></a><a id="1480" href="blog/generic-parallel-fp/index.html#1480" class="Module">ExL</a> <a id="1484" class="Keyword">where</a>
  <a id="1492" class="Keyword">data</a> <a id="ExL.LList"></a><a id="1497" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1503" class="Symbol">(</a><a id="1504" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1506" class="Symbol">:</a> <a id="1508" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="1511" class="Symbol">)</a> <a id="1513" class="Symbol">:</a> <a id="1515" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1519" class="Keyword">where</a>
    <a id="ExL.LList.LNil"></a><a id="1529" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1534" class="Symbol">:</a> <a id="1536" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1542" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a>
    <a id="ExL.LList._▷_"></a><a id="1548" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">_▷_</a> <a id="1552" class="Symbol">:</a> <a id="1554" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1560" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1562" class="Symbol">→</a> <a id="1564" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a> <a id="1566" class="Symbol">→</a> <a id="1568" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1574" href="blog/generic-parallel-fp/index.html#1504" class="Bound">A</a>

  <a id="1579" class="Keyword">infixl</a> <a id="1586" class="Number">5</a> <a id="1588" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">_▷_</a>

  <a id="ExL.scanL"></a><a id="1595" href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a> <a id="1601" class="Symbol">:</a> <a id="1603" class="Symbol">⦃</a> <a id="1605" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1612" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1614" class="Symbol">⦄</a> <a id="1616" class="Symbol">→</a> <a id="1618" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1624" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1626" class="Symbol">→</a> <a id="1628" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1634" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="1638" href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a> <a id="1644" class="Symbol">=</a> <a id="1646" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a> <a id="1652" href="Function.Base.html#1040" class="Function Operator">∘</a> <a id="1654" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a>
    <a id="1661" class="Keyword">where</a>
      <a id="1673" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1676" class="Symbol">:</a> <a id="1678" class="Symbol">⦃</a> <a id="1680" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="1687" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1689" class="Symbol">⦄</a> <a id="1691" class="Symbol">→</a> <a id="1693" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1699" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1701" class="Symbol">→</a> <a id="1703" href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a> <a id="1709" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="1711" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="1713" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
      <a id="1721" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1724" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1729" class="Symbol">=</a> <a id="1731" href="blog/generic-parallel-fp/index.html#1529" class="InductiveConstructor">LNil</a> <a id="1736" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1738" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
      <a id="1751" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1754" class="Symbol">(</a><a id="1755" href="blog/generic-parallel-fp/index.html#1755" class="Bound">xs</a> <a id="1758" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">▷</a> <a id="1760" href="blog/generic-parallel-fp/index.html#1760" class="Bound">x</a><a id="1761" class="Symbol">)</a> <a id="1763" class="Symbol">=</a>
        <a id="1773" class="Keyword">let</a> <a id="1777" href="blog/generic-parallel-fp/index.html#1777" class="Bound">xs&#39;</a> <a id="1781" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1783" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a> <a id="1787" class="Symbol">=</a> <a id="1789" href="blog/generic-parallel-fp/index.html#1673" class="Function">go</a> <a id="1792" href="blog/generic-parallel-fp/index.html#1755" class="Bound">xs</a>
         <a id="1804" class="Keyword">in</a> <a id="1807" href="blog/generic-parallel-fp/index.html#1777" class="Bound">xs&#39;</a> <a id="1811" href="blog/generic-parallel-fp/index.html#1548" class="InductiveConstructor Operator">▷</a> <a id="1813" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a> <a id="1817" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1819" href="blog/generic-parallel-fp/index.html#1760" class="Bound">x</a> <a id="1821" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="1824" href="blog/generic-parallel-fp/index.html#1783" class="Bound">acc</a>
</pre>
<p>While <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1595" class="Function">scanL</a></span> is also <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> in its runtime, it is not amenable to tail call optimization, and thus also requires <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> <em>space.</em> Egads!</p>
<p>You are probably not amazed to learn that different ways of structuring data lead to different runtime and space complexities. But it’s a more interesting puzzle than it sounds; because <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a></span> are isomorphic! So what gives?</p>
<p>Reed’s pithy description here is</p>
<blockquote>
<p>Computation time doesn’t respect isos</p>
</blockquote>
<p>Exploring that question with him has been very illuminating. Math is deeply about extentionality; two mathematical objects are equivalent if their abstract interfaces are indistinguishable. Computation… doesn’t have this property. When computing, we care a great deal about runtime performance, which depends on fiddly implementation details, even if those aren’t externally observable.</p>
<p>In fact, as he goes on to state, this is the whole idea of denotational design. Figure out the extensional behavior first, and then figure out how to implement it.</p>
<p>This all harkens back to my review of another of Elliott’s papers, <a href="/blog/adders-and-arrows">Adders and Arrows</a>, which starts from the extensional behavior of natural addition (encoded as the Peano naturals), and then derives a chain of proofs showing that our everyday binary adders preserve this behavior.</p>
<p>Anyway, let’s switch topics and consider a weird fact of the world. Why do so many parallel algorithms require gnarly array indexing? Here’s an example I found by googling for “parallel c algorithms cuda”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> stencil_1d<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>in<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  __shared__ <span class="dt">int</span> temp<span class="op">[</span>BLOCK_SIZE <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> RADIUS<span class="op">];</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> gindex <span class="op">=</span> threadIdx<span class="op">.</span>x <span class="op">+</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> lindex <span class="op">=</span> threadIdx<span class="op">.</span>x <span class="op">+</span> RADIUS<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  temp<span class="op">[</span>lindex<span class="op">]</span> <span class="op">=</span> in<span class="op">[</span>gindex<span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>threadIdx<span class="op">.</span>x <span class="op">&lt;</span> RADIUS<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    temp<span class="op">[</span>lindex <span class="op">-</span> RADIUS<span class="op">]</span> <span class="op">=</span> in<span class="op">[</span>gindex <span class="op">-</span> RADIUS<span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    temp<span class="op">[</span>lindex <span class="op">+</span> BLOCK_SIZE<span class="op">]</span> <span class="op">=</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    in<span class="op">[</span>gindex <span class="op">+</span> BLOCK_SIZE<span class="op">];</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  __syncthreads<span class="op">();</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> result <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> offset <span class="op">=</span> <span class="op">-</span>RADIUS <span class="op">;</span> offset <span class="op">&lt;=</span> RADIUS <span class="op">;</span> offset<span class="op">++)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    result <span class="op">+=</span> temp<span class="op">[</span>lindex <span class="op">+</span> offset<span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  out<span class="op">[</span>gindex<span class="op">]</span> <span class="op">=</span> result<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and here’s another, expressed as an “easy induction” recurrence relation, from <a href="http://personal.denison.edu/~bressoud/cs402-s11/Supplements/ParallelPrefix.pdf">Richard E Ladner and Michael J Fischer. Parallel prefix computation</a>:</p>
<center>
<img src="/images/generic-parallel-fp/indices.png">
</center>
<p>Sweet lord. No wonder we’re all stuck pretending our computer machines are single threaded behemoths from the 1960s. Taking full advantage of parallelism on modern CPUs must require a research team and five years!</p>
<p>But it’s worth taking a moment and thinking about what all of this janky indexing must be doing. Whatever algorithm is telling the programmer which indices to write where necessarily must be providing a view on the data. That is, the programmer has some sort of “shape” in mind for how the problem should be subdivided, and the indexing is an implementation of accessing the raw array elements in the desired shape.</p>
<p>At risk of beating you on the head with it, this array indexing is <em>a bad implementation of a type system.</em> Bad because it’s something the implementer needed to invent by hand, and is not in any form that the compiler can help ensure the correctness of.</p>
<p>That returns us to the big contribution of <em>Generic Function Parallel Algorithms,</em> which is a technique for decoupling the main thrust of an algorithm from extentionally-inconsequential encodings of things. The idea is to implement the algorithm on lots of trivial data structures, and then compose those small pieces together to get a <em>class</em> of algorithms.</p>
<h2 id="generic-representations"><a href="#generic-representations" class="header-link">Generic Representations<span class="header-link-emoji">🔗</span></a></h2>
<p>The first step is to determine which trivial data structures we need to support. Following the steps of Haskell’s <code>GHC.Generics</code> module, we can decompose any Haskell98 data type as compositions of the following pieces:</p>
<pre class="Agda"><a id="5738" class="Keyword">data</a> <a id="Rep"></a><a id="5743" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5747" class="Symbol">:</a> <a id="5749" href="Agda.Primitive.html#320" class="Primitive">Set₁</a> <a id="5754" class="Keyword">where</a>
  <a id="Rep.V"></a><a id="5762" href="blog/generic-parallel-fp/index.html#5762" class="InductiveConstructor">V</a> <a id="5764" class="Symbol">:</a> <a id="5766" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.U"></a><a id="5772" href="blog/generic-parallel-fp/index.html#5772" class="InductiveConstructor">U</a> <a id="5774" class="Symbol">:</a> <a id="5776" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.K"></a><a id="5782" href="blog/generic-parallel-fp/index.html#5782" class="InductiveConstructor">K</a> <a id="5784" class="Symbol">:</a> <a id="5786" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="5790" class="Symbol">→</a> <a id="5792" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.Par"></a><a id="5798" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="5802" class="Symbol">:</a> <a id="5804" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep.Rec"></a><a id="5810" href="blog/generic-parallel-fp/index.html#5810" class="InductiveConstructor">Rec</a> <a id="5814" class="Symbol">:</a> <a id="5816" class="Symbol">(</a><a id="5817" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="5821" class="Symbol">→</a> <a id="5823" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="5826" class="Symbol">)</a> <a id="5828" class="Symbol">→</a> <a id="5830" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:+:_"></a><a id="5836" href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">_:+:_</a> <a id="5842" class="Symbol">:</a> <a id="5844" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5848" class="Symbol">→</a> <a id="5850" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5854" class="Symbol">→</a> <a id="5856" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:*:_"></a><a id="5862" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">_:*:_</a> <a id="5868" class="Symbol">:</a> <a id="5870" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5874" class="Symbol">→</a> <a id="5876" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5880" class="Symbol">→</a> <a id="5882" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
  <a id="Rep._:∘:_"></a><a id="5888" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">_:∘:_</a> <a id="5894" class="Symbol">:</a> <a id="5896" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5900" class="Symbol">→</a> <a id="5902" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="5906" class="Symbol">→</a> <a id="5908" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
</pre>
<p>which we can embed in <span class="Agda"><a href="Agda.Primitive.html#320" class="Primitive">Set</a></span> via <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>:</p>
<pre class="Agda"><a id="5981" class="Keyword">open</a> <a id="5986" class="Keyword">import</a> <a id="5993" href="Data.Empty.html" class="Module">Data.Empty</a>
<a id="6004" class="Keyword">open</a> <a id="6009" class="Keyword">import</a> <a id="6016" href="Data.Sum.html" class="Module">Data.Sum</a>
<a id="6025" class="Keyword">open</a> <a id="6030" class="Keyword">import</a> <a id="6037" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="6047" class="Keyword">hiding</a> <a id="6054" class="Symbol">(</a><a id="6055" href="Data.Unit.Base.html#1032" class="Record Operator">_≤_</a><a id="6058" class="Symbol">)</a>

<a id="6061" class="Keyword">record</a> <a id="Compose"></a><a id="6068" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="6076" class="Symbol">(</a><a id="6077" href="blog/generic-parallel-fp/index.html#6077" class="Bound">F</a> <a id="6079" href="blog/generic-parallel-fp/index.html#6079" class="Bound">G</a> <a id="6081" class="Symbol">:</a> <a id="6083" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6087" class="Symbol">→</a> <a id="6089" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="6092" class="Symbol">)</a> <a id="6094" class="Symbol">(</a><a id="6095" href="blog/generic-parallel-fp/index.html#6095" class="Bound">A</a> <a id="6097" class="Symbol">:</a> <a id="6099" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="6102" class="Symbol">)</a> <a id="6104" class="Symbol">:</a> <a id="6106" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6110" class="Keyword">where</a>
  <a id="6118" class="Keyword">constructor</a> <a id="compose"></a><a id="6130" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a>
  <a id="6140" class="Keyword">field</a>
    <a id="Compose.composed"></a><a id="6150" href="blog/generic-parallel-fp/index.html#6150" class="Field">composed</a> <a id="6159" class="Symbol">:</a> <a id="6161" href="blog/generic-parallel-fp/index.html#6077" class="Bound">F</a> <a id="6163" class="Symbol">(</a><a id="6164" href="blog/generic-parallel-fp/index.html#6079" class="Bound">G</a> <a id="6166" href="blog/generic-parallel-fp/index.html#6095" class="Bound">A</a><a id="6167" class="Symbol">)</a>
<a id="6169" class="Keyword">open</a> <a id="6174" href="blog/generic-parallel-fp/index.html#6068" class="Module">Compose</a>

<a id="Represent"></a><a id="6183" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6193" class="Symbol">:</a> <a id="6195" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="6199" class="Symbol">→</a> <a id="6201" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6205" class="Symbol">→</a> <a id="6207" href="Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="6211" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6221" href="blog/generic-parallel-fp/index.html#5762" class="InductiveConstructor">V</a> <a id="6223" href="blog/generic-parallel-fp/index.html#6223" class="Bound">a</a>         <a id="6233" class="Symbol">=</a> <a id="6235" href="Data.Empty.html#535" class="Datatype">⊥</a>
<a id="6237" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6247" href="blog/generic-parallel-fp/index.html#5772" class="InductiveConstructor">U</a> <a id="6249" href="blog/generic-parallel-fp/index.html#6249" class="Bound">a</a>         <a id="6259" class="Symbol">=</a> <a id="6261" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="6263" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6273" class="Symbol">(</a><a id="6274" href="blog/generic-parallel-fp/index.html#5782" class="InductiveConstructor">K</a> <a id="6276" href="blog/generic-parallel-fp/index.html#6276" class="Bound">x</a><a id="6277" class="Symbol">)</a> <a id="6279" href="blog/generic-parallel-fp/index.html#6279" class="Bound">a</a>     <a id="6285" class="Symbol">=</a> <a id="6287" href="blog/generic-parallel-fp/index.html#6276" class="Bound">x</a>
<a id="6289" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6299" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="6303" href="blog/generic-parallel-fp/index.html#6303" class="Bound">a</a>       <a id="6311" class="Symbol">=</a> <a id="6313" href="blog/generic-parallel-fp/index.html#6303" class="Bound">a</a>
<a id="6315" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6325" class="Symbol">(</a><a id="6326" href="blog/generic-parallel-fp/index.html#5810" class="InductiveConstructor">Rec</a> <a id="6330" href="blog/generic-parallel-fp/index.html#6330" class="Bound">f</a><a id="6331" class="Symbol">)</a> <a id="6333" href="blog/generic-parallel-fp/index.html#6333" class="Bound">a</a>   <a id="6337" class="Symbol">=</a> <a id="6339" href="blog/generic-parallel-fp/index.html#6330" class="Bound">f</a> <a id="6341" href="blog/generic-parallel-fp/index.html#6333" class="Bound">a</a>
<a id="6343" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6353" class="Symbol">(</a><a id="6354" href="blog/generic-parallel-fp/index.html#6354" class="Bound">x</a> <a id="6356" href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">:+:</a> <a id="6360" href="blog/generic-parallel-fp/index.html#6360" class="Bound">y</a><a id="6361" class="Symbol">)</a> <a id="6363" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a> <a id="6365" class="Symbol">=</a> <a id="6367" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6377" href="blog/generic-parallel-fp/index.html#6354" class="Bound">x</a> <a id="6379" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a> <a id="6381" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="6383" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6393" href="blog/generic-parallel-fp/index.html#6360" class="Bound">y</a> <a id="6395" href="blog/generic-parallel-fp/index.html#6363" class="Bound">a</a>
<a id="6397" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6407" class="Symbol">(</a><a id="6408" href="blog/generic-parallel-fp/index.html#6408" class="Bound">x</a> <a id="6410" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="6414" href="blog/generic-parallel-fp/index.html#6414" class="Bound">y</a><a id="6415" class="Symbol">)</a> <a id="6417" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a> <a id="6419" class="Symbol">=</a> <a id="6421" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6431" href="blog/generic-parallel-fp/index.html#6408" class="Bound">x</a> <a id="6433" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a> <a id="6435" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="6437" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6447" href="blog/generic-parallel-fp/index.html#6414" class="Bound">y</a> <a id="6449" href="blog/generic-parallel-fp/index.html#6417" class="Bound">a</a>
<a id="6451" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6461" class="Symbol">(</a><a id="6462" href="blog/generic-parallel-fp/index.html#6462" class="Bound">x</a> <a id="6464" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="6468" href="blog/generic-parallel-fp/index.html#6468" class="Bound">y</a><a id="6469" class="Symbol">)</a> <a id="6471" href="blog/generic-parallel-fp/index.html#6471" class="Bound">a</a> <a id="6473" class="Symbol">=</a> <a id="6475" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="6483" class="Symbol">(</a><a id="6484" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6494" href="blog/generic-parallel-fp/index.html#6462" class="Bound">x</a><a id="6495" class="Symbol">)</a> <a id="6497" class="Symbol">(</a><a id="6498" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6508" href="blog/generic-parallel-fp/index.html#6468" class="Bound">y</a><a id="6509" class="Symbol">)</a> <a id="6511" href="blog/generic-parallel-fp/index.html#6471" class="Bound">a</a>
</pre>
<p>If you’ve ever worked with <code>GHC.Generics</code>, none of this should be very exciting. We can bundle everything together, plus an iso to transform to and from the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>ed type:</p>
<pre class="Agda"><a id="6707" class="Keyword">record</a> <a id="Generic"></a><a id="6714" href="blog/generic-parallel-fp/index.html#6714" class="Record">Generic</a> <a id="6722" class="Symbol">(</a><a id="6723" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6725" class="Symbol">:</a> <a id="6727" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6731" class="Symbol">→</a> <a id="6733" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="6736" class="Symbol">)</a> <a id="6738" class="Symbol">:</a> <a id="6740" href="Agda.Primitive.html#320" class="Primitive">Set₁</a> <a id="6745" class="Keyword">where</a>
  <a id="6753" class="Keyword">field</a>
    <a id="Generic.RepOf"></a><a id="6763" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6769" class="Symbol">:</a> <a id="6771" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
    <a id="Generic.from"></a><a id="6779" href="blog/generic-parallel-fp/index.html#6779" class="Field">from</a>  <a id="6785" class="Symbol">:</a> <a id="6787" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6789" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="6791" class="Symbol">→</a> <a id="6793" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6803" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6809" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
    <a id="Generic.to"></a><a id="6815" href="blog/generic-parallel-fp/index.html#6815" class="Field">to</a>    <a id="6821" class="Symbol">:</a> <a id="6823" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6833" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a> <a id="6839" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="6841" class="Symbol">→</a> <a id="6843" href="blog/generic-parallel-fp/index.html#6723" class="Bound">F</a> <a id="6845" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="6847" class="Keyword">open</a> <a id="6852" href="blog/generic-parallel-fp/index.html#6714" class="Module">Generic</a> <a id="6860" class="Symbol">⦃</a> <a id="6862" class="Symbol">...</a> <a id="6866" class="Symbol">⦄</a>

<a id="GenericRep"></a><a id="6869" href="blog/generic-parallel-fp/index.html#6869" class="Function">GenericRep</a> <a id="6880" class="Symbol">:</a> <a id="6882" class="Symbol">(</a><a id="6883" href="blog/generic-parallel-fp/index.html#6883" class="Bound">F</a> <a id="6885" class="Symbol">:</a> <a id="6887" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6891" class="Symbol">→</a> <a id="6893" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="6896" class="Symbol">)</a> <a id="6898" class="Symbol">→</a> <a id="6900" class="Symbol">⦃</a> <a id="6902" href="blog/generic-parallel-fp/index.html#6714" class="Record">Generic</a> <a id="6910" href="blog/generic-parallel-fp/index.html#6883" class="Bound">F</a> <a id="6912" class="Symbol">⦄</a> <a id="6914" class="Symbol">→</a> <a id="6916" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6920" class="Symbol">→</a> <a id="6922" href="Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="6926" href="blog/generic-parallel-fp/index.html#6869" class="Function">GenericRep</a> <a id="6937" class="Symbol">_</a> <a id="6939" class="Symbol">=</a> <a id="6941" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="6951" href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a>
</pre>
<p>Agda doesn’t have any out-of-the-box notion of <code>-XDeriveGeneric</code>, which seems like a headache at first blush. It means we need to explicitly write out a <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6779" class="Field">from</a></span>/<span class="Agda"><a href="blog/generic-parallel-fp/index.html#6815" class="Field">to</a></span> pairs by hand, <em>like peasants.</em> Surprisingly however, needing to implement by hand is beneficial, as it reminds us that <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> <em>is not uniquely determined!</em></p>
<p>A good metaphor here is the number 16, which stands for some type we’d like to generify. A <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6763" class="Field">RepOf</a></span> for 16 is an equivalent representation for 16. Here are a few:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2+(2+(2+(2+(2+(2+(2+2))))))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">))))))</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((2+2)*2)+(((2+2)+2)+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">((</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(((</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2 \times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">8 \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo>×</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(4 \times 2) \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo stretchy="false">)</mo><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">(2 \times 4) \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4 \times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><msup><mn>2</mn><mn>2</mn></msup></msup></mrow><annotation encoding="application/x-tex">2^{2^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>And there are lots more! Each of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> and exponentiation corresponds to a different way of building a type, so every one of these expressions is a distinct (if isomorphic) type with 16 values. Every single possible factoring of 16 corresponds to a different way of dividing-and-conquering, which is to say, a different (but related) algorithm.</p>
<p>The trick is to define our algorithm inductively over each <span class="Agda"><a href="Agda.Primitive.html#320" class="Primitive">Set</a></span> that can result from <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>. We can then pick different algorithms from the class by changing the specific way of factoring our type.</p>
<h2 id="left-scans"><a href="#left-scans" class="header-link">Left Scans<span class="header-link-emoji">🔗</span></a></h2>
<p>Let’s consider the case of left scans. I happen to know it’s going to require <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a></span> capabilities, so we’ll also define that:</p>
<pre class="Agda"><a id="8404" class="Keyword">record</a> <a id="Functor"></a><a id="8411" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="8419" class="Symbol">(</a><a id="8420" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8422" class="Symbol">:</a> <a id="8424" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="8428" href="blog/generic-parallel-fp/index.html#286" class="Generalizable">𝓁</a> <a id="8430" class="Symbol">→</a> <a id="8432" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="8436" href="blog/generic-parallel-fp/index.html#286" class="Generalizable">𝓁</a><a id="8437" class="Symbol">)</a> <a id="8439" class="Symbol">:</a> <a id="8441" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="8445" class="Symbol">(</a><a id="8446" href="Agda.Primitive.html#774" class="Primitive">lsuc</a> <a id="8451" href="blog/generic-parallel-fp/index.html#8428" class="Bound">𝓁</a><a id="8452" class="Symbol">)</a> <a id="8454" class="Keyword">where</a>
  <a id="8462" class="Keyword">field</a>
    <a id="Functor.fmap"></a><a id="8472" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="8477" class="Symbol">:</a> <a id="8479" class="Symbol">{</a><a id="8480" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8482" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a> <a id="8484" class="Symbol">:</a> <a id="8486" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="8490" href="blog/generic-parallel-fp/index.html#8428" class="Bound">𝓁</a><a id="8491" class="Symbol">}</a> <a id="8493" class="Symbol">→</a> <a id="8495" class="Symbol">(</a><a id="8496" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8498" class="Symbol">→</a> <a id="8500" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a><a id="8501" class="Symbol">)</a> <a id="8503" class="Symbol">→</a> <a id="8505" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8507" href="blog/generic-parallel-fp/index.html#8480" class="Bound">A</a> <a id="8509" class="Symbol">→</a> <a id="8511" href="blog/generic-parallel-fp/index.html#8420" class="Bound">F</a> <a id="8513" href="blog/generic-parallel-fp/index.html#8482" class="Bound">B</a>

<a id="8516" class="Keyword">record</a> <a id="LScan"></a><a id="8523" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="8529" class="Symbol">(</a><a id="8530" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8532" class="Symbol">:</a> <a id="8534" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="8538" class="Symbol">→</a> <a id="8540" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="8543" class="Symbol">)</a> <a id="8545" class="Symbol">:</a> <a id="8547" href="Agda.Primitive.html#320" class="Primitive">Set₁</a> <a id="8552" class="Keyword">where</a>
  <a id="8560" class="Keyword">field</a>
    <a id="8570" class="Keyword">overlap</a> <a id="8578" class="Symbol">⦃</a> <a id="LScan.func"></a><a id="8580" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="8585" class="Symbol">⦄</a> <a id="8587" class="Symbol">:</a> <a id="8589" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="8597" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a>
    <a id="LScan.lscan"></a><a id="8603" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="8609" class="Symbol">:</a> <a id="8611" class="Symbol">⦃</a> <a id="8613" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="8620" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8622" class="Symbol">⦄</a> <a id="8624" class="Symbol">→</a> <a id="8626" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8628" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8630" class="Symbol">→</a> <a id="8632" href="blog/generic-parallel-fp/index.html#8530" class="Bound">F</a> <a id="8634" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="8636" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="8638" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>

<a id="8641" class="Keyword">open</a> <a id="8646" href="blog/generic-parallel-fp/index.html#8411" class="Module">Functor</a> <a id="8654" class="Symbol">⦃</a>  <a id="8657" class="Symbol">...</a>  <a id="8662" class="Symbol">⦄</a>
<a id="8664" class="Keyword">open</a> <a id="8669" href="blog/generic-parallel-fp/index.html#8523" class="Module">LScan</a> <a id="8675" class="Symbol">⦃</a> <a id="8677" class="Symbol">...</a> <a id="8681" class="Symbol">⦄</a>
</pre>
<p>What’s with the type of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span>? This thing is an exclusive scan, so the first element is always <span class="Agda"><a href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a></span>, and thus the last elemenet is always returned as <span class="Agda"><a href="Agda.Builtin.Sigma.html#246" class="Field">proj₂</a></span> of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span>.</p>
<p>We need to implement <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> for each <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span>ation, and because there is no global coherence requirement in Agda, we can define our <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a></span> instances at the same time.</p>
<p>The simplest case is void which we can scan because we have a <span class="Agda"><a href="Data.Empty.html#535" class="Datatype">⊥</a></span> in negative position:</p>
<pre class="Agda"><a id="9189" class="Keyword">instance</a>
  <a id="lV"></a><a id="9200" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9203" class="Symbol">:</a> <a id="9205" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9211" class="Symbol">(\</a><a id="9213" href="blog/generic-parallel-fp/index.html#9213" class="Bound">a</a> <a id="9215" class="Symbol">→</a> <a id="9217" href="Data.Empty.html#535" class="Datatype">⊥</a><a id="9218" class="Symbol">)</a>
  <a id="9222" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9225" class="Symbol">.</a><a id="9226" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9231" class="Symbol">.</a><a id="9232" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9237" href="blog/generic-parallel-fp/index.html#9237" class="Bound">f</a> <a id="9239" href="blog/generic-parallel-fp/index.html#9239" class="Bound">x</a> <a id="9241" class="Symbol">=</a> <a id="9243" href="Data.Empty.html#637" class="Function">⊥-elim</a> <a id="9250" href="blog/generic-parallel-fp/index.html#9239" class="Bound">x</a>
  <a id="9254" href="blog/generic-parallel-fp/index.html#9200" class="Function">lV</a> <a id="9257" class="Symbol">.</a><a id="9258" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9264" class="Symbol">()</a>
</pre>
<p><span class="Agda"><a href="Agda.Builtin.Unit.html#158" class="Record">⊤</a></span> is also trivial. Notice that there isn’t any <code>a</code> inside of it, so our final accumulated value must be <span class="Agda"><a href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a></span>:</p>
<pre class="Agda">  <a id="lU"></a><a id="9409" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9412" class="Symbol">:</a> <a id="9414" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9420" class="Symbol">(\</a><a id="9422" href="blog/generic-parallel-fp/index.html#9422" class="Bound">a</a> <a id="9424" class="Symbol">→</a> <a id="9426" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="9427" class="Symbol">)</a>
  <a id="9431" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9434" class="Symbol">.</a><a id="9435" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9440" class="Symbol">.</a><a id="9441" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9446" href="blog/generic-parallel-fp/index.html#9446" class="Bound">f</a> <a id="9448" href="blog/generic-parallel-fp/index.html#9448" class="Bound">x</a> <a id="9450" class="Symbol">=</a> <a id="9452" href="blog/generic-parallel-fp/index.html#9448" class="Bound">x</a>
  <a id="9456" href="blog/generic-parallel-fp/index.html#9409" class="Function">lU</a> <a id="9459" class="Symbol">.</a><a id="9460" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9466" href="blog/generic-parallel-fp/index.html#9466" class="Bound">x</a> <a id="9468" class="Symbol">=</a> <a id="9470" href="blog/generic-parallel-fp/index.html#9466" class="Bound">x</a> <a id="9472" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9474" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a>
</pre>
<p>The identity functor is also trivial. Except this time, we <em>do</em> have a result, so it becomes the accumulated value, and we replace it with how much we’ve scaned thus far (nothing):</p>
<pre class="Agda">  <a id="lP"></a><a id="9674" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9677" class="Symbol">:</a> <a id="9679" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9685" class="Symbol">(\</a><a id="9687" href="blog/generic-parallel-fp/index.html#9687" class="Bound">a</a> <a id="9689" class="Symbol">→</a> <a id="9691" href="blog/generic-parallel-fp/index.html#9687" class="Bound">a</a><a id="9692" class="Symbol">)</a>
  <a id="9696" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9699" class="Symbol">.</a><a id="9700" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9705" class="Symbol">.</a><a id="9706" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9711" href="blog/generic-parallel-fp/index.html#9711" class="Bound">f</a> <a id="9713" class="Symbol">=</a> <a id="9715" href="blog/generic-parallel-fp/index.html#9711" class="Bound">f</a>
  <a id="9719" href="blog/generic-parallel-fp/index.html#9674" class="Function">lP</a> <a id="9722" class="Symbol">.</a><a id="9723" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9729" href="blog/generic-parallel-fp/index.html#9729" class="Bound">x</a> <a id="9731" class="Symbol">=</a> <a id="9733" href="blog/generic-parallel-fp/index.html#361" class="Field">mempty</a> <a id="9740" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9742" href="blog/generic-parallel-fp/index.html#9729" class="Bound">x</a>
</pre>
<p>Coproducts are uninteresting; we merely lift the tag:</p>
<pre class="Agda">  <a id="l+"></a><a id="9810" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9813" class="Symbol">:</a> <a id="9815" class="Symbol">⦃</a> <a id="9817" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9823" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="9825" class="Symbol">⦄</a> <a id="9827" class="Symbol">→</a> <a id="9829" class="Symbol">⦃</a> <a id="9831" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9837" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="9839" class="Symbol">⦄</a> <a id="9841" class="Symbol">→</a> <a id="9843" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="9849" class="Symbol">(\</a><a id="9851" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a> <a id="9853" class="Symbol">→</a> <a id="9855" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="9857" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a> <a id="9859" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="9861" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="9863" href="blog/generic-parallel-fp/index.html#9851" class="Bound">a</a><a id="9864" class="Symbol">)</a>
  <a id="9868" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9871" class="Symbol">.</a><a id="9872" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9877" class="Symbol">.</a><a id="9878" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9883" href="blog/generic-parallel-fp/index.html#9883" class="Bound">f</a> <a id="9885" class="Symbol">(</a><a id="9886" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="9891" href="blog/generic-parallel-fp/index.html#9891" class="Bound">y</a><a id="9892" class="Symbol">)</a> <a id="9894" class="Symbol">=</a> <a id="9896" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="9901" class="Symbol">(</a><a id="9902" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9907" href="blog/generic-parallel-fp/index.html#9883" class="Bound">f</a> <a id="9909" href="blog/generic-parallel-fp/index.html#9891" class="Bound">y</a><a id="9910" class="Symbol">)</a>
  <a id="9914" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9917" class="Symbol">.</a><a id="9918" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="9923" class="Symbol">.</a><a id="9924" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9929" href="blog/generic-parallel-fp/index.html#9929" class="Bound">f</a> <a id="9931" class="Symbol">(</a><a id="9932" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="9937" href="blog/generic-parallel-fp/index.html#9937" class="Bound">y</a><a id="9938" class="Symbol">)</a> <a id="9940" class="Symbol">=</a> <a id="9942" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="9947" class="Symbol">(</a><a id="9948" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="9953" href="blog/generic-parallel-fp/index.html#9929" class="Bound">f</a> <a id="9955" href="blog/generic-parallel-fp/index.html#9937" class="Bound">y</a><a id="9956" class="Symbol">)</a>
  <a id="9960" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="9963" class="Symbol">.</a><a id="9964" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="9970" class="Symbol">(</a><a id="9971" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="9976" href="blog/generic-parallel-fp/index.html#9976" class="Bound">x</a><a id="9977" class="Symbol">)</a> <a id="9979" class="Symbol">=</a>
    <a id="9985" class="Keyword">let</a> <a id="9989" href="blog/generic-parallel-fp/index.html#9989" class="Bound">x&#39;</a> <a id="9992" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9994" href="blog/generic-parallel-fp/index.html#9994" class="Bound">y</a> <a id="9996" class="Symbol">=</a> <a id="9998" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10004" href="blog/generic-parallel-fp/index.html#9976" class="Bound">x</a>
     <a id="10011" class="Keyword">in</a> <a id="10014" href="Data.Sum.Base.html#793" class="InductiveConstructor">inj₁</a> <a id="10019" href="blog/generic-parallel-fp/index.html#9989" class="Bound">x&#39;</a> <a id="10022" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10024" href="blog/generic-parallel-fp/index.html#9994" class="Bound">y</a>
  <a id="10028" href="blog/generic-parallel-fp/index.html#9810" class="Function">l+</a> <a id="10031" class="Symbol">.</a><a id="10032" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10038" class="Symbol">(</a><a id="10039" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="10044" href="blog/generic-parallel-fp/index.html#10044" class="Bound">x</a><a id="10045" class="Symbol">)</a> <a id="10047" class="Symbol">=</a>
    <a id="10053" class="Keyword">let</a> <a id="10057" href="blog/generic-parallel-fp/index.html#10057" class="Bound">x&#39;</a> <a id="10060" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10062" href="blog/generic-parallel-fp/index.html#10062" class="Bound">y</a> <a id="10064" class="Symbol">=</a> <a id="10066" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10072" href="blog/generic-parallel-fp/index.html#10044" class="Bound">x</a>
     <a id="10079" class="Keyword">in</a> <a id="10082" href="Data.Sum.Base.html#818" class="InductiveConstructor">inj₂</a> <a id="10087" href="blog/generic-parallel-fp/index.html#10057" class="Bound">x&#39;</a> <a id="10090" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10092" href="blog/generic-parallel-fp/index.html#10062" class="Bound">y</a>
</pre>
<p>And then we come to the interesting cases. To scan the product of <code>F</code> and <code>G</code>, we notice that every left scan of <code>F</code> is a prefix of <code>F × G</code> (because <code>F</code> is on the left.) Thus, we can use <code>lscan F</code> directly in the result, and need only adjust the results of <code>lscan G</code> with the accumulated value from <code>F</code>:</p>
<pre class="Agda">  <a id="l*"></a><a id="10410" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10413" class="Symbol">:</a> <a id="10415" class="Symbol">⦃</a> <a id="10417" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10423" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="10425" class="Symbol">⦄</a> <a id="10427" class="Symbol">→</a> <a id="10429" class="Symbol">⦃</a> <a id="10431" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10437" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="10439" class="Symbol">⦄</a> <a id="10441" class="Symbol">→</a> <a id="10443" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="10449" class="Symbol">(\</a><a id="10451" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a> <a id="10453" class="Symbol">→</a> <a id="10455" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="10457" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a> <a id="10459" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="10461" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="10463" href="blog/generic-parallel-fp/index.html#10451" class="Bound">a</a><a id="10464" class="Symbol">)</a>
  <a id="10468" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10471" class="Symbol">.</a><a id="10472" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="10477" class="Symbol">.</a><a id="10478" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10483" href="blog/generic-parallel-fp/index.html#10483" class="Bound">f</a> <a id="10485" href="blog/generic-parallel-fp/index.html#10485" class="Bound">x</a> <a id="10487" class="Symbol">.</a><a id="10488" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a> <a id="10494" class="Symbol">=</a> <a id="10496" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10501" href="blog/generic-parallel-fp/index.html#10483" class="Bound">f</a> <a id="10503" class="Symbol">(</a><a id="10504" href="blog/generic-parallel-fp/index.html#10485" class="Bound">x</a> <a id="10506" class="Symbol">.</a><a id="10507" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a><a id="10512" class="Symbol">)</a>
  <a id="10516" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10519" class="Symbol">.</a><a id="10520" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="10525" class="Symbol">.</a><a id="10526" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10531" href="blog/generic-parallel-fp/index.html#10531" class="Bound">f</a> <a id="10533" href="blog/generic-parallel-fp/index.html#10533" class="Bound">x</a> <a id="10535" class="Symbol">.</a><a id="10536" href="Agda.Builtin.Sigma.html#246" class="Field">proj₂</a> <a id="10542" class="Symbol">=</a> <a id="10544" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10549" href="blog/generic-parallel-fp/index.html#10531" class="Bound">f</a> <a id="10551" class="Symbol">(</a><a id="10552" href="blog/generic-parallel-fp/index.html#10533" class="Bound">x</a> <a id="10554" class="Symbol">.</a><a id="10555" href="Agda.Builtin.Sigma.html#246" class="Field">proj₂</a><a id="10560" class="Symbol">)</a>
  <a id="10564" href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a> <a id="10567" class="Symbol">.</a><a id="10568" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10574" class="Symbol">(</a><a id="10575" href="blog/generic-parallel-fp/index.html#10575" class="Bound">f-in</a> <a id="10580" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10582" href="blog/generic-parallel-fp/index.html#10582" class="Bound">g-in</a><a id="10586" class="Symbol">)</a> <a id="10588" class="Symbol">=</a>
    <a id="10594" class="Keyword">let</a> <a id="10598" href="blog/generic-parallel-fp/index.html#10598" class="Bound">f-out</a> <a id="10604" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10606" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10612" class="Symbol">=</a> <a id="10614" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10620" href="blog/generic-parallel-fp/index.html#10575" class="Bound">f-in</a>
        <a id="10633" href="blog/generic-parallel-fp/index.html#10633" class="Bound">g-out</a> <a id="10639" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10641" href="blog/generic-parallel-fp/index.html#10641" class="Bound">g-acc</a> <a id="10647" class="Symbol">=</a> <a id="10649" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="10655" href="blog/generic-parallel-fp/index.html#10582" class="Bound">g-in</a>
     <a id="10665" class="Keyword">in</a> <a id="10668" class="Symbol">(</a><a id="10669" href="blog/generic-parallel-fp/index.html#10598" class="Bound">f-out</a> <a id="10675" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10677" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="10682" class="Symbol">(</a><a id="10683" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10689" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;_</a><a id="10692" class="Symbol">)</a> <a id="10694" href="blog/generic-parallel-fp/index.html#10633" class="Bound">g-out</a><a id="10699" class="Symbol">)</a> <a id="10701" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10703" href="blog/generic-parallel-fp/index.html#10606" class="Bound">f-acc</a> <a id="10709" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;</a> <a id="10712" href="blog/generic-parallel-fp/index.html#10641" class="Bound">g-acc</a>
</pre>
<p><span class="Agda"><a href="blog/generic-parallel-fp/index.html#10410" class="Function">l*</a></span> is what makes the whole algorithm parallel. It says we can scan <code>F</code> and <code>G</code> in parallel, and need only a single join node at the end to stick <code>f-acc &lt;&gt;_</code> on at the end. This parallelism is visible in the <code>let</code> expression, where there is no data dependency between the two bindings.</p>
<p>Our final generic instance of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> is over composition. Howevef, we can’t implement <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> for every composition of functors, since we require the ability to “zip” two functors together. The paper is pretty cagey about exactly what <code>Zip</code> is, but after some sleuthing, I think it’s this:</p>
<pre class="Agda"><a id="11328" class="Keyword">record</a> <a id="Zip"></a><a id="11335" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="11339" class="Symbol">(</a><a id="11340" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11342" class="Symbol">:</a> <a id="11344" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="11348" class="Symbol">→</a> <a id="11350" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="11353" class="Symbol">)</a> <a id="11355" class="Symbol">:</a> <a id="11357" href="Agda.Primitive.html#320" class="Primitive">Set₁</a> <a id="11362" class="Keyword">where</a>
  <a id="11370" class="Keyword">field</a>
    <a id="11380" class="Keyword">overlap</a> <a id="11388" class="Symbol">⦃</a> <a id="Zip.func"></a><a id="11390" href="blog/generic-parallel-fp/index.html#11390" class="Field">func</a> <a id="11395" class="Symbol">⦄</a> <a id="11397" class="Symbol">:</a> <a id="11399" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="11407" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a>
    <a id="Zip.zip"></a><a id="11413" href="blog/generic-parallel-fp/index.html#11413" class="Field">zip</a> <a id="11417" class="Symbol">:</a> <a id="11419" class="Symbol">{</a><a id="11420" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11422" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a> <a id="11424" class="Symbol">:</a> <a id="11426" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="11429" class="Symbol">}</a> <a id="11431" class="Symbol">→</a> <a id="11433" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11435" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11437" class="Symbol">→</a> <a id="11439" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11441" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a> <a id="11443" class="Symbol">→</a> <a id="11445" href="blog/generic-parallel-fp/index.html#11340" class="Bound">F</a> <a id="11447" class="Symbol">(</a><a id="11448" href="blog/generic-parallel-fp/index.html#11420" class="Bound">A</a> <a id="11450" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="11452" href="blog/generic-parallel-fp/index.html#11422" class="Bound">B</a><a id="11453" class="Symbol">)</a>
<a id="11455" class="Keyword">open</a> <a id="11460" href="blog/generic-parallel-fp/index.html#11335" class="Module">Zip</a> <a id="11464" class="Symbol">⦃</a> <a id="11466" class="Symbol">...</a> <a id="11470" class="Symbol">⦄</a>
</pre>
<p>That looks a lot like being an applicative, but it’s missing <code>pure</code> and has some weird idempotent laws that are not particularly relevant today. We can define some helper functions as well:</p>
<pre class="Agda"><a id="zipWith"></a><a id="11674" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="11682" class="Symbol">:</a> <a id="11684" class="Symbol">∀</a> <a id="11686" class="Symbol">{</a><a id="11687" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11689" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11691" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a><a id="11692" class="Symbol">}</a> <a id="11694" class="Symbol">→</a> <a id="11696" class="Symbol">⦃</a> <a id="11698" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="11702" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11704" class="Symbol">⦄</a> <a id="11706" class="Symbol">→</a> <a id="11708" class="Symbol">(</a><a id="11709" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11711" class="Symbol">→</a> <a id="11713" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11715" class="Symbol">→</a> <a id="11717" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a><a id="11718" class="Symbol">)</a> <a id="11720" class="Symbol">→</a> <a id="11722" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11724" href="blog/generic-parallel-fp/index.html#11687" class="Bound">A</a> <a id="11726" class="Symbol">→</a> <a id="11728" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11730" href="blog/generic-parallel-fp/index.html#11689" class="Bound">B</a> <a id="11732" class="Symbol">→</a> <a id="11734" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11736" href="blog/generic-parallel-fp/index.html#11691" class="Bound">C</a>
<a id="11738" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="11746" href="blog/generic-parallel-fp/index.html#11746" class="Bound">f</a> <a id="11748" href="blog/generic-parallel-fp/index.html#11748" class="Bound">fa</a> <a id="11751" href="blog/generic-parallel-fp/index.html#11751" class="Bound">fb</a> <a id="11754" class="Symbol">=</a> <a id="11756" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11761" class="Symbol">(</a><a id="11762" href="Data.Product.html#3431" class="Function">uncurry</a> <a id="11770" href="blog/generic-parallel-fp/index.html#11746" class="Bound">f</a><a id="11771" class="Symbol">)</a> <a id="11773" class="Symbol">(</a><a id="11774" href="blog/generic-parallel-fp/index.html#11413" class="Field">zip</a> <a id="11778" href="blog/generic-parallel-fp/index.html#11748" class="Bound">fa</a> <a id="11781" href="blog/generic-parallel-fp/index.html#11751" class="Bound">fb</a><a id="11783" class="Symbol">)</a>

<a id="unzip"></a><a id="11786" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="11792" class="Symbol">:</a> <a id="11794" class="Symbol">⦃</a> <a id="11796" href="blog/generic-parallel-fp/index.html#8411" class="Record">Functor</a> <a id="11804" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11806" class="Symbol">⦄</a> <a id="11808" class="Symbol">→</a> <a id="11810" class="Symbol">{</a><a id="11811" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11813" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a> <a id="11815" class="Symbol">:</a> <a id="11817" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="11820" class="Symbol">}</a> <a id="11822" class="Symbol">→</a> <a id="11824" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11826" class="Symbol">(</a><a id="11827" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11829" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="11831" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a><a id="11832" class="Symbol">)</a> <a id="11834" class="Symbol">→</a> <a id="11836" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11838" href="blog/generic-parallel-fp/index.html#11811" class="Bound">A</a> <a id="11840" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="11842" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="11844" href="blog/generic-parallel-fp/index.html#11813" class="Bound">B</a>
<a id="11846" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="11852" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a> <a id="11854" class="Symbol">=</a> <a id="11856" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11861" href="Agda.Builtin.Sigma.html#234" class="Field">proj₁</a> <a id="11867" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a> <a id="11869" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="11871" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="11876" href="Agda.Builtin.Sigma.html#246" class="Field">proj₂</a> <a id="11882" href="blog/generic-parallel-fp/index.html#11852" class="Bound">x</a>
</pre>
<p>Armed with all of this, we can give an implementation of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span> over functor composition. The idea is to <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a></span> each inner functor, which gives us an <code>G (F A × A)</code>. We can then <span class="Agda"><a href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a></span> that, whose second projection is then the totals of each inner scan. If we scan these <em>totals</em>, we’ll get a running scan for the whole thing; and all that’s left is to adjust each.</p>
<!--
<pre class="Agda"><a id="12288" class="Keyword">instance</a>
  <a id="composeFunc"></a><a id="12299" href="blog.generic-parallel-fp.html#12299" class="Function">composeFunc</a> <a id="12311" class="Symbol">:</a> <a id="12313" class="Symbol">⦃</a> <a id="12315" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12323" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12325" class="Symbol">⦄</a> <a id="12327" class="Symbol">→</a> <a id="12329" class="Symbol">⦃</a> <a id="12331" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12339" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12341" class="Symbol">⦄</a> <a id="12343" class="Symbol">→</a> <a id="12345" href="blog.generic-parallel-fp.html#8411" class="Record">Functor</a> <a id="12353" class="Symbol">(</a><a id="12354" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="12362" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12364" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="12365" class="Symbol">)</a>
  <a id="12369" href="blog.generic-parallel-fp.html#12299" class="Function">composeFunc</a> <a id="12381" class="Symbol">.</a><a id="12382" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12387" href="blog.generic-parallel-fp.html#12387" class="Bound">f</a> <a id="12389" class="Symbol">(</a><a id="12390" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="12398" href="blog.generic-parallel-fp.html#12398" class="Bound">x</a><a id="12399" class="Symbol">)</a> <a id="12401" class="Symbol">.</a><a id="12402" href="blog.generic-parallel-fp.html#6150" class="Field">composed</a> <a id="12411" class="Symbol">=</a> <a id="12413" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12418" class="Symbol">(</a><a id="12419" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12424" href="blog.generic-parallel-fp.html#12387" class="Bound">f</a><a id="12425" class="Symbol">)</a> <a id="12427" href="blog.generic-parallel-fp.html#12398" class="Bound">x</a>
</pre>-->
<pre class="Agda"><a id="12442" class="Keyword">instance</a>
  <a id="l∘"></a><a id="12453" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12456" class="Symbol">:</a> <a id="12458" class="Symbol">⦃</a> <a id="12460" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12466" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a> <a id="12468" class="Symbol">⦄</a> <a id="12470" class="Symbol">→</a> <a id="12472" class="Symbol">⦃</a> <a id="12474" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12480" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12482" class="Symbol">⦄</a> <a id="12484" class="Symbol">→</a> <a id="12486" class="Symbol">⦃</a> <a id="12488" href="blog/generic-parallel-fp/index.html#11335" class="Record">Zip</a> <a id="12492" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12494" class="Symbol">⦄</a> <a id="12496" class="Symbol">→</a> <a id="12498" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="12504" class="Symbol">(</a><a id="12505" href="blog/generic-parallel-fp/index.html#6068" class="Record">Compose</a> <a id="12513" href="blog/generic-parallel-fp/index.html#268" class="Generalizable">G</a> <a id="12515" href="blog/generic-parallel-fp/index.html#266" class="Generalizable">F</a><a id="12516" class="Symbol">)</a>
  <a id="12520" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12523" class="Symbol">.</a><a id="12524" href="blog/generic-parallel-fp/index.html#8580" class="Field">func</a> <a id="12529" class="Symbol">.</a><a id="12530" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12535" href="blog/generic-parallel-fp/index.html#12535" class="Bound">f</a> <a id="12537" class="Symbol">=</a> <a id="12539" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12544" href="blog/generic-parallel-fp/index.html#12535" class="Bound">f</a>
  <a id="12548" href="blog/generic-parallel-fp/index.html#12453" class="Function">l∘</a> <a id="12551" class="Symbol">.</a><a id="12552" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12558" class="Symbol">(</a><a id="12559" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a> <a id="12567" href="blog/generic-parallel-fp/index.html#12567" class="Bound">gfa</a><a id="12570" class="Symbol">)</a> <a id="12572" class="Symbol">=</a>
    <a id="12578" class="Keyword">let</a> <a id="12582" href="blog/generic-parallel-fp/index.html#12582" class="Bound">gfa&#39;</a> <a id="12587" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12589" href="blog/generic-parallel-fp/index.html#12589" class="Bound">tots</a> <a id="12594" class="Symbol">=</a> <a id="12596" href="blog/generic-parallel-fp/index.html#11786" class="Function">unzip</a> <a id="12602" class="Symbol">(</a><a id="12603" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12608" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12614" href="blog/generic-parallel-fp/index.html#12567" class="Bound">gfa</a><a id="12617" class="Symbol">)</a>
        <a id="12627" href="blog/generic-parallel-fp/index.html#12627" class="Bound">tots&#39;</a> <a id="12633" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12635" href="blog/generic-parallel-fp/index.html#12635" class="Bound">tot</a> <a id="12639" class="Symbol">=</a> <a id="12641" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="12647" href="blog/generic-parallel-fp/index.html#12589" class="Bound">tots</a>
        <a id="12660" href="blog/generic-parallel-fp/index.html#12660" class="Bound">adjustl</a> <a id="12668" href="blog/generic-parallel-fp/index.html#12668" class="Bound">t</a> <a id="12670" class="Symbol">=</a> <a id="12672" href="blog/generic-parallel-fp/index.html#8472" class="Field">fmap</a> <a id="12677" class="Symbol">(</a><a id="12678" href="blog/generic-parallel-fp/index.html#12668" class="Bound">t</a> <a id="12680" href="blog/generic-parallel-fp/index.html#376" class="Field Operator">&lt;&gt;_</a><a id="12683" class="Symbol">)</a>
    <a id="12689" class="Keyword">in</a> <a id="12692" href="blog/generic-parallel-fp/index.html#6130" class="InductiveConstructor">compose</a> <a id="12700" class="Symbol">(</a><a id="12701" href="blog/generic-parallel-fp/index.html#11674" class="Function">zipWith</a> <a id="12709" href="blog/generic-parallel-fp/index.html#12660" class="Bound">adjustl</a> <a id="12717" href="blog/generic-parallel-fp/index.html#12627" class="Bound">tots&#39;</a> <a id="12723" href="blog/generic-parallel-fp/index.html#12582" class="Bound">gfa&#39;</a><a id="12727" class="Symbol">)</a> <a id="12729" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12731" href="blog/generic-parallel-fp/index.html#12635" class="Bound">tot</a>
</pre>
<!--
<pre class="Agda"><a id="12749" class="Keyword">instance</a>
  <a id="zI"></a><a id="12760" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12763" class="Symbol">:</a> <a id="12765" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12769" class="Symbol">(\</a><a id="12771" href="blog.generic-parallel-fp.html#12771" class="Bound">a</a> <a id="12773" class="Symbol">→</a> <a id="12775" href="blog.generic-parallel-fp.html#12771" class="Bound">a</a><a id="12776" class="Symbol">)</a>
  <a id="12780" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12783" class="Symbol">.</a><a id="12784" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="12789" class="Symbol">.</a><a id="12790" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12795" href="blog.generic-parallel-fp.html#12795" class="Bound">f</a> <a id="12797" href="blog.generic-parallel-fp.html#12797" class="Bound">a</a> <a id="12799" class="Symbol">=</a> <a id="12801" href="blog.generic-parallel-fp.html#12795" class="Bound">f</a> <a id="12803" href="blog.generic-parallel-fp.html#12797" class="Bound">a</a>
  <a id="12807" href="blog.generic-parallel-fp.html#12760" class="Function">zI</a> <a id="12810" class="Symbol">.</a><a id="12811" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12815" href="blog.generic-parallel-fp.html#12815" class="Bound">a</a> <a id="12817" href="blog.generic-parallel-fp.html#12817" class="Bound">b</a> <a id="12819" class="Symbol">=</a> <a id="12821" href="blog.generic-parallel-fp.html#12815" class="Bound">a</a> <a id="12823" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12825" href="blog.generic-parallel-fp.html#12817" class="Bound">b</a>

  <a id="z*"></a><a id="12830" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12833" class="Symbol">:</a> <a id="12835" class="Symbol">⦃</a> <a id="12837" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12841" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12843" class="Symbol">⦄</a> <a id="12845" class="Symbol">→</a> <a id="12847" class="Symbol">⦃</a> <a id="12849" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12853" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12855" class="Symbol">⦄</a> <a id="12857" class="Symbol">→</a> <a id="12859" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12863" class="Symbol">(\</a><a id="12865" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a> <a id="12867" class="Symbol">→</a> <a id="12869" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12871" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a> <a id="12873" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="12875" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="12877" href="blog.generic-parallel-fp.html#12865" class="Bound">a</a><a id="12878" class="Symbol">)</a>
  <a id="12882" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12885" class="Symbol">.</a><a id="12886" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="12891" class="Symbol">.</a><a id="12892" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12897" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12899" class="Symbol">(</a><a id="12900" href="blog.generic-parallel-fp.html#12900" class="Bound">x</a> <a id="12902" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12904" href="blog.generic-parallel-fp.html#12904" class="Bound">y</a><a id="12905" class="Symbol">)</a> <a id="12907" class="Symbol">=</a> <a id="12909" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12914" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12916" href="blog.generic-parallel-fp.html#12900" class="Bound">x</a> <a id="12918" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12920" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="12925" href="blog.generic-parallel-fp.html#12897" class="Bound">f</a> <a id="12927" href="blog.generic-parallel-fp.html#12904" class="Bound">y</a>
  <a id="12931" href="blog.generic-parallel-fp.html#12830" class="Function">z*</a> <a id="12934" class="Symbol">.</a><a id="12935" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12939" class="Symbol">(</a><a id="12940" href="blog.generic-parallel-fp.html#12940" class="Bound">fa</a> <a id="12943" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12945" href="blog.generic-parallel-fp.html#12945" class="Bound">ga</a><a id="12947" class="Symbol">)</a> <a id="12949" class="Symbol">(</a><a id="12950" href="blog.generic-parallel-fp.html#12950" class="Bound">fb</a> <a id="12953" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12955" href="blog.generic-parallel-fp.html#12955" class="Bound">gb</a><a id="12957" class="Symbol">)</a> <a id="12959" class="Symbol">=</a> <a id="12961" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12965" href="blog.generic-parallel-fp.html#12940" class="Bound">fa</a> <a id="12968" href="blog.generic-parallel-fp.html#12950" class="Bound">fb</a> <a id="12971" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="12973" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="12977" href="blog.generic-parallel-fp.html#12945" class="Bound">ga</a> <a id="12980" href="blog.generic-parallel-fp.html#12955" class="Bound">gb</a>

  <a id="z∘"></a><a id="12986" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="12989" class="Symbol">:</a> <a id="12991" class="Symbol">⦃</a> <a id="12993" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="12997" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="12999" class="Symbol">⦄</a> <a id="13001" class="Symbol">→</a> <a id="13003" class="Symbol">⦃</a> <a id="13005" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="13009" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13011" class="Symbol">⦄</a> <a id="13013" class="Symbol">→</a> <a id="13015" href="blog.generic-parallel-fp.html#11335" class="Record">Zip</a> <a id="13019" class="Symbol">(</a><a id="13020" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="13028" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13030" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="13031" class="Symbol">)</a>
  <a id="13035" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="13038" class="Symbol">.</a><a id="13039" href="blog.generic-parallel-fp.html#11390" class="Field">func</a> <a id="13044" class="Symbol">.</a><a id="13045" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13050" href="blog.generic-parallel-fp.html#13050" class="Bound">f</a> <a id="13052" class="Symbol">=</a> <a id="13054" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13059" href="blog.generic-parallel-fp.html#13050" class="Bound">f</a>
  <a id="13063" href="blog.generic-parallel-fp.html#12986" class="Function">z∘</a> <a id="13066" class="Symbol">.</a><a id="13067" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="13071" class="Symbol">(</a><a id="13072" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13080" href="blog.generic-parallel-fp.html#13080" class="Bound">fa</a><a id="13082" class="Symbol">)</a> <a id="13084" class="Symbol">(</a><a id="13085" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13093" href="blog.generic-parallel-fp.html#13093" class="Bound">ga</a><a id="13095" class="Symbol">)</a> <a id="13097" class="Symbol">=</a>
    <a id="13103" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="13111" class="Symbol">(</a><a id="13112" href="blog.generic-parallel-fp.html#8472" class="Field">fmap</a> <a id="13117" class="Symbol">(</a><a id="13118" href="Data.Product.html#3431" class="Function">uncurry</a> <a id="13126" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a><a id="13129" class="Symbol">)</a> <a id="13131" class="Symbol">(</a><a id="13132" href="blog.generic-parallel-fp.html#11413" class="Field">zip</a> <a id="13136" href="blog.generic-parallel-fp.html#13080" class="Bound">fa</a> <a id="13139" href="blog.generic-parallel-fp.html#13093" class="Bound">ga</a><a id="13141" class="Symbol">))</a>
</pre>-->
<p>And we’re done! We now have an algorithm defined piece-wise over the fundamental ADT building blocks. Let’s put it to use.</p>
<h2 id="dividing-and-conquering"><a href="#dividing-and-conquering" class="header-link">Dividing and Conquering<span class="header-link-emoji">🔗</span></a></h2>
<p>Let’s pretend that <span class="Agda"><a href="Data.Vec.Base.html#1007" class="Datatype">Vec</a></span>s are random access arrays. We’d like to be able to build array algorithms out of our algorithmic building blocks. To that end, we can make a typeclass corresponding to types that are isomorphic to arrays:</p>
<pre class="Agda"><a id="13548" class="Keyword">open</a> <a id="13553" class="Keyword">import</a> <a id="13560" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="13569" class="Keyword">open</a> <a id="13574" class="Keyword">import</a> <a id="13581" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="13590" class="Keyword">hiding</a> <a id="13597" class="Symbol">(</a><a id="13598" href="Data.Vec.Base.html#3906" class="Function">zip</a><a id="13601" class="Symbol">;</a> <a id="13603" href="Data.Vec.Base.html#3973" class="Function">unzip</a><a id="13608" class="Symbol">;</a> <a id="13610" href="Data.Vec.Base.html#3427" class="Function">zipWith</a><a id="13617" class="Symbol">)</a>

<a id="13620" class="Keyword">record</a> <a id="ArrayIso"></a><a id="13627" href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a> <a id="13636" class="Symbol">(</a><a id="13637" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13639" class="Symbol">:</a> <a id="13641" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="13645" class="Symbol">→</a> <a id="13647" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="13650" class="Symbol">)</a> <a id="13652" class="Symbol">:</a> <a id="13654" href="Agda.Primitive.html#320" class="Primitive">Set₁</a> <a id="13659" class="Keyword">where</a>
  <a id="13667" class="Keyword">field</a>
    <a id="ArrayIso.Size"></a><a id="13677" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="13682" class="Symbol">:</a> <a id="13684" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
    <a id="ArrayIso.deserialize"></a><a id="13690" href="blog/generic-parallel-fp/index.html#13690" class="Field">deserialize</a> <a id="13702" class="Symbol">:</a> <a id="13704" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="13708" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13710" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="13715" class="Symbol">→</a> <a id="13717" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13719" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
    <a id="ArrayIso.serialize"></a><a id="13725" href="blog/generic-parallel-fp/index.html#13725" class="Field">serialize</a> <a id="13735" class="Symbol">:</a> <a id="13737" href="blog/generic-parallel-fp/index.html#13637" class="Bound">F</a> <a id="13739" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13741" class="Symbol">→</a> <a id="13743" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="13747" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="13749" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a>
    <a id="13758" class="Comment">-- also prove it&#39;s an iso</a>

<a id="13785" class="Keyword">open</a> <a id="13790" href="blog/generic-parallel-fp/index.html#13627" class="Module">ArrayIso</a> <a id="13799" class="Symbol">⦃</a> <a id="13801" class="Symbol">...</a> <a id="13805" class="Symbol">⦄</a>
</pre>
<!--
<pre class="Agda"><a id="13821" class="Keyword">instance</a>
  <a id="dU"></a><a id="13832" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13835" class="Symbol">:</a> <a id="13837" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13846" class="Symbol">(\</a><a id="13848" href="blog.generic-parallel-fp.html#13848" class="Bound">a</a> <a id="13850" class="Symbol">→</a> <a id="13852" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="13853" class="Symbol">)</a>
  <a id="13857" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13860" class="Symbol">.</a><a id="13861" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="13866" class="Symbol">=</a> <a id="13868" class="Number">0</a>
  <a id="13872" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13875" class="Symbol">.</a><a id="13876" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="13888" class="Symbol">_</a> <a id="13890" class="Symbol">=</a> <a id="13892" href="Agda.Builtin.Unit.html#195" class="InductiveConstructor">tt</a>
  <a id="13897" href="blog.generic-parallel-fp.html#13832" class="Function">dU</a> <a id="13900" class="Symbol">.</a><a id="13901" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="13911" class="Symbol">_</a> <a id="13913" class="Symbol">=</a> <a id="13915" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a>

  <a id="d*"></a><a id="13921" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="13924" class="Symbol">:</a> <a id="13926" class="Symbol">⦃</a> <a id="13928" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13937" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13939" class="Symbol">⦄</a> <a id="13941" class="Symbol">→</a> <a id="13943" class="Symbol">⦃</a> <a id="13945" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13954" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13956" class="Symbol">⦄</a> <a id="13958" class="Symbol">→</a> <a id="13960" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="13969" class="Symbol">(\</a><a id="13971" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a> <a id="13973" class="Symbol">→</a> <a id="13975" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="13977" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a> <a id="13979" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="13981" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="13983" href="blog.generic-parallel-fp.html#13971" class="Bound">a</a><a id="13984" class="Symbol">)</a>
  <a id="13988" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="13991" class="Symbol">⦃</a> <a id="13993" href="blog.generic-parallel-fp.html#13993" class="Bound">d-f</a> <a id="13997" class="Symbol">⦄</a> <a id="13999" class="Symbol">⦃</a> <a id="14001" href="blog.generic-parallel-fp.html#14001" class="Bound">d-g</a> <a id="14005" class="Symbol">⦄</a> <a id="14007" class="Symbol">.</a><a id="14008" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14013" class="Symbol">=</a> <a id="14015" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14020" class="Symbol">⦃</a> <a id="14022" href="blog.generic-parallel-fp.html#13993" class="Bound">d-f</a> <a id="14026" class="Symbol">⦄</a> <a id="14028" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="14030" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14035" class="Symbol">⦃</a> <a id="14037" href="blog.generic-parallel-fp.html#14001" class="Bound">d-g</a> <a id="14041" class="Symbol">⦄</a>
  <a id="14045" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="14048" class="Symbol">⦃</a> <a id="14050" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14054" class="Symbol">⦄</a> <a id="14056" class="Symbol">⦃</a> <a id="14058" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14062" class="Symbol">⦄</a> <a id="14064" class="Symbol">.</a><a id="14065" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14077" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a> <a id="14079" class="Symbol">=</a>
    <a id="14085" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14097" class="Symbol">⦃</a> <a id="14099" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14103" class="Symbol">⦄</a> <a id="14105" class="Symbol">(</a><a id="14106" href="Data.Vec.Base.html#6470" class="Function">take</a> <a id="14111" class="Symbol">(</a><a id="14112" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14117" class="Symbol">⦃</a> <a id="14119" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14123" class="Symbol">⦄)</a> <a id="14126" class="Symbol">{</a><a id="14127" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14132" class="Symbol">⦃</a> <a id="14134" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14138" class="Symbol">⦄}</a> <a id="14141" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a><a id="14142" class="Symbol">)</a> <a id="14144" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a>
    <a id="14150" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14162" class="Symbol">⦃</a> <a id="14164" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14168" class="Symbol">⦄</a> <a id="14170" class="Symbol">(</a><a id="14171" href="Data.Vec.Base.html#6592" class="Function">drop</a> <a id="14176" class="Symbol">(</a><a id="14177" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14182" class="Symbol">⦃</a> <a id="14184" href="blog.generic-parallel-fp.html#14050" class="Bound">d-f</a> <a id="14188" class="Symbol">⦄)</a> <a id="14191" class="Symbol">{</a><a id="14192" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14197" class="Symbol">⦃</a> <a id="14199" href="blog.generic-parallel-fp.html#14058" class="Bound">d-g</a> <a id="14203" class="Symbol">⦄}</a> <a id="14206" href="blog.generic-parallel-fp.html#14077" class="Bound">x</a><a id="14207" class="Symbol">)</a>
  <a id="14211" href="blog.generic-parallel-fp.html#13921" class="Function">d*</a> <a id="14214" class="Symbol">⦃</a> <a id="14216" href="blog.generic-parallel-fp.html#14216" class="Bound">d-f</a> <a id="14220" class="Symbol">⦄</a> <a id="14222" class="Symbol">⦃</a> <a id="14224" href="blog.generic-parallel-fp.html#14224" class="Bound">d-g</a> <a id="14228" class="Symbol">⦄</a> <a id="14230" class="Symbol">.</a><a id="14231" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14241" class="Symbol">(</a><a id="14242" href="blog.generic-parallel-fp.html#14242" class="Bound">f</a> <a id="14244" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14246" href="blog.generic-parallel-fp.html#14246" class="Bound">g</a><a id="14247" class="Symbol">)</a> <a id="14249" class="Symbol">=</a>
    <a id="14255" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14265" class="Symbol">⦃</a> <a id="14267" href="blog.generic-parallel-fp.html#14216" class="Bound">d-f</a> <a id="14271" class="Symbol">⦄</a> <a id="14273" href="blog.generic-parallel-fp.html#14242" class="Bound">f</a> <a id="14275" href="Data.Vec.Base.html#2718" class="Function Operator">++</a> <a id="14278" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14288" class="Symbol">⦃</a> <a id="14290" href="blog.generic-parallel-fp.html#14224" class="Bound">d-g</a> <a id="14294" class="Symbol">⦄</a> <a id="14296" href="blog.generic-parallel-fp.html#14246" class="Bound">g</a>

  <a id="dP"></a><a id="14301" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14304" class="Symbol">:</a> <a id="14306" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14315" class="Symbol">(\</a><a id="14317" href="blog.generic-parallel-fp.html#14317" class="Bound">a</a> <a id="14319" class="Symbol">→</a> <a id="14321" href="blog.generic-parallel-fp.html#14317" class="Bound">a</a><a id="14322" class="Symbol">)</a>
  <a id="14326" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14329" class="Symbol">.</a><a id="14330" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14335" class="Symbol">=</a> <a id="14337" class="Number">1</a>
  <a id="14341" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14344" class="Symbol">.</a><a id="14345" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14357" class="Symbol">(</a><a id="14358" href="blog.generic-parallel-fp.html#14358" class="Bound">x</a> <a id="14360" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="14362" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="14364" class="Symbol">)</a> <a id="14366" class="Symbol">=</a> <a id="14368" href="blog.generic-parallel-fp.html#14358" class="Bound">x</a>
  <a id="14372" href="blog.generic-parallel-fp.html#14301" class="Function">dP</a> <a id="14375" class="Symbol">.</a><a id="14376" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14386" href="blog.generic-parallel-fp.html#14386" class="Bound">x</a> <a id="14388" class="Symbol">=</a> <a id="14390" href="blog.generic-parallel-fp.html#14386" class="Bound">x</a> <a id="14392" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="14394" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a>

  <a id="d∘"></a><a id="14400" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14403" class="Symbol">:</a> <a id="14405" class="Symbol">⦃</a> <a id="14407" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14416" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="14418" class="Symbol">⦄</a> <a id="14420" class="Symbol">→</a> <a id="14422" class="Symbol">⦃</a> <a id="14424" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14433" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a> <a id="14435" class="Symbol">⦄</a> <a id="14437" class="Symbol">→</a> <a id="14439" href="blog.generic-parallel-fp.html#13627" class="Record">ArrayIso</a> <a id="14448" class="Symbol">(</a><a id="14449" href="blog.generic-parallel-fp.html#6068" class="Record">Compose</a> <a id="14457" href="blog.generic-parallel-fp.html#266" class="Generalizable">F</a> <a id="14459" href="blog.generic-parallel-fp.html#268" class="Generalizable">G</a><a id="14460" class="Symbol">)</a>
  <a id="14464" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14467" class="Symbol">⦃</a> <a id="14469" href="blog.generic-parallel-fp.html#14469" class="Bound">d-f</a> <a id="14473" class="Symbol">⦄</a> <a id="14475" class="Symbol">⦃</a> <a id="14477" href="blog.generic-parallel-fp.html#14477" class="Bound">d-g</a> <a id="14481" class="Symbol">⦄</a> <a id="14483" class="Symbol">.</a><a id="14484" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14489" class="Symbol">=</a> <a id="14491" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14496" class="Symbol">⦃</a> <a id="14498" href="blog.generic-parallel-fp.html#14469" class="Bound">d-f</a> <a id="14502" class="Symbol">⦄</a> <a id="14504" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="14506" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14511" class="Symbol">⦃</a> <a id="14513" href="blog.generic-parallel-fp.html#14477" class="Bound">d-g</a> <a id="14517" class="Symbol">⦄</a>
  <a id="14521" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14524" class="Symbol">⦃</a> <a id="14526" href="blog.generic-parallel-fp.html#14526" class="Bound">d-f</a> <a id="14530" class="Symbol">⦄</a> <a id="14532" class="Symbol">⦃</a> <a id="14534" href="blog.generic-parallel-fp.html#14534" class="Bound">d-g</a> <a id="14538" class="Symbol">⦄</a> <a id="14540" class="Symbol">.</a><a id="14541" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14553" href="blog.generic-parallel-fp.html#14553" class="Bound">x</a> <a id="14555" class="Symbol">=</a>
    <a id="14561" class="Keyword">let</a> <a id="14565" href="blog.generic-parallel-fp.html#14565" class="Bound">y</a> <a id="14567" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="14569" class="Symbol">_</a> <a id="14571" class="Symbol">=</a> <a id="14573" href="Data.Vec.Base.html#6714" class="Function">group</a> <a id="14579" class="Symbol">(</a><a id="14580" href="blog.generic-parallel-fp.html#13677" class="Field">Size</a> <a id="14585" class="Symbol">⦃</a> <a id="14587" href="blog.generic-parallel-fp.html#14526" class="Bound">d-f</a> <a id="14591" class="Symbol">⦄)</a> <a id="14594" class="Symbol">_</a> <a id="14596" href="blog.generic-parallel-fp.html#14553" class="Bound">x</a>
     <a id="14603" class="Keyword">in</a> <a id="14606" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="14614" class="Symbol">(</a><a id="14615" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14627" class="Symbol">(</a><a id="14628" href="Data.Vec.Base.html#2589" class="Function">Data.Vec.map</a> <a id="14641" class="Symbol">(</a><a id="14642" href="blog.generic-parallel-fp.html#13690" class="Field">deserialize</a> <a id="14654" class="Symbol">⦃</a> <a id="14656" href="blog.generic-parallel-fp.html#14534" class="Bound">d-g</a> <a id="14660" class="Symbol">⦄)</a> <a id="14663" href="blog.generic-parallel-fp.html#14565" class="Bound">y</a><a id="14664" class="Symbol">))</a>
  <a id="14669" href="blog.generic-parallel-fp.html#14400" class="Function">d∘</a> <a id="14672" class="Symbol">⦃</a> <a id="14674" href="blog.generic-parallel-fp.html#14674" class="Bound">d-f</a> <a id="14678" class="Symbol">⦄</a> <a id="14680" class="Symbol">⦃</a> <a id="14682" href="blog.generic-parallel-fp.html#14682" class="Bound">d-g</a> <a id="14686" class="Symbol">⦄</a> <a id="14688" class="Symbol">.</a><a id="14689" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14699" class="Symbol">(</a><a id="14700" href="blog.generic-parallel-fp.html#6130" class="InductiveConstructor">compose</a> <a id="14708" href="blog.generic-parallel-fp.html#14708" class="Bound">x</a><a id="14709" class="Symbol">)</a> <a id="14711" class="Symbol">=</a>
    <a id="14717" href="Data.Vec.Base.html#2822" class="Function">concat</a> <a id="14724" class="Symbol">(</a><a id="14725" href="Data.Vec.Base.html#2589" class="Function">Data.Vec.map</a> <a id="14738" class="Symbol">(</a><a id="14739" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14749" class="Symbol">⦃</a> <a id="14751" href="blog.generic-parallel-fp.html#14682" class="Bound">d-g</a> <a id="14755" class="Symbol">⦄)</a> <a id="14758" class="Symbol">(</a><a id="14759" href="blog.generic-parallel-fp.html#13725" class="Field">serialize</a> <a id="14769" class="Symbol">⦃</a> <a id="14771" href="blog.generic-parallel-fp.html#14674" class="Bound">d-f</a> <a id="14775" class="Symbol">⦄</a> <a id="14777" href="blog.generic-parallel-fp.html#14708" class="Bound">x</a><a id="14778" class="Symbol">))</a>
</pre>-->
<p>There are instances of <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> for the functor building blocks (though none for <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5836" class="InductiveConstructor Operator">:+:</a></span> since arrays are big records.) We can now use an <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> and an <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> to get our desired parallel array algorithms:</p>
<pre class="Agda"><a id="genericScan"></a><a id="15033" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a>
    <a id="15049" class="Symbol">:</a> <a id="15051" class="Symbol">⦃</a> <a id="15053" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15060" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15062" class="Symbol">⦄</a>
    <a id="15068" class="Symbol">→</a> <a id="15070" class="Symbol">(</a><a id="15071" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a> <a id="15075" class="Symbol">:</a> <a id="15077" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a><a id="15080" class="Symbol">)</a>
    <a id="15086" class="Symbol">→</a> <a id="15088" class="Symbol">⦃</a> <a id="15090" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15092" class="Symbol">:</a> <a id="15094" href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a> <a id="15103" class="Symbol">(</a><a id="15104" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="15114" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a><a id="15117" class="Symbol">)</a> <a id="15119" class="Symbol">⦄</a>
    <a id="15125" class="Symbol">→</a> <a id="15127" class="Symbol">⦃</a> <a id="15129" href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a> <a id="15135" class="Symbol">(</a><a id="15136" href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a> <a id="15146" href="blog/generic-parallel-fp/index.html#15071" class="Bound">rep</a><a id="15149" class="Symbol">)</a> <a id="15151" class="Symbol">⦄</a>
    <a id="15157" class="Symbol">→</a> <a id="15159" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15163" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15165" class="Symbol">(</a><a id="15166" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="15171" class="Symbol">⦃</a> <a id="15173" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15175" class="Symbol">⦄)</a>
    <a id="15182" class="Symbol">→</a> <a id="15184" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15188" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15190" class="Symbol">(</a><a id="15191" href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a> <a id="15196" class="Symbol">⦃</a> <a id="15198" href="blog/generic-parallel-fp/index.html#15090" class="Bound">d</a> <a id="15200" class="Symbol">⦄)</a> <a id="15203" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="15205" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15207" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15219" class="Symbol">_</a> <a id="15221" class="Symbol">⦃</a> <a id="15223" class="Argument">d</a> <a id="15225" class="Symbol">=</a> <a id="15227" href="blog/generic-parallel-fp/index.html#15227" class="Bound">d</a> <a id="15229" class="Symbol">⦄</a> <a id="15231" href="blog/generic-parallel-fp/index.html#15231" class="Bound">x</a> <a id="15233" class="Symbol">=</a>
  <a id="15237" class="Keyword">let</a> <a id="15241" href="blog/generic-parallel-fp/index.html#15241" class="Bound">res</a> <a id="15245" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="15247" href="blog/generic-parallel-fp/index.html#15247" class="Bound">a</a> <a id="15249" class="Symbol">=</a> <a id="15251" href="blog/generic-parallel-fp/index.html#8603" class="Field">lscan</a> <a id="15257" class="Symbol">(</a><a id="15258" href="blog/generic-parallel-fp/index.html#13690" class="Field">deserialize</a> <a id="15270" href="blog/generic-parallel-fp/index.html#15231" class="Bound">x</a><a id="15271" class="Symbol">)</a>
   <a id="15276" class="Keyword">in</a> <a id="15279" href="blog/generic-parallel-fp/index.html#13725" class="Field">serialize</a> <a id="15289" class="Symbol">⦃</a> <a id="15291" href="blog/generic-parallel-fp/index.html#15227" class="Bound">d</a> <a id="15293" class="Symbol">⦄</a> <a id="15295" href="blog/generic-parallel-fp/index.html#15241" class="Bound">res</a> <a id="15299" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="15301" href="blog/generic-parallel-fp/index.html#15247" class="Bound">a</a>
</pre>
<p>I think this is the first truly dependent type I’ve ever written. We take a <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a></span> corresponding to how we’d like to divvy up the problem, and then see if the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#6183" class="Function">Represent</a></span> of that has <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13627" class="Record">ArrayIso</a></span> and <span class="Agda"><a href="blog/generic-parallel-fp/index.html#8523" class="Record">LScan</a></span> instances, and then give back an algorithm that scans over arrays of the correct <span class="Agda"><a href="blog/generic-parallel-fp/index.html#13677" class="Field">Size</a></span>.</p>
<p>Finally we’re ready to try this out. We can give the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1013" class="Datatype">RList</a></span> implementation from earlier:</p>
<pre class="Agda"><a id="▷_"></a><a id="15740" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷_</a> <a id="15743" class="Symbol">:</a> <a id="15745" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="15749" class="Symbol">→</a> <a id="15751" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
<a id="15755" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷_</a> <a id="15758" href="blog/generic-parallel-fp/index.html#15758" class="Bound">a</a> <a id="15760" class="Symbol">=</a> <a id="15762" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="15766" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="15770" href="blog/generic-parallel-fp/index.html#15758" class="Bound">a</a>

<a id="15773" href="blog/generic-parallel-fp/index.html#15773" class="Function">_</a> <a id="15775" class="Symbol">:</a> <a id="15777" class="Symbol">⦃</a> <a id="15779" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15786" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15788" class="Symbol">⦄</a> <a id="15790" class="Symbol">→</a> <a id="15792" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15796" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15798" class="Number">4</a> <a id="15800" class="Symbol">→</a> <a id="15802" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15806" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15808" class="Number">4</a> <a id="15810" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="15812" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15814" class="Symbol">_</a> <a id="15816" class="Symbol">=</a> <a id="15818" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15830" class="Symbol">(</a><a id="15831" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15833" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15835" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="15837" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a><a id="15840" class="Symbol">)</a>
</pre>
<p>or the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#1497" class="Datatype">LList</a></span> instance:</p>
<pre class="Agda"><a id="_◁"></a><a id="15884" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">_◁</a> <a id="15887" class="Symbol">:</a> <a id="15889" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a> <a id="15893" class="Symbol">→</a> <a id="15895" href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a>
<a id="15899" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">_◁</a> <a id="15902" href="blog/generic-parallel-fp/index.html#15902" class="Bound">a</a> <a id="15904" class="Symbol">=</a> <a id="15906" href="blog/generic-parallel-fp/index.html#15902" class="Bound">a</a> <a id="15908" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="15912" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a>

<a id="15917" href="blog/generic-parallel-fp/index.html#15917" class="Function">_</a> <a id="15919" class="Symbol">:</a> <a id="15921" class="Symbol">⦃</a> <a id="15923" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="15930" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15932" class="Symbol">⦄</a> <a id="15934" class="Symbol">→</a> <a id="15936" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15940" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15942" class="Number">4</a> <a id="15944" class="Symbol">→</a> <a id="15946" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="15950" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="15952" class="Number">4</a> <a id="15954" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="15956" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="15958" class="Symbol">_</a> <a id="15960" class="Symbol">=</a> <a id="15962" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="15974" class="Symbol">(</a><a id="15975" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="15979" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="15981" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="15983" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a><a id="15984" class="Symbol">)</a>
</pre>
<p>But we can also come up with more interesting strategies as well. For example, we can divvy up the problem by left-associating the first half, and right-associating the second:</p>
<pre class="Agda"><a id="16173" href="blog/generic-parallel-fp/index.html#16173" class="Function">_</a> <a id="16175" class="Symbol">:</a> <a id="16177" class="Symbol">⦃</a> <a id="16179" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16186" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16188" class="Symbol">⦄</a> <a id="16190" class="Symbol">→</a> <a id="16192" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="16196" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16198" class="Number">8</a> <a id="16200" class="Symbol">→</a> <a id="16202" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="16206" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16208" class="Number">8</a> <a id="16210" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="16212" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="16214" class="Symbol">_</a> <a id="16216" class="Symbol">=</a> <a id="16218" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="16230" class="Symbol">((</a><a id="16232" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="16236" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="16238" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a> <a id="16240" href="blog/generic-parallel-fp/index.html#15884" class="Function Operator">◁</a><a id="16241" class="Symbol">)</a> <a id="16243" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="16247" class="Symbol">(</a><a id="16248" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16250" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16252" href="blog/generic-parallel-fp/index.html#15740" class="Function Operator">▷</a> <a id="16254" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a><a id="16257" class="Symbol">))</a>
</pre>
<p>This one probably isn’t an <em>efficient</em> algorithm, but it’s cool that we can express such a thing so succinctly. Probably of more interest is a balanced tree over our array:</p>
<pre class="Agda"><a id="16443" href="blog/generic-parallel-fp/index.html#16443" class="Function">_</a> <a id="16445" class="Symbol">:</a> <a id="16447" class="Symbol">⦃</a> <a id="16449" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16456" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16458" class="Symbol">⦄</a> <a id="16460" class="Symbol">→</a> <a id="16462" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="16466" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16468" class="Number">16</a> <a id="16471" class="Symbol">→</a> <a id="16473" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="16477" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16479" class="Number">16</a> <a id="16482" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="16484" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="16486" class="Symbol">_</a> <a id="16488" class="Symbol">=</a> <a id="16490" class="Keyword">let</a> <a id="16494" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a> <a id="16498" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a> <a id="16500" class="Symbol">=</a> <a id="16502" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a> <a id="16504" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="16508" href="blog/generic-parallel-fp/index.html#16498" class="Bound">a</a>
     <a id="16515" class="Keyword">in</a> <a id="16518" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="16530" class="Symbol">(</a><a id="16531" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16533" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16535" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16537" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊</a> <a id="16539" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="16543" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16545" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16547" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a> <a id="16549" href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌋</a><a id="16550" class="Symbol">)</a>
</pre>
<p>The balanced tree over products is interesting, but what if we make a balanced tree over <em>composition?</em> In essence, we can split the problem into chunks of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mo stretchy="false">(</mo></msup><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2^(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> amounts of work via <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a></span>:</p>
<pre class="Agda"><a id="16763" class="Symbol">{-#</a> <a id="16767" class="Keyword">NO_POSITIVITY_CHECK</a> <a id="16787" class="Symbol">#-}</a>
<a id="16791" class="Keyword">data</a> <a id="Bush"></a><a id="16796" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16801" class="Symbol">:</a> <a id="16803" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="16805" class="Symbol">→</a> <a id="16807" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="16811" class="Symbol">→</a> <a id="16813" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="16817" class="Keyword">where</a>
  <a id="Bush.twig"></a><a id="16825" href="blog/generic-parallel-fp/index.html#16825" class="InductiveConstructor">twig</a> <a id="16830" class="Symbol">:</a> <a id="16832" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16834" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="16836" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16838" class="Symbol">→</a> <a id="16840" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16845" class="Number">0</a> <a id="16847" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
  <a id="Bush.bush"></a><a id="16851" href="blog/generic-parallel-fp/index.html#16851" class="InductiveConstructor">bush</a> <a id="16856" class="Symbol">:</a> <a id="16858" class="Symbol">{</a><a id="16859" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16861" class="Symbol">:</a> <a id="16863" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="16864" class="Symbol">}</a> <a id="16866" class="Symbol">→</a> <a id="16868" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16873" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16875" class="Symbol">(</a><a id="16876" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16881" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a> <a id="16883" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a><a id="16884" class="Symbol">)</a> <a id="16886" class="Symbol">→</a> <a id="16888" href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a> <a id="16893" class="Symbol">(</a><a id="16894" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="16898" href="blog/generic-parallel-fp/index.html#16859" class="Bound">n</a><a id="16899" class="Symbol">)</a> <a id="16901" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
</pre>
<p>Which we won’t use directly, but can use it’s <span class="Agda"><a href="blog/generic-parallel-fp/index.html#5743" class="Datatype">Rep</a></span>:</p>
<pre class="Agda"><a id="16973" href="blog/generic-parallel-fp/index.html#16973" class="Function">_</a> <a id="16975" class="Symbol">:</a> <a id="16977" class="Symbol">⦃</a> <a id="16979" href="blog/generic-parallel-fp/index.html#304" class="Record">Monoid</a> <a id="16986" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16988" class="Symbol">⦄</a> <a id="16990" class="Symbol">→</a> <a id="16992" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="16996" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="16998" class="Number">16</a> <a id="17001" class="Symbol">→</a> <a id="17003" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="17007" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a> <a id="17009" class="Number">16</a> <a id="17012" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="17014" href="blog/generic-parallel-fp/index.html#254" class="Generalizable">A</a>
<a id="17016" class="Symbol">_</a> <a id="17018" class="Symbol">=</a> <a id="17020" class="Keyword">let</a> <a id="17024" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17029" class="Symbol">=</a> <a id="17031" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a> <a id="17035" href="blog/generic-parallel-fp/index.html#5862" class="InductiveConstructor Operator">:*:</a> <a id="17039" href="blog/generic-parallel-fp/index.html#5798" class="InductiveConstructor">Par</a>
     <a id="17048" class="Keyword">in</a> <a id="17051" href="blog/generic-parallel-fp/index.html#15033" class="Function">genericScan</a> <a id="17063" class="Symbol">((</a><a id="17065" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17070" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17074" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a><a id="17078" class="Symbol">)</a> <a id="17080" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17084" class="Symbol">(</a><a id="17085" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a> <a id="17090" href="blog/generic-parallel-fp/index.html#5888" class="InductiveConstructor Operator">:∘:</a> <a id="17094" href="blog/generic-parallel-fp/index.html#17024" class="Bound">pair</a><a id="17098" class="Symbol">))</a>
</pre>
<p>The paper compares several of these strategies for dividing-and-conquering. In particular, it shows that we can minimize total work via a left-associated <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a></span> strategy, but maximize parallelism with a <em>right</em>-associated <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16494" class="Bound Operator">⌊_⌋</a></span>. And using the <code>Bush</code> from earlier, we can get a nice middle ground.</p>
<h2 id="very-quick-ffts"><a href="#very-quick-ffts" class="header-link">Very Quick FFTs<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper follows up, applying this approach to implementations of the fast fourier transform. There, the <span class="Agda"><a href="blog/generic-parallel-fp/index.html#16796" class="Datatype">Bush</a></span> approach gives constant factor improvments for both <em>work</em> and <em>parallelism,</em> compared to all previously known algorithms.</p>
<p>Results like these are strong evidence that Elliott is <em>actually onto something</em> with his seemingly crazy ideas that computation should be elegant and well principled. Giving significant constant factor improvements to well-known, extremely important algorithms <em>mostly for free</em> is a true superpower, and is worth taking extremely seriously.</p>
<h2 id="fighting-against-publication-bias"><a href="#fighting-against-publication-bias" class="header-link">Fighting Against Publication Bias<span class="header-link-emoji">🔗</span></a></h2>
<p>Andrew McKnight and I tried to use this same approach to get a nice algorithm for sorting, hoping that we could get well-known sorting algorithms to fall out as special cases of our more general functor building blocks. We completely failed on this front, namely because we couldn’t figure out how to give an instance for product types. Rather alarmingly, we’re not entirely sure <em>why</em> the approach failed there; maybe it was just not thinking hard enough.</p>
<p>Another plausible idea is that sorting requires branching, and that this approach only works for statically-known codepaths.</p>
<h2 id="future-work"><a href="#future-work" class="header-link">Future Work<span class="header-link-emoji">🔗</span></a></h2>
<p>Andrew and I spent a good chunk of the week thinking about this problem, and we figure there are solid odds that you could <em>automatically</em> discover these generic algorithmic building blocks from a well-known algorithm. Here’s the sketch:</p>
<p>Use the well-known algorithm as a specification, instantiate all parameters at small types and see if you can find instances of the algorithm for the functor building blocks that agree with the spec. It seems like you should be able to use factorization of the input to target which instances you’re looking for.</p>
<p>Of course, once you have the algorithmic building blocks, conventional search techniques can be used to optimize any particular goal you might have.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Lightweight Semiformal Time Complexity Analysis for Purely Functional Data Structures</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/complexity-analysis/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/complexity-analysis/index.html</guid>
      <pubDate>2022-03-06</pubDate>
      <content:encoded><![CDATA[
        <p>What a mouthful of a title! <a href="https://www.cse.chalmers.se/~nad/publications/danielsson-popl2008.pdf">LWTCAfPFDS</a> is our paper for the week, written by Nils Anders Danielsson. At a high level, the idea is to introduce a graded monad which counts computation steps, whose bind adds those steps together. By constructing our program in this monad, we can use the type-system to track its runtime asymptotics.</p>
<h2 id="core-definitions"><a href="#core-definitions" class="header-link">Core Definitions<span class="header-link-emoji">🔗</span></a></h2>
<p>We might as well dive in. Since all of this complexity analysis stuff shouldn’t <em>change</em> anything at runtime, we really only need to stick the analysis in the types, and can erase it all at runtime.</p>
<p>The paper thus presents its main tools in an <code>abstract</code> block, which is a new Agda feature for me. And wow, does Agda ever feel like it’s Haskell but from the future. An <code>abstract</code> block lets us give some definitions, which <em>inside</em> the <code>abstract</code> block can be normalized. But outside the block, they are opaque symbols that are just what they are. This is a delightful contrast to Haskell, where we need to play a game of making a new module, and carefully not exporting things in order to get the same behavior. And even then, in Haskell, we can’t give opaque <code>type</code> synonyms or anything like that.</p>
<p>Anyway, the main type in the paper is <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span>, which tracks how many computation steps are necessary to produce an eventual value:</p>
<!--
<pre class="Agda"><a id="1606" class="Symbol">{-#</a> <a id="1610" class="Keyword">OPTIONS</a> <a id="1618" class="Pragma">--rewriting</a> <a id="1630" class="Symbol">#-}</a>

<a id="1635" class="Keyword">module</a> <a id="1642" href="blog.complexity-analysis.html" class="Module">blog.complexity-analysis</a> <a id="1667" class="Keyword">where</a>

<a id="1674" class="Keyword">open</a> <a id="1679" class="Keyword">import</a> <a id="1686" href="Function.html" class="Module">Function</a>
<a id="1695" class="Keyword">open</a> <a id="1700" class="Keyword">import</a> <a id="1707" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="1716" class="Keyword">open</a> <a id="1721" class="Keyword">import</a> <a id="1728" href="Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a>
<a id="1748" class="Keyword">open</a> <a id="1753" class="Keyword">import</a> <a id="1760" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="1770" class="Keyword">using</a> <a id="1776" class="Symbol">(</a><a id="1777" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="1781" class="Symbol">;</a> <a id="1783" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="1787" class="Symbol">;</a> <a id="1789" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="1794" class="Symbol">)</a>
<a id="1796" class="Keyword">open</a> <a id="1801" class="Keyword">import</a> <a id="1808" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1846" class="Symbol">as</a> <a id="1849" class="Module">Eq</a>

<a id="1853" class="Keyword">open</a> <a id="1858" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a>

<a id="1862" class="Keyword">private</a> <a id="1870" class="Keyword">variable</a>
  <a id="1881" href="blog.complexity-analysis.html#1881" class="Generalizable">a</a> <a id="1883" href="blog.complexity-analysis.html#1883" class="Generalizable">b</a> <a id="1885" class="Symbol">:</a> <a id="1887" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="1893" href="blog.complexity-analysis.html#1893" class="Generalizable">m</a> <a id="1895" href="blog.complexity-analysis.html#1895" class="Generalizable">n</a> <a id="1897" class="Symbol">:</a> <a id="1899" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
</pre>-->
<pre class="Agda"><a id="1914" class="Keyword">abstract</a>
  <a id="Thunk"></a><a id="1925" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="1931" class="Symbol">:</a> <a id="1933" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1935" class="Symbol">→</a> <a id="1937" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="1941" class="Symbol">→</a> <a id="1943" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="1949" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="1955" href="blog/complexity-analysis/index.html#1955" class="Bound">n</a> <a id="1957" href="blog/complexity-analysis/index.html#1957" class="Bound">a</a> <a id="1959" class="Symbol">=</a> <a id="1961" href="blog/complexity-analysis/index.html#1957" class="Bound">a</a>
</pre>
<p>Because none of this exists at runtime, we can just ignore the <code>n</code> argument, and use the <code>abstract</code>ion barrier to ensure nobody can use this fact in anger. <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is a <em>graded</em> monad, that is, a monad parameterized by a monoid, which uses <code>mempty</code> for <code>pure</code>, and <code>mappend</code> for binding. We can show that <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> does form a graded monad:</p>
<pre class="Agda">  <a id="pure"></a><a id="2328" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="2333" class="Symbol">:</a> <a id="2335" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2337" class="Symbol">→</a> <a id="2339" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2345" class="Number">0</a> <a id="2347" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="2351" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="2356" href="blog/complexity-analysis/index.html#2356" class="Bound">x</a> <a id="2358" class="Symbol">=</a> <a id="2360" href="blog/complexity-analysis/index.html#2356" class="Bound">x</a>

  <a id="2365" class="Keyword">infixl</a> <a id="2372" class="Number">1</a> <a id="2374" href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a>
  <a id="_&gt;&gt;=_"></a><a id="2382" href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a> <a id="2388" class="Symbol">:</a> <a id="2390" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2396" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2398" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2400" class="Symbol">→</a> <a id="2402" class="Symbol">(</a><a id="2403" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2405" class="Symbol">→</a> <a id="2407" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2413" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2415" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="2416" class="Symbol">)</a> <a id="2418" class="Symbol">→</a> <a id="2420" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2426" class="Symbol">(</a><a id="2427" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2429" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2431" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2432" class="Symbol">)</a> <a id="2434" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a>
  <a id="2438" href="blog/complexity-analysis/index.html#2438" class="Bound">x</a> <a id="2440" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="2444" href="blog/complexity-analysis/index.html#2444" class="Bound">f</a> <a id="2446" class="Symbol">=</a> <a id="2448" href="blog/complexity-analysis/index.html#2444" class="Bound">f</a> <a id="2450" href="blog/complexity-analysis/index.html#2438" class="Bound">x</a>

  <a id="2455" class="Keyword">infixr</a> <a id="2462" class="Number">1</a> <a id="2464" href="blog/complexity-analysis/index.html#2472" class="Function Operator">_=&lt;&lt;_</a>
  <a id="_=&lt;&lt;_"></a><a id="2472" href="blog/complexity-analysis/index.html#2472" class="Function Operator">_=&lt;&lt;_</a> <a id="2478" class="Symbol">:</a> <a id="2480" class="Symbol">(</a><a id="2481" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2483" class="Symbol">→</a> <a id="2485" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2491" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2493" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="2494" class="Symbol">)</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2504" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2506" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2508" class="Symbol">→</a> <a id="2510" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2516" class="Symbol">(</a><a id="2517" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="2519" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="2521" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2522" class="Symbol">)</a> <a id="2524" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a>
  <a id="2528" href="blog/complexity-analysis/index.html#2528" class="Bound">f</a> <a id="2530" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="2534" href="blog/complexity-analysis/index.html#2534" class="Bound">x</a> <a id="2536" class="Symbol">=</a> <a id="2538" href="blog/complexity-analysis/index.html#2528" class="Bound">f</a> <a id="2540" href="blog/complexity-analysis/index.html#2534" class="Bound">x</a>
</pre>
<p>We’ll omit the proofs that <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> really is a monad, but it’s not hard to see; <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is truly just the identity monad.</p>
<p><span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> is also equipped with two further operations; the ability to mark a computation cycle, and the ability to extract the underlying value by throwing away the complexity analysis:</p>
<pre class="Agda">  <a id="2883" class="Keyword">infixr</a> <a id="2890" class="Number">0</a> <a id="2892" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a>
  <a id="!_"></a><a id="2897" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a> <a id="2900" class="Symbol">:</a> <a id="2902" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2908" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2910" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="2912" class="Symbol">→</a> <a id="2914" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2920" class="Symbol">(</a><a id="2921" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2925" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="2926" class="Symbol">)</a> <a id="2928" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="2932" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a> <a id="2935" href="blog/complexity-analysis/index.html#2935" class="Bound">a</a> <a id="2937" class="Symbol">=</a> <a id="2939" href="blog/complexity-analysis/index.html#2935" class="Bound">a</a>

  <a id="force"></a><a id="2944" href="blog/complexity-analysis/index.html#2944" class="Function">force</a> <a id="2950" class="Symbol">:</a> <a id="2952" class="Symbol">{</a><a id="2953" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a> <a id="2955" class="Symbol">:</a> <a id="2957" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="2960" class="Symbol">}</a> <a id="2962" class="Symbol">→</a> <a id="2964" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="2970" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="2972" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a> <a id="2974" class="Symbol">→</a> <a id="2976" href="blog/complexity-analysis/index.html#2953" class="Bound">a</a>
  <a id="2980" href="blog/complexity-analysis/index.html#2944" class="Function">force</a> <a id="2986" href="blog/complexity-analysis/index.html#2986" class="Bound">x</a> <a id="2988" class="Symbol">=</a> <a id="2990" href="blog/complexity-analysis/index.html#2986" class="Bound">x</a>
</pre>
<p>Here, <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> is given a low, right-spanning precedence, which means it’s relatively painless to annotate with:</p>
<pre class="Agda"><a id="3118" href="blog/complexity-analysis/index.html#3118" class="Function">_</a> <a id="3120" class="Symbol">:</a> <a id="3122" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="3128" class="Number">3</a> <a id="3130" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
<a id="3132" class="Symbol">_</a> <a id="3134" class="Symbol">=</a> <a id="3136" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3138" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3140" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="3142" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="3147" class="Number">0</a>
</pre>
<h2 id="conventions"><a href="#conventions" class="header-link">Conventions<span class="header-link-emoji">🔗</span></a></h2>
<p>Our definitions are “opt-in,” in the sense that the compiler won’t yell at you if you forget to call <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> somewhere a computational step happens. Thus, we require users to follow the following conventions:</p>
<ol type="1">
<li>Every function body must begin with a call to <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span>.</li>
<li><span class="Agda"><a href="blog/complexity-analysis/index.html#2944" class="Function">force</a></span> may not be used in a function body.</li>
<li>None of <span class="Agda"><a href="blog/complexity-analysis/index.html#2328" class="Function">pure</a></span>, <span class="Agda"><a href="blog/complexity-analysis/index.html#2382" class="Function Operator">_&gt;&gt;=_</a></span> nor <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> may be called partially applied.</li>
</ol>
<p>The first convention ensures we count everything that should be counted. The second ensures we don’t cheat by discarding complexity information before it’s been counted. And the third ensures we don’t accidentally introduce uncounted computation steps.</p>
<p>The first two are pretty obvious, but the third is a little subtler. Under the hood, partial application gets turned into a lambda, which introduces a computation step to evaluate. But that step won’t be ticked via <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span>, so we will have lost the bijection between our programs and their analyses.</p>
<h2 id="lazy-data-types"><a href="#lazy-data-types" class="header-link">Lazy Data Types<span class="header-link-emoji">🔗</span></a></h2>
<p>The paper shows us how to define a lazy vector. <span class="Agda"><a href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a></span> <code>a c n</code> is a vector of <code>n</code> elements of type <code>a</code>, where the cost of forcing each subsequent tail is <code>c</code>:</p>
<pre class="Agda"><a id="4346" class="Symbol">{-#</a> <a id="4350" class="Keyword">NO_POSITIVITY_CHECK</a> <a id="4370" class="Symbol">#-}</a>
<a id="4374" class="Keyword">data</a> <a id="VecL"></a><a id="4379" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4384" class="Symbol">(</a><a id="4385" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4387" class="Symbol">:</a> <a id="4389" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="4392" class="Symbol">)</a> <a id="4394" class="Symbol">(</a><a id="4395" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4397" class="Symbol">:</a> <a id="4399" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4400" class="Symbol">)</a> <a id="4402" class="Symbol">:</a> <a id="4404" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="4406" class="Symbol">→</a> <a id="4408" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4412" class="Keyword">where</a>
  <a id="VecL.[]"></a><a id="4420" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="4423" class="Symbol">:</a> <a id="4425" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4430" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4432" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4434" class="Number">0</a>
  <a id="VecL._∷_"></a><a id="4438" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">_∷_</a> <a id="4442" class="Symbol">:</a> <a id="4444" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4446" class="Symbol">→</a> <a id="4448" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4454" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4456" class="Symbol">(</a><a id="4457" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4462" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4464" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4466" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="4467" class="Symbol">)</a> <a id="4469" class="Symbol">→</a> <a id="4471" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="4476" href="blog/complexity-analysis/index.html#4385" class="Bound">a</a> <a id="4478" href="blog/complexity-analysis/index.html#4395" class="Bound">c</a> <a id="4480" class="Symbol">(</a><a id="4481" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="4485" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="4486" class="Symbol">)</a>

<a id="4489" class="Keyword">infixr</a> <a id="4496" class="Number">5</a> <a id="4498" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">_∷_</a>
</pre>
<p>Let’s try to write <span class="Agda"><a href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a></span> for <span class="Agda"><a href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a></span>. We’re going to need a helper function, which delays a computation by artificially inflating its number of steps:</p>
<pre class="Agda"><a id="4678" class="Keyword">abstract</a>
  <a id="wait"></a><a id="4689" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="4694" class="Symbol">:</a> <a id="4696" class="Symbol">{</a><a id="4697" href="blog/complexity-analysis/index.html#4697" class="Bound">n</a> <a id="4699" class="Symbol">:</a> <a id="4701" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4702" class="Symbol">}</a> <a id="4704" class="Symbol">→</a> <a id="4706" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4712" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="4714" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="4716" class="Symbol">→</a> <a id="4718" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="4724" class="Symbol">(</a><a id="4725" href="blog/complexity-analysis/index.html#4697" class="Bound">n</a> <a id="4727" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="4729" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a><a id="4730" class="Symbol">)</a> <a id="4732" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
  <a id="4736" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="4741" href="blog/complexity-analysis/index.html#4741" class="Bound">m</a> <a id="4743" class="Symbol">=</a> <a id="4745" href="blog/complexity-analysis/index.html#4741" class="Bound">m</a>
</pre>
<p>(the paper follows its own rules and ensures that we call <span class="Agda"><a href="blog/complexity-analysis/index.html#2897" class="Function Operator">!_</a></span> every time we <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span>, thus it comes with an extra <span class="Agda"><a href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a></span> in the type of <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span>. It gets confusing, so we’ll use this version instead.)</p>
<p>Unfortunately, the paper also plays fast and loose with its math. It’s fine, because the math is right, but the code presented in the paper doesn’t typecheck in Agda. As a workaround, we need to enable rewriting:</p>
<pre class="Agda"><a id="5196" class="Keyword">open</a> <a id="5201" class="Keyword">import</a> <a id="5208" href="Agda.Builtin.Equality.Rewrite.html" class="Module">Agda.Builtin.Equality.Rewrite</a>
<a id="5238" class="Symbol">{-#</a> <a id="5242" class="Keyword">REWRITE</a> <a id="5250" href="Data.Nat.Properties.html#12863" class="Function">+-suc</a> <a id="5256" href="Data.Nat.Properties.html#13227" class="Function">+-identityʳ</a> <a id="5268" class="Symbol">#-}</a>
</pre>
<p>We’ll also need to be able to lift equalities over the <code>Thunk</code> time bounds:</p>
<pre class="Agda"><a id="cast"></a><a id="5358" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5363" class="Symbol">:</a> <a id="5365" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="5367" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="5369" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="5371" class="Symbol">→</a> <a id="5373" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5379" href="blog/complexity-analysis/index.html#1893" class="Generalizable">m</a> <a id="5381" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5383" class="Symbol">→</a> <a id="5385" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5391" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="5393" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="5395" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5400" href="blog/complexity-analysis/index.html#5400" class="Bound">eq</a> <a id="5403" href="blog/complexity-analysis/index.html#5403" class="Bound">x</a> <a id="5405" class="Keyword">rewrite</a> <a id="5413" href="blog/complexity-analysis/index.html#5400" class="Bound">eq</a> <a id="5416" class="Symbol">=</a> <a id="5418" href="blog/complexity-analysis/index.html#5403" class="Bound">x</a>
</pre>
<p>Finally, we can write <span class="Agda"><a href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a></span>:</p>
<pre class="Agda"><a id="fmap"></a><a id="5467" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a>
  <a id="5474" class="Symbol">:</a> <a id="5476" class="Symbol">{</a><a id="5477" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a> <a id="5479" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5482" class="Symbol">:</a> <a id="5484" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="5485" class="Symbol">}</a>
  <a id="5489" class="Symbol">→</a> <a id="5491" class="Symbol">(</a><a id="5492" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5494" class="Symbol">→</a> <a id="5496" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5502" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5505" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a><a id="5506" class="Symbol">)</a>
  <a id="5510" class="Symbol">→</a> <a id="5512" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="5517" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="5519" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a> <a id="5521" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
  <a id="5525" class="Symbol">→</a> <a id="5527" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="5533" class="Symbol">(</a><a id="5534" class="Number">2</a> <a id="5536" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="5538" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a><a id="5540" class="Symbol">)</a> <a id="5542" class="Symbol">(</a><a id="5543" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="5548" href="blog/complexity-analysis/index.html#1883" class="Generalizable">b</a> <a id="5550" class="Symbol">(</a><a id="5551" class="Number">2</a> <a id="5553" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="5555" href="blog/complexity-analysis/index.html#5479" class="Bound">fc</a> <a id="5558" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="5560" href="blog/complexity-analysis/index.html#5477" class="Bound">c</a><a id="5561" class="Symbol">)</a> <a id="5563" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="5564" class="Symbol">)</a>
<a id="5566" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5571" href="blog/complexity-analysis/index.html#5571" class="Bound">f</a> <a id="5573" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="5576" class="Symbol">=</a> <a id="5578" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="5583" class="Symbol">(</a><a id="5584" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="5589" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a><a id="5591" class="Symbol">)</a>
<a id="5593" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5598" class="Symbol">{</a><a id="5599" class="Argument">c</a> <a id="5601" class="Symbol">=</a> <a id="5603" href="blog/complexity-analysis/index.html#5603" class="Bound">c</a><a id="5604" class="Symbol">}</a> <a id="5606" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a> <a id="5608" class="Symbol">(</a><a id="5609" href="blog/complexity-analysis/index.html#5609" class="Bound">x</a> <a id="5611" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="5613" href="blog/complexity-analysis/index.html#5613" class="Bound">xs</a><a id="5615" class="Symbol">)</a>
          <a id="5627" class="Symbol">=</a> <a id="5629" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="5631" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a> <a id="5633" href="blog/complexity-analysis/index.html#5609" class="Bound">x</a>
  <a id="5637" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="5641" class="Symbol">\</a><a id="5642" href="blog/complexity-analysis/index.html#5642" class="Bound">x&#39;</a> <a id="5645" class="Symbol">→</a> <a id="5647" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="5649" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="5654" class="Symbol">(</a><a id="5655" href="blog/complexity-analysis/index.html#5642" class="Bound">x&#39;</a> <a id="5658" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="5660" href="blog/complexity-analysis/index.html#5358" class="Function">cast</a> <a id="5665" class="Symbol">(</a><a id="5666" href="Data.Nat.Properties.html#13404" class="Function">+-comm</a> <a id="5673" href="blog/complexity-analysis/index.html#5603" class="Bound">c</a> <a id="5675" class="Symbol">_)</a> <a id="5678" class="Symbol">(</a><a id="5679" href="blog/complexity-analysis/index.html#5613" class="Bound">xs</a> <a id="5682" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="5686" href="blog/complexity-analysis/index.html#5467" class="Function">fmap</a> <a id="5691" href="blog/complexity-analysis/index.html#5606" class="Bound">f</a><a id="5692" class="Symbol">))</a>
</pre>
<p>This took me about an hour to write; I’m not convinced the approach here is as “lightweight” as claimed. Of particular challenge was figuring out the actual time bounds on this thing. The problem is that we usually reason about asymptotics via Big-O notation, which ignores all of these constant factors. What would be nicer is the hypothetical type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> {c fc <span class="op">:</span> ℕ}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  → (a → <span class="dt">Thunk</span> (<span class="dt">O</span> fc) b)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  → <span class="dt">VecL</span> a c n</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  → <span class="dt">Thunk</span> (<span class="dt">O</span> c) (<span class="dt">VecL</span> b (<span class="dt">O</span> (fc <span class="op">+</span> c)) n)</span></code></pre></div>
<p>where every thunk is now parameterized by <code>O x</code> saying our asymptotics are bounded by <code>x</code>. We’ll see about fleshing this idea out later. For now, we can power through on the paper, and write vector insertion. Let’s assume we have a constant time comparison function for <span class="Agda"><a href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a></span>:</p>
<pre class="Agda"><a id="6455" class="Keyword">postulate</a>
  <a id="_&lt;=_"></a><a id="6467" href="blog/complexity-analysis/index.html#6467" class="Postulate Operator">_&lt;=_</a> <a id="6472" class="Symbol">:</a> <a id="6474" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6476" class="Symbol">→</a> <a id="6478" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6480" class="Symbol">→</a> <a id="6482" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6488" class="Number">1</a> <a id="6490" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
</pre>
<p>First things first, we need another waiting function to inflate the times on every tail:</p>
<pre class="Agda"><a id="waitL"></a><a id="6594" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a>
    <a id="6604" class="Symbol">:</a> <a id="6606" class="Symbol">{</a><a id="6607" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a> <a id="6610" class="Symbol">:</a> <a id="6612" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="6613" class="Symbol">}</a> <a id="6615" class="Symbol">{</a><a id="6616" href="blog/complexity-analysis/index.html#6616" class="Bound">c</a> <a id="6618" class="Symbol">:</a> <a id="6620" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="6621" class="Symbol">}</a>
    <a id="6627" class="Symbol">→</a> <a id="6629" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="6634" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6636" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a> <a id="6639" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
    <a id="6645" class="Symbol">→</a> <a id="6647" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6653" class="Number">1</a> <a id="6655" class="Symbol">(</a><a id="6656" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="6661" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6663" class="Symbol">(</a><a id="6664" class="Number">2</a> <a id="6666" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="6668" href="blog/complexity-analysis/index.html#6616" class="Bound">c</a> <a id="6670" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="6672" href="blog/complexity-analysis/index.html#6607" class="Bound">c&#39;</a><a id="6674" class="Symbol">)</a> <a id="6676" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="6677" class="Symbol">)</a>
<a id="6679" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6685" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="6688" class="Symbol">=</a> <a id="6690" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6692" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6697" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a>
<a id="6700" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6706" class="Symbol">(</a><a id="6707" href="blog/complexity-analysis/index.html#6707" class="Bound">x</a> <a id="6709" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="6711" href="blog/complexity-analysis/index.html#6711" class="Bound">xs</a><a id="6713" class="Symbol">)</a> <a id="6715" class="Symbol">=</a> <a id="6717" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6719" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6724" class="Symbol">(</a><a id="6725" href="blog/complexity-analysis/index.html#6707" class="Bound">x</a> <a id="6727" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="6729" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="6734" class="Symbol">(</a><a id="6735" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="6741" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="6745" href="blog/complexity-analysis/index.html#6711" class="Bound">xs</a><a id="6747" class="Symbol">))</a>
</pre>
<p>and a helper version of <span class="Agda"><a href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a></span> which accounts in <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span>:</p>
<pre class="Agda"><a id="if_then_else_"></a><a id="6841" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a> <a id="6855" class="Symbol">:</a> <a id="6857" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a> <a id="6862" class="Symbol">→</a> <a id="6864" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6866" class="Symbol">→</a> <a id="6868" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="6870" class="Symbol">→</a> <a id="6872" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="6878" class="Number">1</a> <a id="6880" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="6882" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="6885" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a> <a id="6891" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="6896" href="blog/complexity-analysis/index.html#6896" class="Bound">t</a> <a id="6898" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="6903" href="blog/complexity-analysis/index.html#6903" class="Bound">f</a> <a id="6905" class="Symbol">=</a> <a id="6907" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6909" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6914" href="blog/complexity-analysis/index.html#6903" class="Bound">f</a>
<a id="6916" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="6919" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a>  <a id="6925" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="6930" href="blog/complexity-analysis/index.html#6930" class="Bound">t</a> <a id="6932" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="6937" href="blog/complexity-analysis/index.html#6937" class="Bound">f</a> <a id="6939" class="Symbol">=</a> <a id="6941" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="6943" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="6948" href="blog/complexity-analysis/index.html#6930" class="Bound">t</a>
<a id="6950" class="Keyword">infixr</a> <a id="6957" class="Number">2</a> <a id="6959" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if_then_else_</a>
</pre>
<p>we can thus write vector insertion:</p>
<pre class="Agda"><a id="insert"></a><a id="7019" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a>
    <a id="7030" class="Symbol">:</a> <a id="7032" class="Symbol">{</a><a id="7033" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a> <a id="7035" class="Symbol">:</a> <a id="7037" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="7038" class="Symbol">}</a>
    <a id="7044" class="Symbol">→</a> <a id="7046" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
    <a id="7052" class="Symbol">→</a> <a id="7054" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7059" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7061" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a> <a id="7063" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a>
    <a id="7069" class="Symbol">→</a> <a id="7071" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7077" class="Number">4</a> <a id="7079" class="Symbol">(</a><a id="7080" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7085" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7087" class="Symbol">(</a><a id="7088" class="Number">4</a> <a id="7090" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="7092" href="blog/complexity-analysis/index.html#7033" class="Bound">c</a><a id="7093" class="Symbol">)</a> <a id="7095" class="Symbol">(</a><a id="7096" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="7100" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7101" class="Symbol">))</a>
<a id="7104" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7111" href="blog/complexity-analysis/index.html#7111" class="Bound">x</a> <a id="7113" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="7116" class="Symbol">=</a> <a id="7118" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7123" class="Symbol">(</a><a id="7124" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7129" class="Symbol">(</a><a id="7130" href="blog/complexity-analysis/index.html#7111" class="Bound">x</a> <a id="7132" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7134" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7139" class="Symbol">(</a><a id="7140" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7145" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a><a id="7147" class="Symbol">)))</a>
<a id="7151" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7158" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7160" class="Symbol">(</a><a id="7161" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7163" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7165" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7167" class="Symbol">)</a>
         <a id="7178" class="Symbol">=</a> <a id="7180" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7182" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7184" href="blog/complexity-analysis/index.html#6467" class="Postulate Operator">&lt;=</a> <a id="7187" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a>
  <a id="7191" href="blog/complexity-analysis/index.html#2382" class="Function Operator">&gt;&gt;=</a> <a id="7195" class="Symbol">\</a><a id="7196" href="blog/complexity-analysis/index.html#7196" class="Bound">b</a> <a id="7198" class="Symbol">→</a> <a id="7200" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7202" href="blog/complexity-analysis/index.html#6841" class="Function Operator">if</a> <a id="7205" href="blog/complexity-analysis/index.html#7196" class="Bound">b</a> <a id="7207" href="blog/complexity-analysis/index.html#6841" class="Function Operator">then</a> <a id="7212" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7214" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7216" href="blog/complexity-analysis/index.html#4689" class="Function">wait</a> <a id="7221" class="Symbol">(</a><a id="7222" href="blog/complexity-analysis/index.html#6594" class="Function">waitL</a> <a id="7228" class="Symbol">(</a><a id="7229" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7231" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7233" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7235" class="Symbol">))</a>
                  <a id="7256" href="blog/complexity-analysis/index.html#6841" class="Function Operator">else</a> <a id="7261" href="blog/complexity-analysis/index.html#7161" class="Bound">y</a> <a id="7263" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7265" class="Symbol">(</a><a id="7266" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7273" href="blog/complexity-analysis/index.html#7158" class="Bound">x</a> <a id="7275" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="7279" href="blog/complexity-analysis/index.html#7165" class="Bound">ys</a><a id="7281" class="Symbol">)</a>
</pre>
<p>The obvious followup to <span class="Agda"><a href="blog/complexity-analysis/index.html#7019" class="Function">insert</a></span> is insertion <span class="Agda"><a href="blog/complexity-analysis/index.html#7410" class="Function">sort</a></span>:</p>
<pre class="Agda"><a id="7361" class="Keyword">open</a> <a id="7366" class="Keyword">import</a> <a id="7373" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="7382" class="Keyword">using</a> <a id="7388" class="Symbol">(</a><a id="7389" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a><a id="7392" class="Symbol">;</a> <a id="7394" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="7396" class="Symbol">;</a> <a id="7398" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">_∷_</a><a id="7401" class="Symbol">;</a> <a id="7403" href="Data.Vec.Base.html#1555" class="Function">tail</a><a id="7407" class="Symbol">)</a>

<a id="sort"></a><a id="7410" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7415" class="Symbol">:</a> <a id="7417" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="7421" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7423" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="7425" class="Symbol">→</a> <a id="7427" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7433" class="Symbol">(</a><a id="7434" class="Number">1</a> <a id="7436" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="7438" class="Number">5</a> <a id="7440" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="7442" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7443" class="Symbol">)</a> <a id="7445" class="Symbol">(</a><a id="7446" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7451" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7453" class="Symbol">(</a><a id="7454" class="Number">4</a> <a id="7456" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="7458" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7459" class="Symbol">)</a> <a id="7461" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7462" class="Symbol">)</a>
<a id="7464" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7469" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a> <a id="7472" class="Symbol">=</a> <a id="7474" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7476" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7481" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a>
<a id="7484" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7489" class="Symbol">(</a><a id="7490" href="blog/complexity-analysis/index.html#7490" class="Bound">x</a> <a id="7492" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="7494" href="blog/complexity-analysis/index.html#7494" class="Bound">xs</a><a id="7496" class="Symbol">)</a> <a id="7498" class="Symbol">=</a> <a id="7500" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7502" href="blog/complexity-analysis/index.html#7019" class="Function">insert</a> <a id="7509" href="blog/complexity-analysis/index.html#7490" class="Bound">x</a> <a id="7511" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="7515" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="7520" href="blog/complexity-analysis/index.html#7494" class="Bound">xs</a>
</pre>
<p>This thing looks linear, but insertion sort is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,</span> so what gives? The thing to notice is that the cost of each <em>tail</em> is linear, but we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> tails, so forcing the whole thing indeed works out to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span> We can now show <span class="Agda"><a href="blog/complexity-analysis/index.html#7804" class="Function">head</a></span> runs in constant time:</p>
<pre class="Agda"><a id="head"></a><a id="7804" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="7809" class="Symbol">:</a> <a id="7811" class="Symbol">{</a><a id="7812" href="blog/complexity-analysis/index.html#7812" class="Bound">c</a> <a id="7814" class="Symbol">:</a> <a id="7816" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="7817" class="Symbol">}</a> <a id="7819" class="Symbol">→</a> <a id="7821" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="7826" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7828" href="blog/complexity-analysis/index.html#7812" class="Bound">c</a> <a id="7830" class="Symbol">(</a><a id="7831" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="7835" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7836" class="Symbol">)</a> <a id="7838" class="Symbol">→</a> <a id="7840" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7846" class="Number">1</a> <a id="7848" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="7850" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="7855" class="Symbol">(</a><a id="7856" href="blog/complexity-analysis/index.html#7856" class="Bound">x</a> <a id="7858" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="7860" class="Symbol">_)</a> <a id="7863" class="Symbol">=</a> <a id="7865" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="7867" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="7872" href="blog/complexity-analysis/index.html#7856" class="Bound">x</a>
</pre>
<p>and that we can find the <span class="Agda"><a href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a></span> element in linear time:</p>
<pre class="Agda"><a id="minimum"></a><a id="7951" href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a> <a id="7959" class="Symbol">:</a> <a id="7961" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="7965" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="7967" class="Symbol">(</a><a id="7968" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="7972" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7973" class="Symbol">)</a> <a id="7975" class="Symbol">→</a> <a id="7977" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="7983" class="Symbol">(</a><a id="7984" class="Number">8</a> <a id="7986" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="7988" class="Number">5</a> <a id="7990" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="7992" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="7993" class="Symbol">)</a> <a id="7995" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="7997" href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a> <a id="8005" href="blog/complexity-analysis/index.html#8005" class="Bound">xs</a> <a id="8008" class="Symbol">=</a> <a id="8010" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8012" href="blog/complexity-analysis/index.html#7804" class="Function">head</a> <a id="8017" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8021" href="blog/complexity-analysis/index.html#7410" class="Function">sort</a> <a id="8026" href="blog/complexity-analysis/index.html#8005" class="Bound">xs</a>
</pre>
<p>Interestingly, Agda can figure out the bounds on <span class="Agda"><a href="blog/complexity-analysis/index.html#7951" class="Function">minimum</a></span> by itself, but not any of our other functions.</p>
<p>The paper goes on to show that we can define <span class="Agda"><a href="blog/complexity-analysis/index.html#8264" class="Function">last</a></span>, and then get a quadratic-time <code>maximum</code> using it:</p>
<pre class="Agda"><a id="last"></a><a id="8264" href="blog/complexity-analysis/index.html#8264" class="Function">last</a> <a id="8269" class="Symbol">:</a> <a id="8271" class="Symbol">{</a><a id="8272" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a> <a id="8274" class="Symbol">:</a> <a id="8276" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="8277" class="Symbol">}</a> <a id="8279" class="Symbol">→</a> <a id="8281" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="8286" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8288" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a> <a id="8290" class="Symbol">(</a><a id="8291" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="8295" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a><a id="8296" class="Symbol">)</a> <a id="8298" class="Symbol">→</a> <a id="8300" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="8306" class="Symbol">(</a><a id="8307" class="Number">1</a> <a id="8309" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="8311" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="8315" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8317" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="8319" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="8323" href="blog/complexity-analysis/index.html#8272" class="Bound">c</a><a id="8324" class="Symbol">)</a> <a id="8326" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
<a id="8328" href="blog/complexity-analysis/index.html#8264" class="Function">last</a> <a id="8333" class="Symbol">(</a><a id="8334" href="blog/complexity-analysis/index.html#8334" class="Bound">x</a> <a id="8336" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="8338" href="blog/complexity-analysis/index.html#8338" class="Bound">xs</a><a id="8340" class="Symbol">)</a> <a id="8342" class="Symbol">=</a> <a id="8344" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8346" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8352" href="blog/complexity-analysis/index.html#8334" class="Bound">x</a> <a id="8354" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8358" href="blog/complexity-analysis/index.html#8338" class="Bound">xs</a>
  <a id="8363" class="Keyword">where</a>
    <a id="8373" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8379" class="Symbol">:</a> <a id="8381" class="Symbol">{</a><a id="8382" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a> <a id="8384" class="Symbol">:</a> <a id="8386" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="8387" class="Symbol">}</a> <a id="8389" class="Symbol">→</a> <a id="8391" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8393" class="Symbol">→</a> <a id="8395" href="blog/complexity-analysis/index.html#4379" class="Datatype">VecL</a> <a id="8400" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a> <a id="8402" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a> <a id="8404" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8406" class="Symbol">→</a> <a id="8408" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="8414" class="Symbol">(</a><a id="8415" class="Number">1</a> <a id="8417" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="8419" href="blog/complexity-analysis/index.html#1895" class="Generalizable">n</a> <a id="8421" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="8423" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="8427" href="blog/complexity-analysis/index.html#8382" class="Bound">c</a><a id="8428" class="Symbol">)</a> <a id="8430" href="blog/complexity-analysis/index.html#1881" class="Generalizable">a</a>
    <a id="8436" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8442" href="blog/complexity-analysis/index.html#8442" class="Bound">a</a> <a id="8444" href="blog/complexity-analysis/index.html#4420" class="InductiveConstructor">[]</a> <a id="8447" class="Symbol">=</a> <a id="8449" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8451" href="blog/complexity-analysis/index.html#2328" class="Function">pure</a> <a id="8456" href="blog/complexity-analysis/index.html#8442" class="Bound">a</a>
    <a id="8462" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8468" class="Symbol">_</a> <a id="8470" class="Symbol">(</a><a id="8471" href="blog/complexity-analysis/index.html#8471" class="Bound">x</a> <a id="8473" href="blog/complexity-analysis/index.html#4438" class="InductiveConstructor Operator">∷</a> <a id="8475" href="blog/complexity-analysis/index.html#8475" class="Bound">xs</a><a id="8477" class="Symbol">)</a> <a id="8479" class="Symbol">=</a> <a id="8481" href="blog/complexity-analysis/index.html#2897" class="Function Operator">!</a> <a id="8483" href="blog/complexity-analysis/index.html#8373" class="Function">last&#39;</a> <a id="8489" href="blog/complexity-analysis/index.html#8471" class="Bound">x</a> <a id="8491" href="blog/complexity-analysis/index.html#2472" class="Function Operator">=&lt;&lt;</a> <a id="8495" href="blog/complexity-analysis/index.html#8475" class="Bound">xs</a>
</pre>
<p>Trying to define <code>maximum</code> makes Agda spin, probably because of one of my rewrite rules. But here’s what it should be:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> <span class="op">:</span> <span class="dt">Vec</span> a (suc n) → <span class="dt">Thunk</span> (<span class="dv">13</span> <span class="op">+</span> <span class="dv">14</span> <span class="op">*</span> n <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> n <span class="op">^</span> <span class="dv">2</span>) a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">maximum</span> xs <span class="ot">=</span> <span class="op">!</span> <span class="fu">last</span> <span class="op">=&lt;&lt;</span> <span class="fu">sort</span> xs</span></code></pre></div>
<p>The paper goes on to say some thinks about partially evaluating thunks, and then shows its use to measure some popular libraries. But I’m more interested in making the experience better.</p>
<h2 id="extra-curricular-big-o"><a href="#extra-curricular-big-o" class="header-link">Extra-curricular Big O<span class="header-link-emoji">🔗</span></a></h2>
<p>Clearly this is all too much work. When we do complexity analysis by hand, we are primarily concerned with <em>complexity classes,</em> not exact numbers of steps. How hard would it be to generalize all of this so that <code>Thunk</code> takes a function bounding the runtime necessary to produce its value?</p>
<p>First, a quick refresher on what big-O means. A function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">f : \mathbb{N} \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> is said to be in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo>→</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">g : \mathbb{N} \to \mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> iff:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∃</mi><mo stretchy="false">(</mo><mi>C</mi><mi>k</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>n</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>C</mi><mo>⋅</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\exists (C k : \mathbb{N}). \forall (n : \mathbb{N}, k \leq n). f(n) \leq C \cdot g(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∃</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mclose">)</span><span class="mord">.∀</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>That is, there is some point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> at which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> stays above <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>.</span> This is the formal definition, but in practice we usually play rather fast and loose with our notation. For example, we say “quicksort is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span> in the length of the list”, or “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot\log{m})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">m</span></span><span class="mclose">)</span></span></span></span> , where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> is the size of the first argument.”</p>
<p>We need to do a bit of elaboration here to turn these informal statements into a formal claim. In both cases, there should are implicit binders inside the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(-)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">−</span><span class="mclose">)</span></span></span></span>,</span> binding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> in the first, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span></span></span></span> in the second. These functions then get instantiated with the actual sizes of the lists. It’s a subtle point, but it needs to be kept in mind.</p>
<p>The other question is how the hell do we generalize that definition to multiple variables? Easy! We replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>:</mo><mi mathvariant="double-struck">N</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n : \mathbb{N}, k \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbb">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> with a vector of natural numbers, subject to the constraint that they’re <em>all</em> bigger than <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.</span></p>
<p>OK, let’s write some code. We can give the definition of <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>:</p>
<pre class="Agda"><a id="10468" class="Keyword">open</a> <a id="10473" class="Keyword">import</a> <a id="10480" href="Data.Vec.Relation.Unary.All.html" class="Module">Data.Vec.Relation.Unary.All</a>
    <a id="10512" class="Keyword">using</a> <a id="10518" class="Symbol">(</a><a id="10519" href="Data.Vec.Relation.Unary.All.html#1082" class="Datatype">All</a><a id="10522" class="Symbol">;</a> <a id="10524" href="Data.Vec.Relation.Unary.All.html#1174" class="InductiveConstructor Operator">_∷_</a><a id="10527" class="Symbol">;</a> <a id="10529" href="Data.Vec.Relation.Unary.All.html#1157" class="InductiveConstructor">[]</a><a id="10531" class="Symbol">)</a>
    <a id="10537" class="Keyword">renaming</a> <a id="10546" class="Symbol">(</a><a id="10547" href="Data.Vec.Relation.Unary.All.html#1456" class="Function">tail</a> <a id="10552" class="Symbol">to</a> <a id="10555" class="Function">tailAll</a><a id="10562" class="Symbol">)</a>

<a id="10565" class="Keyword">record</a> <a id="O"></a><a id="10572" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="10574" class="Symbol">{</a><a id="10575" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a> <a id="10580" class="Symbol">:</a> <a id="10582" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="10583" class="Symbol">}</a> <a id="10585" class="Symbol">(</a><a id="10586" href="blog/complexity-analysis/index.html#10586" class="Bound">g</a> <a id="10588" class="Symbol">:</a> <a id="10590" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="10594" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10596" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a>  <a id="10602" class="Symbol">→</a> <a id="10604" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="10605" class="Symbol">)</a> <a id="10607" class="Symbol">:</a> <a id="10609" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="10613" class="Keyword">where</a>
  <a id="10621" class="Keyword">field</a>
    <a id="O.f"></a><a id="10631" href="blog/complexity-analysis/index.html#10631" class="Field">f</a> <a id="10633" class="Symbol">:</a> <a id="10635" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="10639" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10641" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a> <a id="10646" class="Symbol">→</a> <a id="10648" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
    <a id="O.C"></a><a id="10654" href="blog/complexity-analysis/index.html#10654" class="Field">C</a> <a id="10656" class="Symbol">:</a> <a id="10658" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
    <a id="O.k"></a><a id="10664" href="blog/complexity-analysis/index.html#10664" class="Field">k</a> <a id="10666" class="Symbol">:</a> <a id="10668" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
    <a id="O.def"></a><a id="10674" href="blog/complexity-analysis/index.html#10674" class="Field">def</a> <a id="10678" class="Symbol">:</a> <a id="10680" class="Symbol">(</a><a id="10681" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10683" class="Symbol">:</a> <a id="10685" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="10689" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10691" href="blog/complexity-analysis/index.html#10575" class="Bound">vars</a><a id="10695" class="Symbol">)</a> <a id="10697" class="Symbol">→</a> <a id="10699" href="Data.Vec.Relation.Unary.All.html#1082" class="Datatype">All</a> <a id="10703" class="Symbol">(</a><a id="10704" href="blog/complexity-analysis/index.html#10664" class="Field">k</a> <a id="10706" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤_</a><a id="10708" class="Symbol">)</a> <a id="10710" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10712" class="Symbol">→</a> <a id="10714" href="blog/complexity-analysis/index.html#10631" class="Field">f</a> <a id="10716" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a> <a id="10718" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤</a> <a id="10720" href="blog/complexity-analysis/index.html#10654" class="Field">C</a> <a id="10722" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="10724" href="blog/complexity-analysis/index.html#10586" class="Bound">g</a> <a id="10726" href="blog/complexity-analysis/index.html#10681" class="Bound">n</a>
</pre>
<p>The generality of <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> is a bit annoying for the common case of being a function over one variable, so we can introduce a helper function <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span>:</p>
<pre class="Agda"><a id="hoist"></a><a id="10895" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10901" class="Symbol">:</a> <a id="10903" class="Symbol">{</a><a id="10904" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10906" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a> <a id="10908" class="Symbol">:</a> <a id="10910" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="10913" class="Symbol">}</a> <a id="10915" class="Symbol">→</a> <a id="10917" class="Symbol">(</a><a id="10918" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10920" class="Symbol">→</a> <a id="10922" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a><a id="10923" class="Symbol">)</a> <a id="10925" class="Symbol">→</a> <a id="10927" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="10931" href="blog/complexity-analysis/index.html#10904" class="Bound">a</a> <a id="10933" class="Number">1</a> <a id="10935" class="Symbol">→</a> <a id="10937" href="blog/complexity-analysis/index.html#10906" class="Bound">b</a>
<a id="10939" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10945" href="blog/complexity-analysis/index.html#10945" class="Bound">f</a> <a id="10947" class="Symbol">(</a><a id="10948" href="blog/complexity-analysis/index.html#10948" class="Bound">x</a> <a id="10950" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="10952" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="10954" class="Symbol">)</a> <a id="10956" class="Symbol">=</a> <a id="10958" href="blog/complexity-analysis/index.html#10945" class="Bound">f</a> <a id="10960" href="blog/complexity-analysis/index.html#10948" class="Bound">x</a>

<a id="O&#39;"></a><a id="10963" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="10966" class="Symbol">:</a> <a id="10968" class="Symbol">(</a><a id="10969" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="10971" class="Symbol">→</a> <a id="10973" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="10974" class="Symbol">)</a> <a id="10976" class="Symbol">→</a> <a id="10978" href="Agda.Primitive.html#320" class="Primitive">Set</a>
<a id="10982" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="10985" href="blog/complexity-analysis/index.html#10985" class="Bound">f</a> <a id="10987" class="Symbol">=</a> <a id="10989" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="10991" class="Symbol">(</a><a id="10992" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="10998" href="blog/complexity-analysis/index.html#10985" class="Bound">f</a><a id="10999" class="Symbol">)</a>
</pre>
<p>We can trivially lift any function <code>f</code> into <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> <code>f</code>:</p>
<pre class="Agda"><a id="O-build"></a><a id="11071" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11079" class="Symbol">:</a> <a id="11081" class="Symbol">{</a><a id="11082" href="blog/complexity-analysis/index.html#11082" class="Bound">vars</a> <a id="11087" class="Symbol">:</a> <a id="11089" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="11090" class="Symbol">}</a> <a id="11092" class="Symbol">→</a> <a id="11094" class="Symbol">(</a><a id="11095" href="blog/complexity-analysis/index.html#11095" class="Bound">f</a> <a id="11097" class="Symbol">:</a> <a id="11099" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="11103" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11105" href="blog/complexity-analysis/index.html#11082" class="Bound">vars</a> <a id="11110" class="Symbol">→</a> <a id="11112" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="11113" class="Symbol">)</a> <a id="11115" class="Symbol">→</a> <a id="11117" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11119" href="blog/complexity-analysis/index.html#11095" class="Bound">f</a>
<a id="11121" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11129" href="blog/complexity-analysis/index.html#11129" class="Bound">f</a> <a id="11131" class="Symbol">.</a><a id="11132" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11136" class="Symbol">=</a> <a id="11138" href="blog/complexity-analysis/index.html#11129" class="Bound">f</a>
<a id="11140" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11148" href="blog/complexity-analysis/index.html#11148" class="Bound">f</a> <a id="11150" class="Symbol">.</a><a id="11151" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11155" class="Symbol">=</a> <a id="11157" class="Number">1</a>
<a id="11159" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11167" href="blog/complexity-analysis/index.html#11167" class="Bound">f</a> <a id="11169" class="Symbol">.</a><a id="11170" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11174" class="Symbol">=</a> <a id="11176" class="Number">0</a>
<a id="11178" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="11186" href="blog/complexity-analysis/index.html#11186" class="Bound">f</a> <a id="11188" class="Symbol">.</a><a id="11189" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11195" href="blog/complexity-analysis/index.html#11195" class="Bound">n</a> <a id="11197" href="blog/complexity-analysis/index.html#11197" class="Bound">x</a> <a id="11199" class="Symbol">=</a> <a id="11201" href="Data.Nat.Properties.html#4574" class="Function">≤-refl</a>
</pre>
<p>and also trivially weaken an <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> into using more variables:</p>
<pre class="Agda"><a id="O-weaken"></a><a id="11285" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11294" class="Symbol">:</a> <a id="11296" class="Symbol">∀</a> <a id="11298" class="Symbol">{</a><a id="11299" href="blog/complexity-analysis/index.html#11299" class="Bound">vars</a><a id="11303" class="Symbol">}</a> <a id="11305" class="Symbol">{</a><a id="11306" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11308" class="Symbol">:</a> <a id="11310" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="11314" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="11316" href="blog/complexity-analysis/index.html#11299" class="Bound">vars</a> <a id="11321" class="Symbol">→</a> <a id="11323" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="11324" class="Symbol">}</a> <a id="11326" class="Symbol">→</a> <a id="11328" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11330" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11332" class="Symbol">→</a> <a id="11334" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="11336" class="Symbol">(</a><a id="11337" href="blog/complexity-analysis/index.html#11306" class="Bound">f</a> <a id="11339" href="Function.Base.html#1040" class="Function Operator">∘</a> <a id="11341" href="Data.Vec.Base.html#1555" class="Function">tail</a><a id="11345" class="Symbol">)</a>
<a id="11347" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11356" href="blog/complexity-analysis/index.html#11356" class="Bound">o</a> <a id="11358" class="Symbol">.</a><a id="11359" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11363" class="Symbol">=</a> <a id="11365" href="blog/complexity-analysis/index.html#11356" class="Bound">o</a> <a id="11367" class="Symbol">.</a><a id="11368" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11372" href="Function.Base.html#1040" class="Function Operator">∘</a> <a id="11374" href="Data.Vec.Base.html#1555" class="Function">tail</a>
<a id="11379" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11388" href="blog/complexity-analysis/index.html#11388" class="Bound">o</a> <a id="11390" class="Symbol">.</a><a id="11391" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11395" class="Symbol">=</a> <a id="11397" href="blog/complexity-analysis/index.html#11388" class="Bound">o</a> <a id="11399" class="Symbol">.</a><a id="11400" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a>
<a id="11404" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11413" href="blog/complexity-analysis/index.html#11413" class="Bound">o</a> <a id="11415" class="Symbol">.</a><a id="11416" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11420" class="Symbol">=</a> <a id="11422" href="blog/complexity-analysis/index.html#11413" class="Bound">o</a> <a id="11424" class="Symbol">.</a><a id="11425" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a>
<a id="11429" href="blog/complexity-analysis/index.html#11285" class="Function">O-weaken</a> <a id="11438" href="blog/complexity-analysis/index.html#11438" class="Bound">o</a> <a id="11440" class="Symbol">.</a><a id="11441" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11447" class="Symbol">(_</a> <a id="11450" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="11452" href="blog/complexity-analysis/index.html#11452" class="Bound">x</a><a id="11453" class="Symbol">)</a> <a id="11455" class="Symbol">(_</a> <a id="11458" href="Data.Vec.Relation.Unary.All.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11460" href="blog/complexity-analysis/index.html#11460" class="Bound">eq</a><a id="11462" class="Symbol">)</a> <a id="11464" class="Symbol">=</a> <a id="11466" href="blog/complexity-analysis/index.html#11438" class="Bound">o</a> <a id="11468" class="Symbol">.</a><a id="11469" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11475" href="blog/complexity-analysis/index.html#11452" class="Bound">x</a> <a id="11477" href="blog/complexity-analysis/index.html#11460" class="Bound">eq</a>
</pre>
<p>More interestingly, we can lift a given <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span> into a higher power, witnessing the fact that eg, something of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> is also <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>:</span></p>
<pre class="Agda"><a id="O-^-suc"></a><a id="11632" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11640" class="Symbol">:</a> <a id="11642" class="Symbol">{</a><a id="11643" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a> <a id="11645" class="Symbol">:</a> <a id="11647" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="11648" class="Symbol">}</a> <a id="11650" class="Symbol">→</a> <a id="11652" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="11655" class="Symbol">(</a><a id="11656" href="Data.Nat.Base.html#3480" class="Function Operator">_^</a> <a id="11659" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a><a id="11660" class="Symbol">)</a> <a id="11662" class="Symbol">→</a> <a id="11664" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="11667" class="Symbol">(</a><a id="11668" href="Data.Nat.Base.html#3480" class="Function Operator">_^</a> <a id="11671" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="11675" href="blog/complexity-analysis/index.html#11643" class="Bound">n</a><a id="11676" class="Symbol">)</a>
<a id="11678" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11686" href="blog/complexity-analysis/index.html#11686" class="Bound">o</a> <a id="11688" class="Symbol">.</a><a id="11689" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="11693" class="Symbol">=</a> <a id="11695" href="blog/complexity-analysis/index.html#11686" class="Bound">o</a> <a id="11697" class="Symbol">.</a><a id="11698" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a>
<a id="11702" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11710" href="blog/complexity-analysis/index.html#11710" class="Bound">o</a> <a id="11712" class="Symbol">.</a><a id="11713" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a> <a id="11717" class="Symbol">=</a> <a id="11719" href="blog/complexity-analysis/index.html#11710" class="Bound">o</a> <a id="11721" class="Symbol">.</a><a id="11722" href="blog/complexity-analysis/index.html#10654" class="Field">O.C</a>
<a id="11726" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11734" href="blog/complexity-analysis/index.html#11734" class="Bound">o</a> <a id="11736" class="Symbol">.</a><a id="11737" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a> <a id="11741" class="Symbol">=</a> <a id="11743" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="11747" class="Symbol">(</a><a id="11748" href="blog/complexity-analysis/index.html#11734" class="Bound">o</a> <a id="11750" class="Symbol">.</a><a id="11751" href="blog/complexity-analysis/index.html#10664" class="Field">O.k</a><a id="11754" class="Symbol">)</a>
<a id="11756" href="blog/complexity-analysis/index.html#11632" class="Function">O-^-suc</a> <a id="11764" class="Symbol">{</a><a id="11765" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11766" class="Symbol">}</a> <a id="11768" href="blog/complexity-analysis/index.html#11768" class="Bound">o</a> <a id="11770" class="Symbol">.</a><a id="11771" href="blog/complexity-analysis/index.html#10674" class="Field">O.def</a> <a id="11777" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a><a id="11779" class="Symbol">@(</a><a id="11781" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11783" href="Data.Vec.Base.html#1062" class="InductiveConstructor Operator">∷</a> <a id="11785" href="Data.Vec.Base.html#1043" class="InductiveConstructor">[]</a><a id="11787" class="Symbol">)</a> <a id="11789" href="blog/complexity-analysis/index.html#11789" class="Bound">ps</a><a id="11791" class="Symbol">@(</a><a id="11793" href="Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="11797" href="blog/complexity-analysis/index.html#11797" class="Bound">px</a> <a id="11800" href="Data.Vec.Relation.Unary.All.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11802" href="Data.Vec.Relation.Unary.All.html#1157" class="InductiveConstructor">[]</a><a id="11804" class="Symbol">)</a> <a id="11806" class="Symbol">=</a>
  <a id="11810" href="Relation.Binary.Reasoning.Base.Triple.html#3019" class="Function Operator">begin</a>
    <a id="11820" href="blog/complexity-analysis/index.html#10631" class="Function">f</a> <a id="11822" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a>               <span class="reasoning-step"><span class="as-written Function"><a id="11839" href="Relation.Binary.Reasoning.Base.Triple.html#3754" class="Function">≤⟨</a> <a id="11842" href="blog/complexity-analysis/index.html#10674" class="Function">def</a> <a id="11846" href="blog/complexity-analysis/index.html#11777" class="Bound">xs</a> <a id="11849" class="Symbol">(</a><a id="11850" href="Data.Nat.Properties.html#7191" class="Function">≤-step</a> <a id="11857" href="blog/complexity-analysis/index.html#11797" class="Bound">px</a> <a id="11860" href="Data.Vec.Relation.Unary.All.html#1174" class="InductiveConstructor Operator">∷</a> <a id="11862" href="Data.Vec.Relation.Unary.All.html#1157" class="InductiveConstructor">[]</a><a id="11864" class="Symbol">)</a> <a id="11866" href="Relation.Binary.Reasoning.Base.Triple.html#3754" class="Function">⟩</a></span><span class="alternate Function">≤</span></span>
    <a id="11872" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11874" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="11876" class="Symbol">(</a><a id="11877" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11879" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="11881" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11882" class="Symbol">)</a>        <span class="reasoning-step"><span class="as-written Function"><a id="11891" href="Relation.Binary.Reasoning.Base.Triple.html#3754" class="Function">≤⟨</a> <a id="11894" href="Data.Nat.Properties.html#25330" class="Function">*-monoˡ-≤</a> <a id="11904" class="Symbol">(</a><a id="11905" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11907" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="11909" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11910" class="Symbol">)</a> <a id="11912" class="Symbol">(</a><a id="11913" href="Data.Nat.Properties.html#26043" class="Function">m≤m*n</a> <a id="11919" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11921" class="Symbol">(</a><a id="11922" href="Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="11926" href="Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="11929" class="Symbol">))</a> <a id="11932" href="Relation.Binary.Reasoning.Base.Triple.html#3754" class="Function">⟩</a></span><span class="alternate Function">≤</span></span>
    <a id="11938" class="Symbol">(</a><a id="11939" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11941" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="11943" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a><a id="11944" class="Symbol">)</a> <a id="11946" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="11948" class="Symbol">(</a><a id="11949" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11951" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="11953" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11954" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function"><a id="11957" href="Relation.Binary.Reasoning.Base.Triple.html#4527" class="Function">≡⟨</a> <a id="11960" href="Data.Nat.Properties.html#21055" class="Function">*-assoc</a> <a id="11968" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11970" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11972" class="Symbol">(</a><a id="11973" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11975" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="11977" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="11978" class="Symbol">)</a> <a id="11980" href="Relation.Binary.Reasoning.Base.Triple.html#4527" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="11986" href="blog/complexity-analysis/index.html#10654" class="Function">C</a> <a id="11988" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="11990" class="Symbol">(</a><a id="11991" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11993" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="11995" class="Symbol">(</a><a id="11996" href="blog/complexity-analysis/index.html#11781" class="Bound">x</a> <a id="11998" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12000" href="blog/complexity-analysis/index.html#11765" class="Bound">n</a><a id="12001" class="Symbol">))</a>
  <a id="12006" href="Relation.Binary.Reasoning.Base.Triple.html#5128" class="Function Operator">∎</a>
  <a id="12010" class="Keyword">where</a>
    <a id="12020" class="Keyword">open</a> <a id="12025" href="blog/complexity-analysis/index.html#10572" class="Module">O</a> <a id="12027" href="blog/complexity-analysis/index.html#11768" class="Bound">o</a>
    <a id="12033" class="Keyword">open</a> <a id="12038" href="Data.Nat.Properties.html#12487" class="Module">≤-Reasoning</a>
</pre>
<p>However, the challenge is and has always been to simplify the construction of <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> bounds. Thus, we’d like the ability to remove low-order terms from <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>s. We can do this by eliminating <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> whenever there is a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup></mrow><annotation encoding="application/x-tex">n^{k&#39;}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9425em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9425em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> term around with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><msup><mi>k</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">k \leq k&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>:</span></p>
<pre class="Agda"><a id="12328" class="Keyword">postulate</a>
  <a id="O-drop-low"></a><a id="12340" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a>
    <a id="12355" class="Symbol">:</a> <a id="12357" class="Symbol">{</a><a id="12358" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12360" href="blog/complexity-analysis/index.html#12360" class="Bound">x</a> <a id="12362" href="blog/complexity-analysis/index.html#12362" class="Bound">y</a> <a id="12364" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12366" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a> <a id="12369" class="Symbol">:</a> <a id="12371" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="12372" class="Symbol">}</a>
    <a id="12378" class="Symbol">→</a> <a id="12380" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12382" href="Data.Nat.Base.html#1544" class="Datatype Operator">≤</a> <a id="12384" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a>
    <a id="12391" class="Symbol">→</a> <a id="12393" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12396" class="Symbol">(\</a><a id="12398" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12400" class="Symbol">→</a> <a id="12402" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12404" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="12406" href="blog/complexity-analysis/index.html#12360" class="Bound">x</a> <a id="12408" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="12410" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12412" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12414" href="blog/complexity-analysis/index.html#12364" class="Bound">k</a> <a id="12416" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="12418" href="blog/complexity-analysis/index.html#12362" class="Bound">y</a> <a id="12420" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="12422" href="blog/complexity-analysis/index.html#12398" class="Bound">n</a> <a id="12424" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12426" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a><a id="12428" class="Symbol">)</a>
    <a id="12434" class="Symbol">→</a> <a id="12436" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12439" class="Symbol">(\</a><a id="12441" href="blog/complexity-analysis/index.html#12441" class="Bound">n</a> <a id="12443" class="Symbol">→</a> <a id="12445" href="blog/complexity-analysis/index.html#12358" class="Bound">z</a> <a id="12447" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="12449" href="blog/complexity-analysis/index.html#12441" class="Bound">n</a> <a id="12451" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12453" href="blog/complexity-analysis/index.html#12366" class="Bound">k&#39;</a><a id="12455" class="Symbol">)</a>
</pre>
<p>The <code>z</code> variable here lets us compose <span class="Agda"><a href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a></span> terms, by subsequently instantiating</p>
<p>As a special case, we can eliminate constant terms via <span class="Agda"><a href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a></span> by first expanding constant terms to be coefficients of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">n^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>:</span></p>
<pre class="Agda"><a id="O-drop-1"></a><a id="12701" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a>
  <a id="12712" class="Symbol">:</a> <a id="12714" class="Symbol">{</a><a id="12715" href="blog/complexity-analysis/index.html#12715" class="Bound">x</a> <a id="12717" href="blog/complexity-analysis/index.html#12717" class="Bound">y</a> <a id="12719" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a> <a id="12721" class="Symbol">:</a> <a id="12723" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="12724" class="Symbol">}</a>
  <a id="12728" class="Symbol">→</a> <a id="12730" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12733" class="Symbol">(\</a><a id="12735" href="blog/complexity-analysis/index.html#12735" class="Bound">n</a> <a id="12737" class="Symbol">→</a> <a id="12739" href="blog/complexity-analysis/index.html#12715" class="Bound">x</a> <a id="12741" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="12743" href="blog/complexity-analysis/index.html#12717" class="Bound">y</a> <a id="12745" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="12747" href="blog/complexity-analysis/index.html#12735" class="Bound">n</a> <a id="12749" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12751" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a><a id="12752" class="Symbol">)</a>
  <a id="12756" class="Symbol">→</a> <a id="12758" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12761" class="Symbol">(\</a><a id="12763" href="blog/complexity-analysis/index.html#12763" class="Bound">n</a> <a id="12765" class="Symbol">→</a> <a id="12767" href="blog/complexity-analysis/index.html#12763" class="Bound">n</a> <a id="12769" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="12771" href="blog/complexity-analysis/index.html#12719" class="Bound">k</a><a id="12772" class="Symbol">)</a>
<a id="12774" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="12783" class="Symbol">{</a><a id="12784" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12785" class="Symbol">}</a> <a id="12787" class="Symbol">{</a><a id="12788" href="blog/complexity-analysis/index.html#12788" class="Bound">y</a><a id="12789" class="Symbol">}</a> <a id="12791" class="Symbol">{</a><a id="12792" href="blog/complexity-analysis/index.html#12792" class="Bound">k</a><a id="12793" class="Symbol">}</a> <a id="12795" href="blog/complexity-analysis/index.html#12795" class="Bound">o</a> <a id="12797" class="Keyword">rewrite</a> <a id="12805" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="12809" class="Symbol">(</a><a id="12810" href="Data.Nat.Properties.html#20019" class="Function">*-identityʳ</a> <a id="12822" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12823" class="Symbol">)</a> <a id="12825" class="Symbol">=</a>
  <a id="12829" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a> <a id="12840" class="Symbol">{</a><a id="12841" class="Number">0</a><a id="12842" class="Symbol">}</a> <a id="12844" class="Symbol">{</a><a id="12845" href="blog/complexity-analysis/index.html#12784" class="Bound">x</a><a id="12846" class="Symbol">}</a> <a id="12848" class="Symbol">{</a><a id="12849" href="blog/complexity-analysis/index.html#12788" class="Bound">y</a><a id="12850" class="Symbol">}</a> <a id="12852" class="Symbol">{</a><a id="12853" class="Argument">k</a> <a id="12855" class="Symbol">=</a> <a id="12857" class="Number">0</a><a id="12858" class="Symbol">}</a> <a id="12860" class="Symbol">{</a><a id="12861" href="blog/complexity-analysis/index.html#12792" class="Bound">k</a><a id="12862" class="Symbol">}</a> <a id="12864" href="Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a> <a id="12868" href="blog/complexity-analysis/index.html#12795" class="Bound">o</a>
</pre>
<p>With these functions, we can now easily construct <span class="Agda"><a href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a></span> values for arbitrary one-variable functions:</p>
<pre class="Agda"><a id="12987" href="blog/complexity-analysis/index.html#12987" class="Function">_</a> <a id="12989" class="Symbol">:</a> <a id="12991" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="12994" class="Symbol">(</a><a id="12995" href="Data.Nat.Base.html#3480" class="Function Operator">_^</a> <a id="12998" class="Number">1</a><a id="12999" class="Symbol">)</a>
<a id="13001" class="Symbol">_</a> <a id="13003" class="Symbol">=</a> <a id="13005" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="13014" class="Symbol">{</a><a id="13015" class="Number">4</a><a id="13016" class="Symbol">}</a> <a id="13018" class="Symbol">{</a><a id="13019" class="Number">5</a><a id="13020" class="Symbol">}</a> <a id="13022" class="Symbol">{</a><a id="13023" class="Number">1</a><a id="13024" class="Symbol">}</a> <a id="13026" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="13028" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="13036" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="13038" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13044" class="Symbol">\</a><a id="13045" href="blog/complexity-analysis/index.html#13045" class="Bound">n</a> <a id="13047" class="Symbol">→</a> <a id="13049" class="Number">4</a> <a id="13051" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="13053" class="Number">5</a> <a id="13055" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="13057" href="blog/complexity-analysis/index.html#13045" class="Bound">n</a> <a id="13059" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="13061" class="Number">1</a>

<a id="13064" href="blog/complexity-analysis/index.html#13064" class="Function">_</a> <a id="13066" class="Symbol">:</a> <a id="13068" href="blog/complexity-analysis/index.html#10963" class="Function">O&#39;</a> <a id="13071" class="Symbol">(</a><a id="13072" href="Data.Nat.Base.html#3480" class="Function Operator">_^</a> <a id="13075" class="Number">2</a><a id="13076" class="Symbol">)</a>
<a id="13078" class="Symbol">_</a> <a id="13080" class="Symbol">=</a> <a id="13082" href="blog/complexity-analysis/index.html#12701" class="Function">O-drop-1</a> <a id="13091" class="Symbol">{</a><a id="13092" class="Number">4</a><a id="13093" class="Symbol">}</a> <a id="13095" class="Symbol">{</a><a id="13096" class="Number">1</a><a id="13097" class="Symbol">}</a> <a id="13099" class="Symbol">{</a><a id="13100" class="Number">2</a><a id="13101" class="Symbol">}</a>
  <a id="13105" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="13107" href="blog/complexity-analysis/index.html#12340" class="Postulate">O-drop-low</a> <a id="13118" class="Symbol">{</a><a id="13119" class="Number">4</a><a id="13120" class="Symbol">}</a> <a id="13122" class="Symbol">{</a><a id="13123" class="Number">5</a><a id="13124" class="Symbol">}</a> <a id="13126" class="Symbol">{</a><a id="13127" class="Number">3</a><a id="13128" class="Symbol">}</a> <a id="13130" class="Symbol">{</a><a id="13131" class="Number">1</a><a id="13132" class="Symbol">}</a> <a id="13134" class="Symbol">{</a><a id="13135" class="Number">2</a><a id="13136" class="Symbol">}</a> <a id="13138" class="Symbol">(</a><a id="13139" href="Data.Nat.Base.html#1609" class="InductiveConstructor">s≤s</a> <a id="13143" href="Data.Nat.Base.html#1567" class="InductiveConstructor">z≤n</a><a id="13146" class="Symbol">)</a>
  <a id="13150" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="13152" href="blog/complexity-analysis/index.html#11071" class="Function">O-build</a> <a id="13160" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="13162" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13168" class="Symbol">\</a><a id="13169" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13171" class="Symbol">→</a> <a id="13173" class="Number">4</a> <a id="13175" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="13177" class="Number">5</a> <a id="13179" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="13181" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13183" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="13185" class="Number">1</a> <a id="13187" href="Agda.Builtin.Nat.html#319" class="Primitive Operator">+</a> <a id="13189" class="Number">3</a> <a id="13191" href="Agda.Builtin.Nat.html#522" class="Primitive Operator">*</a> <a id="13193" href="blog/complexity-analysis/index.html#13169" class="Bound">n</a> <a id="13195" href="Data.Nat.Base.html#3480" class="Function Operator">^</a> <a id="13197" class="Number">2</a>
</pre>
<p>Finally, we just need to build a version of <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> that is adequately lifted over the same functions we use for <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span>:</p>
<pre class="Agda"><a id="13341" class="Keyword">abstract</a>
  <a id="OThunk"></a><a id="13352" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13359" class="Symbol">:</a> <a id="13361" class="Symbol">{</a><a id="13362" href="blog/complexity-analysis/index.html#13362" class="Bound">vars</a> <a id="13367" class="Symbol">:</a> <a id="13369" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13370" class="Symbol">}</a> <a id="13372" class="Symbol">→</a> <a id="13374" class="Symbol">(</a><a id="13375" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="13379" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="13381" href="blog/complexity-analysis/index.html#13362" class="Bound">vars</a> <a id="13386" class="Symbol">→</a> <a id="13388" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13389" class="Symbol">)</a> <a id="13391" class="Symbol">→</a> <a id="13393" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="13397" class="Symbol">→</a> <a id="13399" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="13405" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13412" class="Symbol">_</a> <a id="13414" href="blog/complexity-analysis/index.html#13414" class="Bound">a</a> <a id="13416" class="Symbol">=</a> <a id="13418" href="blog/complexity-analysis/index.html#13414" class="Bound">a</a>

  <a id="OThunk&#39;"></a><a id="13423" href="blog/complexity-analysis/index.html#13423" class="Function">OThunk&#39;</a> <a id="13431" class="Symbol">:</a> <a id="13433" class="Symbol">(</a><a id="13434" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="13436" class="Symbol">→</a> <a id="13438" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13439" class="Symbol">)</a> <a id="13441" class="Symbol">→</a> <a id="13443" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="13447" class="Symbol">→</a> <a id="13449" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="13455" href="blog/complexity-analysis/index.html#13423" class="Function">OThunk&#39;</a> <a id="13463" href="blog/complexity-analysis/index.html#13463" class="Bound">f</a> <a id="13465" class="Symbol">=</a> <a id="13467" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13474" class="Symbol">(</a><a id="13475" href="blog/complexity-analysis/index.html#10895" class="Function">hoist</a> <a id="13481" href="blog/complexity-analysis/index.html#13463" class="Bound">f</a><a id="13482" class="Symbol">)</a>
</pre>
<p>The <span class="Agda"><a href="blog/complexity-analysis/index.html#13586" class="Function">limit</a></span> function can be used to lift a <span class="Agda"><a href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a></span> into an <span class="Agda"><a href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a></span>:</p>
<pre class="Agda">  <a id="limit"></a><a id="13586" href="blog/complexity-analysis/index.html#13586" class="Function">limit</a>
    <a id="13596" class="Symbol">:</a> <a id="13598" class="Symbol">{</a><a id="13599" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a> <a id="13604" class="Symbol">:</a> <a id="13606" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13607" class="Symbol">}</a> <a id="13609" class="Symbol">{</a><a id="13610" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a> <a id="13612" class="Symbol">:</a> <a id="13614" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="13618" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="13620" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a> <a id="13625" class="Symbol">→</a> <a id="13627" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="13628" class="Symbol">}</a> <a id="13630" class="Symbol">{</a><a id="13631" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a> <a id="13633" class="Symbol">:</a> <a id="13635" href="Agda.Primitive.html#320" class="Primitive">Set</a><a id="13638" class="Symbol">}</a>
    <a id="13644" class="Symbol">→</a> <a id="13646" class="Symbol">(</a><a id="13647" href="blog/complexity-analysis/index.html#13647" class="Bound">v</a> <a id="13649" class="Symbol">:</a> <a id="13651" href="Data.Vec.Base.html#1007" class="Datatype">Vec</a> <a id="13655" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="13657" href="blog/complexity-analysis/index.html#13599" class="Bound">vars</a><a id="13661" class="Symbol">)</a>
    <a id="13667" class="Symbol">→</a> <a id="13669" class="Symbol">(</a><a id="13670" href="blog/complexity-analysis/index.html#13670" class="Bound">o</a> <a id="13672" class="Symbol">:</a> <a id="13674" href="blog/complexity-analysis/index.html#10572" class="Record">O</a> <a id="13676" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a><a id="13677" class="Symbol">)</a>
    <a id="13683" class="Symbol">→</a> <a id="13685" href="blog/complexity-analysis/index.html#1925" class="Function">Thunk</a> <a id="13691" class="Symbol">(</a><a id="13692" href="blog/complexity-analysis/index.html#13670" class="Bound">o</a> <a id="13694" class="Symbol">.</a><a id="13695" href="blog/complexity-analysis/index.html#10631" class="Field">O.f</a> <a id="13699" href="blog/complexity-analysis/index.html#13647" class="Bound">v</a><a id="13700" class="Symbol">)</a> <a id="13702" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a> <a id="13704" class="Symbol">→</a> <a id="13706" href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a> <a id="13713" href="blog/complexity-analysis/index.html#13610" class="Bound">f</a> <a id="13715" href="blog/complexity-analysis/index.html#13631" class="Bound">a</a>
  <a id="13719" href="blog/complexity-analysis/index.html#13586" class="Function">limit</a> <a id="13725" class="Symbol">_</a> <a id="13727" class="Symbol">_</a> <a id="13729" href="blog/complexity-analysis/index.html#13729" class="Bound">x</a> <a id="13731" class="Symbol">=</a> <a id="13733" href="blog/complexity-analysis/index.html#13729" class="Bound">x</a>
</pre>
<p>and we can now give an asymptotic bound over <span class="Agda"><a href="blog/complexity-analysis/index.html#7410" class="Function">sort</a></span>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>o2 <span class="op">:</span> <span class="dt">O&#39;</span> (_<span class="op">^</span> <span class="dv">1</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>o2 <span class="ot">=</span> <span class="dt">O</span><span class="op">-</span><span class="fu">drop</span><span class="op">-</span><span class="dv">1</span> {<span class="dv">1</span>} {<span class="dv">5</span>} {<span class="dv">1</span>} <span class="op">$</span> <span class="dt">O</span><span class="op">-</span>build <span class="op">$</span> hoist \n <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">*</span> n</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>linearHeadSort <span class="op">:</span> <span class="dt">Vec</span> a n → <span class="dt">OThunk&#39;</span> (_<span class="op">^</span> <span class="dv">1</span>) (<span class="dt">VecL</span> a (<span class="dv">4</span> <span class="op">*</span> n) n)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>linearHeadSort {n <span class="ot">=</span> n} v <span class="ot">=</span> limit (n ∷ []) o2 <span class="op">$</span> <span class="fu">sort</span> v</span></code></pre></div>
<h2 id="conclusions"><a href="#conclusions" class="header-link">Conclusions<span class="header-link-emoji">🔗</span></a></h2>
<p>I’m traveling right now, and ran out of internet on publication day, which means I don’t have a copy of the paper in front of me as I write this (foolish!) Overall, the paper is slightly interesting, though I don’t think there’s anything especially novel here. Sticking the runtime behavior into the type is pretty much babby’s first example of graded monads, and we don’t even get asymptotics out of it! Instead we need to push big polynomials around, and explicitly call <span class="Agda"><a href="blog/complexity-analysis/index.html#4689" class="Function">wait</a></span> to make different branches work out.</p>
<p>The <span class="Agda"><a href="blog/complexity-analysis/index.html#10572" class="Record">O</a></span> stuff I’ve presented here alleviates a few of those problems; as it allows us to relatively-easily throw away the polynomials and just work with the highest order terms. A probably better approach would be to throw away the functions, and use a canonical normalizing-form to express the asymptotes. Then we could define a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="#cc0000"><mtext>\lub</mtext></mstyle></mrow><annotation encoding="application/x-tex">\lub</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\lub</span></span></span></span></span> operator over <span class="Agda"><a href="blog/complexity-analysis/index.html#13352" class="Function">OThunk</a></span>s, and define:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>_<span class="op">&gt;&gt;=</span>_ <span class="op">:</span> <span class="dt">OThunk</span> f a → (a → <span class="dt">OThunk</span> g b) → <span class="dt">OThunk</span> (f ⊔ g) b</span></code></pre></div>
<p>to let us work compositionally in the land of big O.</p>
<p>My biggest takeaway here is that the techniques described in this paper are probably not powerful enough to be used in anger. Or, at least, not if you actually want to get any work done. Between the monads, polynomials, and waiting, the experience could use a lot of TLC.</p>
      ]]></content:encoded>
  </item>
</channel>
</rss>
