<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
  <title>Reasonably Polymorphic</title>
  <link>http://reasonablypolymorphic.com</link>
  <atom:link href="http://reasonablypolymorphic.com/feed.rss" rel="self" type="application/rss+xml" />
  <description>There will be math and Haskell and it will be in ya face.</description>
  <category>Life</category>
  <copyright>2018 Sandy Maguire</copyright>
  <pubDate>2022-01-20T18:02:00Z</pubDate>
  <language>en-us</language>
  <image>
      <url>http://reasonablypolymorphic.com/images/favicon.png</url>
    <title>Sandy Maguire</title>
    <link>http://reasonablypolymorphic.com</link>
  </image>
  <item>
      <title>Automating Wordle</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/wordle/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/wordle/index.html</guid>
      <pubDate>2022-01-20T18:02:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>It‚Äôs been a weird day.</p>
<p>Erin‚Äôs family has recently been into a word game called <a href="https://www.powerlanguage.co.uk/wordle/">Wordle</a>. Inevitably it spilled into Erin‚Äôs life, and subsequently into mine. The rules are simple: there‚Äôs a secret five-letter word, and you need to find it by guessing words. If your word shares a letter in the same place as the secret word, that letter is marked as green. If you have a letter in a different place, but also in the secret word, it‚Äôs marked as yellow.</p>
<p>The goal is to find the secret word in six guesses or fewer. Yesterday‚Äôs, for example, was ‚Äúpilot.‚Äù</p>
<p>After two days of doing it by hand, like a damn pleb, I decided it would be more fun to try to automate this game. So I spent all day thinking about how to do it, and eventually came up with a nice strategy. This blog post documents it, taking time to explain how it works, and more importantly, why.</p>
<h2 id="measuring-information">Measuring Information</h2>
<p>The trick to Wordle is to extract as much information from your guesses as possible. But what does it mean to ‚Äúextract‚Äù information? Is information something we can put a number on?</p>
<p>Rather surprisingly, the answer is yes.</p>
<p>Let‚Äôs illustrate the idea by ignoring Wordle for a moment. Instead, imagine I have a buried treasure, somewhere on this map:</p>
<p><img src="/images/wordle/map0.png" style="width: 100%"></p>
<p>You don‚Äôt know where the treasure is, but you can ask me some yes/no questions, and I promise to answer truthfully. In six questions, can you find the treasure?</p>
<p>The trick here is to be very strategic about how you ask your questions. For example, the first question you ask might be ‚Äúis the treasure on the left half of the map?‚Äù, to which I reply yes. We can now redraw the map, using red to highlight the places the treasure could still be:</p>
<p><img src="/images/wordle/map1.png" style="width: 100%"></p>
<p>Next you can ask ‚Äúis the treasure on the bottom half <em>of the remaining red region?</em>‚Äù I say no. Thus the treasure is on the top half, and our refined map looks like this:</p>
<p><img src="/images/wordle/map2.png" style="width: 100%"></p>
<p>‚ÄúIs the treasure on the right half?‚Äù Yes.</p>
<p><img src="/images/wordle/map3.png" style="width: 100%"></p>
<p>‚ÄúTop?‚Äù No.</p>
<p><img src="/images/wordle/map4.png" style="width: 100%"></p>
<p>You get the idea. By phrasing subsequent questions like this, each time we cut in half the remaining possible hiding spots for the treasure. When we find the treasure, we‚Äôre done.</p>
<p>To quantify the amount of information necessary to find the treasure, we need only count how many questions we asked. If we can go from the full map to finding the treasure in 7 questions, we say we needed <em>7 bits</em> of information to find it.</p>
<p>In general, the information required to solve a problem is the number of times we need to split the space in half in order to find what we were looking for. Information is measured in ‚Äúbits.‚Äù</p>
<h2 id="back-to-wordle">Back To Wordle</h2>
<p>How does any of this apply to Wordle? The first question to ask ourselves is just how much information is required to win the game. But what does that mean? We‚Äôre trying to find one particular five-letter word in the entire English language. So, how many five-letter words are there in the English language? Nobody knows for sure, but I wrote a program to look through the dictionary, and it came up with <strong>5150 words.</strong></p>
<p>If we need to find one word in particular out of these 5150, how many times do we need to cut it in half? Let‚Äôs do the math:</p>
<pre><code>  5150 / 2
= 2575 / 2
= 1288 / 2
= 644  / 2
= 322  / 2
= 161  / 2
= 81   / 2
= 41   / 2
= 21   / 2
= 11   / 2
= 6    / 2
= 3    / 2
= 2    / 2
= 1</code></pre>
<p>Thirteen cuts! It takes thirteen cuts to trim down the search space of all possible Wordle words down to a single word. Thus, analogously to our hidden treasure, we need thirteen bits of information in order to find the secret word.</p>
<h2 id="discovering-information">Discovering Information</h2>
<p>Knowing the amount of information necessary to solve Wordle is one thing, but where does that information actually come from? Recall, the rules of the game <em>don‚Äôt even let us</em> ask yes or no questions; all we‚Äôre allowed to do is guess a five-letter word.</p>
<p>How can we turn a five-letter word into a yes/no question? Much like with the buried treasure, it helps to have a lay of the land. Imagine that by some chance, exactly half the words in the dictionary had an <code>e</code> in them, and the other half had no <code>e</code>. Then, by guessing a word that contains an <code>e</code>, we could narrow down the possible words by half depending on whether or not we got a yellow result from Wordle.</p>
<p>Imagine by another coincidence that exactly half the words in the dictionary had an <code>s</code> in them, and the other half didn‚Äôt. We could further refine our possibilities by guessing a word that has an <code>s</code> as well as an <code>e</code>.</p>
<p>So that‚Äôs the idea. Of course, no letter is going to be in exactly half of the words, but some will be <em>more</em> ‚Äúexactly half‚Äù than others. We can inspect the dictionary, and find the letters which are most ‚Äúbalanced.‚Äù Doing that, we get the following:</p>
<pre><code>e: 203
a: 497
r: 641
o: 969
t: 981
l: 1019
i: 1021
s: 1079
n: 1215
u: 1401
c: 1419
y: 1481
h: 1557
d: 1575
p: 1623
g: 1715
m: 1719
b: 1781
f: 1901
k: 1911
w: 1927
v: 2017
x: 2241
z: 2245
q: 2257
j: 2261</code></pre>
<p>The numbers here measure the imbalance of each letter. That is, there are 203 fewer words that contain <code>e</code> than do not. On the other end, there are <code>2261</code> more words that don‚Äôt contain <code>j</code> than do. This means that by guessing <code>e</code>, we are going to get a much more even split than by guessing <code>j</code>.</p>
<p>The letters with lower numbers give us more information on average than the letters with big numbers. And remember, information is the name of the game here.</p>
<p>By forming a five-letter word out of the most-balanced letters on this list, we can extract approximately five bits of information from the system. So that means we‚Äôd like to come up with a word from the letters <code>earot</code> if at all possible. Unfortunately, there is no such word, so we need to look a little further and also pull in <code>l</code>. Now we can make a word from <code>earotl</code>‚Äî<code>later</code>!</p>
<p>Since <code>later</code> is formed from the most balanced letters in the word set, it has the <em>highest expected information.</em> By trying <code>later</code> first, we are statistically most likely to learn more than any other guess.</p>
<p>Let‚Äôs see how it does against yesterday‚Äôs word <code>pilot</code>. We get:</p>
<p>üü®‚¨õüü®‚¨õ‚¨õ</p>
<p>No greens, but we know that the secret word (pilot) doesn‚Äôt have any <code>a</code>s, <code>e</code>s or <code>r</code>s. Furthermore, we know it does have both a <code>l</code> and a <code>t</code>. Therefore, we can eliminate a huge chunk of our words, for example:</p>
<ul>
<li><code>titan</code> because the secret word has no <code>a</code></li>
<li><code>cupid</code> because it doesn‚Äôt have an <code>l</code></li>
</ul>
<p>and, as you can imagine, lots of other words.</p>
<p>In fact, the number of words remaining is 27. They are:</p>
<pre><code>blitz,blunt,built,cloth,clout,filth,flint,flout,glint,
guilt,hotly,light,limit,lofty,lusty,moult,pilot,quilt,
sloth,spilt, split,still,stilt,stool,tulip,unlit,until</code></pre>
<p>We can check how many bits of information we extracted:</p>
<pre><code>log2 (5150 / 27) = 7.58</code></pre>
<p>We managed to extract nearly 8 bits of information from this one guess! That‚Äôs significantly better than the 5 we should have gotten ‚Äútheoretically.‚Äù Not bad at all!</p>
<p>Our next guess can be found in the same way. Take the 27 remaining words, and figure out which letters are best balanced among them:</p>
<pre><code>u: 5
i: 7
o: 9
s: 13
h: 17
n: 17
f: 19
p: 19
b: 21
g: 21
y: 21
c: 23
m: 23
q: 25
z: 25
a: 27
d: 27
e: 27
j: 27
k: 27
l: 27
r: 27
t: 27
v: 27
w: 27
x: 27</code></pre>
<p>Notice that several letters have an unbalanced count of 27. This means either all the words have (or do not have) this letter, and thus, these are completely unhelpful letters to guess.</p>
<p>Of our remaining 27, the most balanced word we can make from these letters is <code>until</code>. But notice that <code>until</code> uses both <code>t</code> and <code>l</code>, which we already learned from <code>later</code>!</p>
<p>We can do better by picking a word from the original dictionary which is most balanced according to these numbers. That word is <code>using</code>. Let‚Äôs use it for our next guess, which results in:</p>
<p>‚¨õ‚¨õüü®‚¨õ‚¨õ</p>
<p>We‚Äôre left with only four words:</p>
<pre><code>blitz,filth,limit,pilot</code></pre>
<p>Rinse and repeat, by finding the most balanced letters in the remaining possibilities, and then finding the best word in the dictionary made out of those letters. The next guess is <code>morph</code>:</p>
<p>‚¨õüü®‚¨õüü®‚¨õ</p>
<p>Which eliminates all words except for <code>pilot</code>. Nice.</p>
<p>With that, we‚Äôve successfully automated away playing a fun game. Yay? This strategy works for any word, and hones in on it extremely quickly.</p>
<p>All the code can be found on <a href="https://gist.github.com/isovector/00c7974588e5e1dfeb94f2ea7a7ef675">Github.</a></p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Shall We Vote on Values, But Bet on Beliefs?</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/review-futarchy/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/review-futarchy/index.html</guid>
      <pubDate>2022-01-14T15:55:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Another week, another paper review. This week we‚Äôre looking at Robin Hanson‚Äôs <a href="">‚ÄúShall We Vote on Values, But Bet on Beliefs?‚Äù</a> (SWVVBBB). In SWVVBBB, Hanson proposes a new form of government he calls ‚Äúfutuarchy,‚Äù which injects prediction markets into democratic government.</p>
<p>The preamble starts like this:</p>
<ol type="1">
<li>Democracies fail by not aggregating information</li>
<li>Prediction markets are really good at aggregating information</li>
<li>We can postdict which nations did better than others.</li>
</ol>
<p>These three assumptions seem relatively self-evident, though perhaps the first is the least obvious. In support of this assumption, Hanson presents some evidence:</p>
<ol type="1">
<li>Most people vote the same way they‚Äôve always voted.</li>
<li>Most people don‚Äôt know what the government is doing.</li>
<li>Most people don‚Äôt know which platforms parties stand for.</li>
<li>It‚Äôs hard for governments to disseminate information.</li>
<li>The populace often has different ideas about what government should do than what experts say it should do.</li>
<li>At large, the populace believes in a bunch of rather crazy things (eg. 85% of Americans believe Jesus was born to a virgin, and 52% believe astrology has some scientific proof.)</li>
<li>It seems untenable that bad policy decisions would be adopted if they were known to be bad policy decisions.</li>
</ol>
<p>The first three points are pretty easy to believe as well. The fourth is also tenable; the government relies on mainstream media to get messages out, where it can be editorialized before being published. Points five and six taken together suggest that the people are often <em>wrong</em> about what constitutes good policy.</p>
<p>Hanson presents sources for these claims, but I don‚Äôt have any issues taking them on faith ‚Äî this isn‚Äôt the crux of the paper. It‚Äôs safe to say that failure to aggregate information is a serious problem in democracies.</p>
<p>Why does this matter? Because democracy gives us one vote, with which not only do we need to vote on our values, but also on how we‚Äôd like the government to bring about those values. For example, political parties‚Äô platforms involve both <em>values</em> (‚Äúwe care about healthcare, equality, housing, etc.‚Äù), and <em>strategy</em> (‚Äúwe will build 1,000,000 new houses and hire 50,000 new nurses.‚Äù)</p>
<p>Personally, I support Canada‚Äôs left-most party‚Äôs values, but I don‚Äôt think they‚Äôd be very capable if they actually got into power. This tension leads me away from voting for them, in an attempt to find a better mix of <em>competent</em> and <em>represents what I care about.</em></p>
<p>The question that SWVVBBB answers is ‚Äúhow can we separate voting for values from voting for execution of those values.‚Äù And as the title suggests, the trick is to do it by putting our money where our mouths are.</p>
<h2 id="betting-on-beliefs">Betting on Beliefs</h2>
<p>The main contribution of SWVVBBB in my opinion is its clever mechanism design to pull <em>probabilities</em> out of <em>prices.</em> This will take some explanation.</p>
<p>At a high level, the idea is we should vote for a party based only on our values. The winning party is responsible for choosing an explicit mathematical function that represents how well the country is doing on its values. For example, this function might be ‚ÄúGDP‚Äù, or ‚Äúpercent of the population employed,‚Äù or ‚Äúglobal happiness ranking,‚Äù or what have you. Probably, it will be some combination of these things.</p>
<p>The government‚Äôs only job is to define what success looks like, and how we‚Äôre going to measure it. That‚Äôs all the government does. They don‚Äôt get to raise taxes, or allocate spending, or appoint judges, or anything like that. They are responsible only to pick the utility function, and to create any agencies that might be required to measure it.</p>
<p>Here‚Äôs where it gets interesting.</p>
<p>We now put a prediction market in place. For a fee, anybody can propose any intervention on the way the country is run. Collectively, people buy and sell bonds corresponding to whether they think the proposal will help maximize the government‚Äôs value function. By looking at the market price of the bonds, we can get a good sense of whether or not the market thinks the proposal is a good idea. If it is, the proposal immediately gets turned into law.</p>
<p>The details on how to actually go about building this market are a good chunk of the paper, which we will get to in the next section. For now, let‚Äôs continue thinking about the high-level idea.</p>
<p>By connecting the law to a market, we immediately get a few benefits. The first is that we now incentivize people to have true beliefs about governance. If my ideas about how the country should be run are in fact good, I can make money off of that skill. Furthermore, it incentivizes transparency. If people can make lots of money off of this market, you can bet they‚Äôll watch it extremely closely.</p>
<p>Perhaps best of all, it pushes stupid people out of the market. If you are consistently <em>wrong</em> about what constitutes good governance, you will quickly price yourself out of the market ‚Äî similar to people who go broke trying to play the stock market on the advice of their uncle.</p>
<p>To be clear, this doesn‚Äôt disenfranchise people. They still get to vote on the government. But it requires questions of policy to be answered by putting your money where your mouth is. Thus, under this scheme, it becomes prohibitively expensive to have stupid beliefs strongly held.</p>
<h2 id="mechanism-design">Mechanism Design</h2>
<p>So, that‚Äôs the high level idea. How do we actually go about implementing it?</p>
<h3 id="discovering-probability">Discovering Probability</h3>
<p>Imagine a particular question of fact, that can be definitely observed in the future. For example, maybe we want to determine whether or not it will be raining next Friday at 10am in the park beside my house. The more specific the question, the better.</p>
<p>The bank can offer a pair of assets:</p>
<ol type="1">
<li>Pays \$1 if it is raining on Friday at 10am.</li>
<li>Pays \$1 if it is not raining on Friday at 10am.</li>
</ol>
<p>and the bank is happy to sell these assets for \$1, because exactly one of them will actually pay off. In the meantime, the bank can collect interest for free.</p>
<p>Suppose Market-Making Marty buys 10,000 of these pairs from the bank. Marty can now sell the assets individually, for example, he might sell some not raining assets to Dusty, and some raining assets to Misty. Initially, he might price both assets at \$0.60.</p>
<p>By selling both sides of the pair at \$0.60, Marty safely makes \$2,000 dollars off of his \$10,000 investment. It‚Äôs safe because he no longer holds any assets except for cold hard cash.</p>
<p>Dusty figures that it‚Äôs sunny more than 60% of the time, so paying \$0.60 for an asset that pays \$1.00 is a good deal. If he estimates the likelihood of it being sunny on Friday at 80%, then he expects an 80% chance of making \$10,000, and a 20% chance of making \$0. Adding these together, he computes his expected value at <span class="math inline">\(0.8 * 10000 + 0.2 * 0 = 8000\)</span>, which is \$2,000 more in expectation than the cost of buying all the assets at \$6,000.</p>
<p>Misty does some chain of reasoning that makes her believe that her money is also well spent.</p>
<p>Summer has been thinking hard, and is pretty sure the chance of rain on Friday is actually closer to 5%. So she approaches Dusty, and offers to buy some of his no-rain assets for \$0.90. Dusty thinks this is too confident, so he happily unloads his options to Summer, since again he expects to be making money on this trade.</p>
<p>When everything settles, no-rain assets are trading at a market price of \$0.83, while rain assets are at \$0.17 (in the limit, these must add up to \$1.00, or else you can make money by holding both sides.)</p>
<p>Patty, who was thinking about having a picnic in the park on Friday, looks at the asset prices, and decides it‚Äôs not going to rain, since no-rain is trading above rain.</p>
<p>Thus, Patty has made a decision about the future, based on information aggregated from Dusty, Misty, Summer, and whoever else might have been in on the market.</p>
<p>Friday comes along, and it doesn‚Äôt rain. Patty is happy, as is everyone holding no-rain assets, since they all made money.</p>
<h3 id="discovering-expected-value">Discovering Expected Value</h3>
<p>We can play the same game to extract information about expected values from the market. Suppose we want to guess the price of flour next week. The bank can look at the historical high of flour price, and sell pairs of assets:</p>
<ol type="1">
<li>Pays \$x, where <code>x</code> is the percentage of the cost of flour with respect to its all-time high. For example, if the all-time high was \$40, and the cost of flour next week was \$30, this asset pays \$0.75 (<span class="math inline">\(30/40\)</span>).</li>
<li>Pays \$(1 - x).</li>
</ol>
<p>Again, the bank is happy to make this trade because they are still only paying out \$1, and they still get to make interest on that dollar until the market pays out.</p>
<p>The trading price of these assets now correspond to the market‚Äôs opinion of the expected value of the price of flour next week. If \$x assets are trading at \$0.30, we can read the expected value of flour next week to be <span class="math inline">\(0.3 * 40 = 12\)</span>.</p>
<h3 id="conditional-assets">Conditional Assets</h3>
<p>There‚Äôs one last trick we can do. We can make conditional assets, that is, assets which only pay out when a certain precondition is met. We can consider the case of whether or not a big law firm BLF wins its case, conditional on whether or not they put Litigious Larry on as the lead prosecutor. In this case, the bank offers quads of assets for \$1:</p>
<ol type="1">
<li>Pays \$1 if BLF wins with Larry</li>
<li>Pays \$1 if BLF wins without Larry</li>
<li>Pays \$1 if BLF loses with Larry</li>
<li>Pays \$1 if BLF loses without Larry</li>
</ol>
<p>Again, only one of these four cases will actually pay out (ignoring the possibility that it doesn‚Äôt go to court, but that‚Äôs a simplification for the example, not a limitation of the technique.)</p>
<p>Like Patty in the park, BLF can make a decision about the future: whether or not they should put Larry on the case based on whether Win|Larry is trading higher than Win|-Larry.</p>
<p>Furthermore, they can rethink whether or not they want to settle out of court if the BLF loses assets are trading at better than BLF wins.</p>
<h2 id="putting-it-into-practice">Putting It Into Practice</h2>
<p>With the mechanism design under our belt, we can now think about implementing futarchy.</p>
<p>The people vote on the government based on parties‚Äô values. The government puts forward its value function. Now, anyone can pay a transaction fee (perhaps quite high) to propose a policy intervention. The bank can offer a pair of assets:</p>
<ol type="1">
<li>Pays \$x if the intervention is made</li>
<li>Pays \$(1-x) if the intervention is made</li>
</ol>
<p>where x is linear in the observed value function at some point in the future. The idea is to tie the payoff of the asset to how well it helps influence our value function.</p>
<p>For example, maybe the government decides the value function is GDP. Maybe the target GDP in five years is \$30 trillion. Phoebe then proposes building a high-speed train between Toronto and Vancouver. The bank can offer assets as above, where x is the observed percentage of GDP out of \$30 trillion.</p>
<p>After some period of trading, the \$x assets are trading well above \$(1-x). This is interpreted as the market thinking this train would be good for long term GDP. Immediately, the decision to build the train is ensconced in law.</p>
<p>That doesn‚Äôt mean all the details are necessarily worked out. If Phoebe had the whole plan for the train worked out, she could have put those in her proposal. But let‚Äôs assume she didn‚Äôt. Instead, someone can make a new proposal, that Cost-Cutting Carlos should get put in charge of the project. At the same time, there is a proposal that Safety Susan should be put in charge. Markets pop up for both, and whichever is trading higher gets the bid (unless neither is trading well!)</p>
<p>We can follow this process ad infinitum, to work out more and more particulars. If, at any time, someone thinks the train is actually a bad idea, they can make a proposal to stop its development. We need not worry about the inefficiency inherent this sort of flip-flopping; the market will necessarily price-in the sunk costs.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Review: Adders and Arrows</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/adders-and-arrows/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/adders-and-arrows/index.html</guid>
      <pubDate>2022-01-07T14:27:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>This year my goal is to go through one paper a week, and produce some resulting artifact to help hammer in my understanding. Today‚Äôs paper is <a href="http://conal.net/">Conal Elliott‚Äôs</a>‚Äôs <a href="http://conal.net/papers/drafts/adders-and-arrows.pdf">Adders and Arrows</a>.</p>
<p>In my opinion, Adders and Arrows is an attempt to answer the questions ‚Äúwhere do digital circuits come from?‚Äù and ‚Äúhow can we be convinced our digital circuits do what they claim?‚Äù by focusing on the concrete case of adders. What‚Äôs quite remarkable to me is that the paper takes 17 pages to build up to the ‚Äúknown‚Äù ripple-carry adder, which is essentially day 1 of any digital circuitry class. This feels a bit ridiculous at first blush, but immediately pays off for itself by using the same machinery to derive a carry-forward adder. Carry-forward adders come like a week later in circuitry class, and are completely unrelated to ripple-carry adders, but Elliott derives them essentially for free. He then gives a third variation on the theme, which is a ripple-carry adder <em>in time,</em> rather than space, and again gets it in one page.</p>
<p>So that‚Äôs the impressive stuff. What‚Äôs also important is that the paper doesn‚Äôt require us to trust that the corresponding circuits do what they claim ‚Äî the underlying machinery passes around a big chain of equivalence proofs, which automatically get composed and witness that addition over the naturals is a model for each circuit.</p>
<p>Something I really liked about this paper is that it‚Äôs the first time I‚Äôve ever gotten a glimpse of why it might be valuable to understand category theory. It‚Äôs not just good for classifying things! Turns out you can do cool things with it too. But nobody who teaches it ever says that.</p>
<p>The paper itself is only a draft, and it shows in several places. Notably, the core abstraction (the arrow category) is missing, and the paper ends extremely abruptly. After some spelunking, I managed to track down the implementation of the arrow category, and was pleased to realize I‚Äôd already implemented it independently.</p>
<p>We‚Äôll proceed section by section.</p>
<h2 id="section-1-a-model-of-addition">Section 1: A model of addition</h2>
<p>Section 1 gives us a model of the natural numbers via the Peano encoding, and also defines addition. It drives home the point that this unary encoding is only the model of our computation ‚Äî its specification ‚Äî and not the actual implementation. This is a common theme in Elliott‚Äôs work: ‚Äúhow do we even know what question we‚Äôre trying to answer?‚Äù We know by posing the dumbest possible model of the problem, and then proving any actual solution to the problem is equivalent. He stresses that the ‚Äúdumbest possible‚Äù thing is an important quality ‚Äî this is the only part of the problem we get no checks or balances on, so our only hope is to make it so simple that we can‚Äôt screw it up.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> Nat <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  zero <span class="ot">:</span> Nat</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  suc  <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Nat</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>zero  + n <span class="ot">=</span> n</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>suc m + n <span class="ot">=</span> suc <span class="ot">(</span>m + n<span class="ot">)</span></span></code></pre></div>
<p>Because arbitrary categories don‚Äôt support currying, we can uncurry addition, which will come in handy later:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>&lt;+&gt; <span class="ot">:</span> Nat2 <span class="ot">-&gt;</span> Nat</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>&lt;+&gt; <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">=</span> x + y</span></code></pre></div>
<h2 id="section-2-bounded-numbers">Section 2: Bounded numbers</h2>
<p>Section 2 is defines the <code>Fin</code>iteary numbers, which are natural numbers guaranteed to be smaller than a given upper bound.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> Fin <span class="ot">:</span> N <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  zero <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  suc  <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> N<span class="ot">}</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc n<span class="ot">)</span></span></code></pre></div>
<p>Thus, <code>Fin 2</code> is the type of binary digits, and <code>Fin 10</code> is that of decimal digits.</p>
<p>Elliott gives us an observation of <code>Fin</code> in terms of <code>Nat</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>toN <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Nat</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>toN zero    <span class="ot">=</span> zero</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>toN <span class="ot">(</span>suc f<span class="ot">)</span> <span class="ot">=</span> suc <span class="ot">(</span>toN f<span class="ot">)</span></span></code></pre></div>
<p>We‚Äôd like to find a model-preserving implementation of <code>+</code> over <code>Fin</code> (let‚Äôs call it <code>&lt;+F&gt;</code>.) But what does model-preserving meaning? As usual, the answer is ‚Äúhomomorphism‚Äù, and namely, that the following square must commute:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>&lt;+&gt; <span class="ot">.</span> bimap toN toN <span class="ot">=</span> toN <span class="ot">.</span> &lt;+F&gt;</span></code></pre></div>
<p>The paper says ‚Äúsolving this equation for <code>&lt;+F&gt;</code> yields the following recursive definition.‚Äù It‚Äôs unclear if this answer was ‚Äúsolved for‚Äù in the sense of being manipulated algebraically, or if it just happens to be a solution to the problem. I hope it‚Äôs the former, because I would love to see how to do that, but I suspect it‚Äôs the latter. Anyway, the definition of <code>_+F_</code> is given below, plus the work I needed to do to get everything to typecheck.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>n+suc <span class="ot">:</span> <span class="ot">(</span>n m <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> n + suc m == suc <span class="ot">(</span>n + m<span class="ot">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>n+suc zero m <span class="ot">=</span> refl</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>n+suc <span class="ot">(</span>suc n<span class="ot">)</span> m <span class="kw">rewrite</span> n+suc n m <span class="ot">=</span> refl</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>weaken <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">{</span>n<span class="ot">}</span> <span class="ot">(</span>y <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>weaken <span class="ot">{</span>zero<span class="ot">}</span> y <span class="ot">=</span> y</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>weaken <span class="ot">{</span>suc m<span class="ot">}</span> zero <span class="ot">=</span> zero</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>weaken <span class="ot">{</span>suc m<span class="ot">}</span> <span class="ot">{</span>suc n<span class="ot">}</span> <span class="ot">(</span>suc y<span class="ot">)</span> <span class="kw">rewrite</span> n+suc m n <span class="ot">=</span> suc <span class="ot">(</span>weaken y<span class="ot">)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="ot">_</span>+F<span class="ot">_</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>suc m<span class="ot">)</span> <span class="ot">-&gt;</span> Fin n <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">{</span>m<span class="ot">}</span> zero y <span class="ot">=</span> weaken y</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a><span class="ot">_</span>+F<span class="ot">_</span> <span class="ot">{</span>suc <span class="ot">_}</span> <span class="ot">(</span>suc x<span class="ot">)</span> y <span class="ot">=</span> suc <span class="ot">(</span>x +F y<span class="ot">)</span></span></code></pre></div>
<p>Something that ended up challenging me here was that Elliott uses extensional equality of functions for his commutative diagrams, but my implementation of arrow categories (coming up) requires a propositional equality. I got around the problem by postulating extensionality (which I stole from McBride), and then by defining a type-alias for extensional equality that plays well with <code>extensionality</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">postulate</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  extensionality <span class="ot">:</span> <span class="ot">{</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{</span>T <span class="ot">:</span> S <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>                   <span class="ot">{</span>f g <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> S<span class="ot">)</span> <span class="ot">-&gt;</span> T x<span class="ot">}</span> <span class="ot">-&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                   <span class="ot">((</span>x <span class="ot">:</span> S<span class="ot">)</span> <span class="ot">-&gt;</span> f x == g x<span class="ot">)</span> <span class="ot">-&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>                   f == g</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="kw">infix</span> <span class="dv">1</span> <span class="ot">_</span>=o=<span class="ot">_</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a><span class="ot">_</span>=o=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a><span class="ot">_</span>=o=<span class="ot">_</span> <span class="ot">{</span>A<span class="ot">}</span> f g <span class="ot">=</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">-&gt;</span> f x == g x</span></code></pre></div>
<p>and then we can give <em>most</em> (it‚Äôs hard to prove things, OK?) of the proof for the commutative diagram:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>toN-weaken <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>y <span class="ot">:</span> Fin n<span class="ot">)</span> <span class="ot">-&gt;</span> toN <span class="ot">(</span>weaken <span class="ot">{</span>m<span class="ot">}</span> y<span class="ot">)</span> == toN y</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>toN-weaken <span class="ot">{</span>zero<span class="ot">}</span> y <span class="ot">=</span> refl</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> zero <span class="ot">=</span> refl</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> <span class="ot">(</span>suc y<span class="ot">)</span> <span class="ot">=</span> ?</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>toN-+F <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN <span class="ot">{</span>m + n<span class="ot">}</span> ‚àò &lt;+F&gt; =o= &lt;+&gt; ‚àò toN2 <span class="ot">{</span>suc m , n<span class="ot">}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>toN-+F <span class="ot">{</span>zero , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span> <span class="ot">=</span> refl</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>toN-+F <span class="ot">{</span>suc m , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>m , n<span class="ot">}</span> <span class="ot">(</span>zero , y<span class="ot">)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>        <span class="ot">|</span> toN-weaken <span class="ot">{</span>suc m<span class="ot">}</span> y <span class="ot">=</span> refl</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>toN-+F <span class="ot">{</span>suc m , n<span class="ot">}</span> <span class="ot">(</span>suc x , y<span class="ot">)</span> <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>m , n<span class="ot">}</span> <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<h2 id="section-3-the-arrow-category">Section 3: The arrow category</h2>
<p>Section 3 presents the fact that we can bundle up the commutative diagram with its proof into an object. Unfortunately, it only gives the <em>barest hint</em> about how to actually go about doing that. I‚Äôm presenting here what I think it is, but if something goes wrong in the rest of the paper, here‚Äôs where the problem is.</p>
<p>The paper is keen to point out that we have five things we‚Äôre bundling together:</p>
<ol type="1">
<li>A mapping from implementation input to specification input.</li>
<li>A mapping from implementation output to specification output.</li>
<li>An implementation.</li>
<li>A specification.</li>
<li>A proof that the square commutes.</li>
</ol>
<p>Colloquially, I‚Äôd call the first two points our ‚Äúobservations‚Äù of the system.</p>
<p>The idea is, we‚Äôd like to bundle all of these things together, ideally in some sort of composable packaging. Composable usually means categorical, so we should look at our old friend <code>SET</code>, the category whose objects are types and arrows are functions. By itself, <code>SET</code> doesn‚Äôt give us any of the machinery we‚Äôd want for thinking about commutative squares. So instead, we‚Äôll construct the arrow category over <code>SET</code>. Let‚Äôs call it <code>&gt;-SET-&gt;</code>.</p>
<p>But what is the arrow category? The paper is quiet on this front, but my understanding is that it transforms the <em>arrows</em> in <code>SET</code> into <em>objects</em> in <code>&gt;-SET-&gt;</code>. An arrow in <code>&gt;-SET-&gt;</code> is thus a pair of arrows in <code>SET</code> which form a commutative square. For example, consider the arrows in <code>SET</code>:</p>
<pre><code>Fin n x Fin n        Nat x Nat
      |                  |
      | &lt;+F&gt;             | &lt;+&gt;
      v                  v
    Fin n               Nat</code></pre>
<p>In <code>&gt;-SET-&gt;</code>, these are just two objects, and a morphism between them is something that makes the whole square commute. In <code>&gt;-SET-&gt;</code>:</p>
<pre><code>       bimap toNat toNat
&lt;+F&gt;  ------------------&gt;  &lt;+&gt;
             toNat</code></pre>
<p>and again in <code>SET</code>:</p>
<pre><code>                bimap toNat toNat
Fin n x Fin n  ------------------&gt; Nat x Nat
      |                                |
      | &lt;+F&gt;                           | &lt;+&gt;
      v               toNat            v
    Fin n      ------------------&gt;    Nat</code></pre>
<p>So we can consider the arrow category to be a ‚Äúview‚Äù on its underlying category, like how databases present views over their data. The arrow category lets us talk about arrows directly, and <em>ensures</em> the commutativity of any constructions we‚Äôre able to form. As such, it‚Äôs a natural fit for our purposes of specification ‚Äî we are literally unable to construct any arrows in <code>&gt;-SET-&gt;</code> which violate our specification.</p>
<h3 id="building-categories">Building Categories</h3>
<p>How do we go about actually building an arrow category? First, some preliminaries to build a category:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">record</span> Category <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="kw">infix</span> <span class="dv">6</span> <span class="ot">_</span>~&gt;<span class="ot">_</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    Obj <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    <span class="ot">_</span>~&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">(</span>A B <span class="ot">:</span> Obj<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    id <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">-&gt;</span> A ~&gt; A</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    <span class="ot">_</span>&gt;&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">-&gt;</span> A ~&gt; B <span class="ot">-&gt;</span> B ~&gt; C <span class="ot">-&gt;</span> A ~&gt; C</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    id-l <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span> <span class="ot">-&gt;</span> id &gt;&gt; f == f</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    id-r <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> Obj<span class="ot">}</span> <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span> <span class="ot">-&gt;</span> f &gt;&gt; id == f</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>    &gt;&gt;-assoc <span class="ot">:</span> <span class="ot">{</span>A B C D <span class="ot">:</span> Obj<span class="ot">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>               <span class="ot">(</span>f <span class="ot">:</span> A ~&gt; B<span class="ot">)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>            <span class="ot">-&gt;</span> <span class="ot">(</span>g <span class="ot">:</span> B ~&gt; C<span class="ot">)</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>            <span class="ot">-&gt;</span> <span class="ot">(</span>h <span class="ot">:</span> C ~&gt; D<span class="ot">)</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>            <span class="ot">-&gt;</span> f &gt;&gt; <span class="ot">(</span>g &gt;&gt; h<span class="ot">)</span> == <span class="ot">(</span>f &gt;&gt; g<span class="ot">)</span> &gt;&gt; h</span></code></pre></div>
<p>And I have some syntactic sugar for dealing with arrows and composition in an arbitrary category:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">infix</span> <span class="dv">5</span> <span class="ot">_</span>[<span class="ot">_</span>,<span class="ot">_</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="ot">_</span>[<span class="ot">_</span>,<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">(</span>C <span class="ot">:</span> Category<span class="ot">)</span> <span class="ot">-&gt;</span> Obj C <span class="ot">-&gt;</span> Obj C <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>C [ X , Y ] <span class="ot">=</span> <span class="ot">_</span>~&gt;<span class="ot">_</span> C X Y</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="kw">infix</span> <span class="dv">5</span> <span class="ot">_</span>[<span class="ot">_</span>&gt;&gt;<span class="ot">_</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="ot">_</span>[<span class="ot">_</span>&gt;&gt;<span class="ot">_</span>] <span class="ot">:</span> <span class="ot">(</span>C <span class="ot">:</span> Category<span class="ot">)</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>       <span class="ot">-&gt;</span> <span class="ot">{</span>X Y Z <span class="ot">:</span> Obj C<span class="ot">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>       <span class="ot">-&gt;</span> C [ X , Y ]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>       <span class="ot">-&gt;</span> C [ Y , Z ]</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>       <span class="ot">-&gt;</span> C [ X , Z ]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>C [ f &gt;&gt; g ] <span class="ot">=</span> <span class="ot">_</span>&gt;&gt;<span class="ot">_</span> C f g</span></code></pre></div>
<p>With this, we can describe an arrow in <code>SET</code> via <code>SET [ A , B ]</code>, and composition via <code>SET [ foo &gt;&gt; bar ]</code>.</p>
<h3 id="building-arrow-categories">Building arrow categories</h3>
<p>An arrow category is parameterizd by the category whose arrows form its objects:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">ARROW</span> (<span class="dt">C</span> <span class="op">:</span> <span class="dt">Category</span>) <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  open <span class="dt">Category</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  open _<span class="ot">=&gt;</span>_</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  record <span class="dt">ArrowObj</span> <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    constructor arrow<span class="op">-</span>obj</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>    field</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>      {alpha} <span class="op">:</span> <span class="dt">Obj</span> <span class="dt">A</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>      {beta}  <span class="op">:</span> <span class="dt">Obj</span> <span class="dt">B</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>      hom <span class="op">:</span> <span class="dt">C</span> [ alpha , beta ]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>  open <span class="dt">ArrowObj</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>  record <span class="dt">ArrowArr</span> (<span class="dt">X</span> <span class="dt">Y</span> <span class="op">:</span> <span class="dt">ArrowObj</span>) <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>    constructor arrow<span class="op">-</span>hom</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    field</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>      f <span class="op">:</span> <span class="dt">A</span> [ <span class="dt">X</span> <span class="op">.</span>alpha , <span class="dt">Y</span> <span class="op">.</span>alpha ]</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>      g <span class="op">:</span> <span class="dt">B</span> [ <span class="dt">X</span> <span class="op">.</span>beta , <span class="dt">Y</span> <span class="op">.</span>beta ]</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a>      commute <span class="op">:</span> <span class="dt">C</span> [ f <span class="op">&gt;&gt;</span> <span class="dt">Y</span> <span class="op">.</span>hom ] <span class="op">==</span> <span class="dt">C</span> [ <span class="dt">X</span> <span class="op">.</span>hom <span class="op">&gt;&gt;</span> g ]</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>  <span class="dt">Arrow</span> <span class="op">:</span> <span class="dt">Category</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>  <span class="dt">Obj</span> <span class="dt">Arrow</span> <span class="ot">=</span> <span class="dt">ArrowObj</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>  _<span class="op">~&gt;</span>_ <span class="dt">Arrow</span> <span class="ot">=</span> <span class="dt">ArrowArr</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>  <span class="co">-- ...</span></span></code></pre></div>
<p>My implementation for <code>Arrow</code> is actually in terms of the arrow category, which is the same idea except it does some functor stuff. In the code accompanying this post, <code>ARROW {c}</code> is implemented as <code>COMMA {c} ID=&gt; ID=&gt;</code> where <code>ID=&gt;</code> is the identity functor.</p>
<h3 id="back-to-section-3">Back to section 3</h3>
<p>For convenience, the paper implicitly defines a type synonym for constructing arrows in the arrow category. This is called <code>_‚ÆÜ_</code> in the paper, but I hate unicode, so mine is defined as <code>=&gt;&gt;</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">infix</span> <span class="dv">0</span> <span class="ot">_</span>=&gt;&gt;<span class="ot">_</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="ot">_</span>=&gt;&gt;<span class="ot">_</span> <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>s1 t1 <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>          <span class="ot">{</span>s2 t2 <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    <span class="ot">‚Üí</span> <span class="ot">(</span>s1 <span class="ot">-&gt;</span> s2<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>t1 <span class="ot">-&gt;</span> t2<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>g =&gt;&gt; h <span class="ot">=</span> ArrowArr <span class="ot">(</span>arrow-obj g<span class="ot">)</span> <span class="ot">(</span>arrow-obj h<span class="ot">)</span></span></code></pre></div>
<p>With all of this machinery in place, we‚Äôre now ready to continue on the paper. We can construct a morphism in the arrow category corresponding to the fact that <code>&lt;+&gt;</code> is a model for <code>&lt;+F&gt;</code>, as witnessed by <code>toN-+F</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>+=&gt;&gt; <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat √ó Nat<span class="ot">}</span> <span class="ot">-&gt;</span> toN2 <span class="ot">{</span> suc m , n <span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span> m + n <span class="ot">}</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>+=&gt;&gt; <span class="ot">=</span> arrow-hom &lt;+F&gt; &lt;+&gt; $ extensionality toN-+F</span></code></pre></div>
<p>Again, the necessity of <code>extensionality</code> here is a byproduct of me not having parameterized my <code>Category</code> by a notion of equivalence. The arrow category wants to use extensional equality, but I‚Äôve hard-baked in propositional equality, and didn‚Äôt have time to fix it before my deadline to get this post out.</p>
<p>Although not presented in the paper, arrow categories also have a notion of ‚Äútransposition,‚Äù corresponding to flipping which arrows (in <code>SET</code>) lay on the horizontal and vertical axes. Because <code>_=&gt;&gt;_</code> names two arrows, leaving the other two implicit, transposition changes the type of our arrows ‚Äî making the implicit ones explicit and vice versa. We‚Äôll need this later in section 7.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>transpose <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> CommaObj<span class="ot">}</span> <span class="ot">((</span>comma-hom f g <span class="ot">_)</span> <span class="ot">:</span> CommaArr A B<span class="ot">)</span> <span class="ot">-&gt;</span> f =&gt;&gt; g</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>transpose <span class="ot">{</span>comma-obj h<span class="ot">}</span> <span class="ot">{</span>comma-obj h&#39;<span class="ot">}</span> <span class="ot">(</span>comma-hom f g p<span class="ot">)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="ot">=</span> comma-hom h h&#39; <span class="ot">(</span>sym p<span class="ot">)</span></span></code></pre></div>
<p>As an aside, it‚Äôs super cool that Agda can do this sort of pattern matching in a type signature.</p>
<h2 id="section-4-carry-in">Section 4: Carry-in</h2>
<p>In order to make non-unary adders compositional, we need to support carrying-in. The play is familiar. Define what we want (the specifiation) over the naturals, write it over <code>Fin</code>, and then give an equivalence proof. The paper defines some type synonyms:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>Nat3 <span class="ot">:</span> <span class="dt">Set</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>Nat3 <span class="ot">=</span> Nat √ó Nat2</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>Fin3 <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>Fin3 <span class="ot">(</span>m , n<span class="ot">)</span> <span class="ot">=</span> Fin m √ó Fin2 n</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>toN3 <span class="ot">:</span> <span class="ot">{(</span>c , m , n<span class="ot">)</span> <span class="ot">:</span> Nat3<span class="ot">}</span> <span class="ot">-&gt;</span> Fin3 <span class="ot">(</span>c , m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Nat3</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>toN3 <span class="ot">(</span>c , mn<span class="ot">)</span> <span class="ot">=</span> toN c , toN2 mn</span></code></pre></div>
<p>(where <code>Nat2</code> and <code>Fin2</code> are exactly what you‚Äôd expect.)</p>
<p>It‚Äôs easy to define the specification (<code>addN</code>), and implementation (<code>addF</code>), and the proof is trivial too:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>addN <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> Nat</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>addN <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c + a + b</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>addF <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> Fin3 <span class="ot">(</span><span class="dv">2</span> , m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>addF <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c +F a +F b</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>toN-addF <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>mn<span class="ot">@(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">‚Üí</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>     SET [ addF &gt;&gt; toN ] =o= SET [ toN3 &gt;&gt; addN ]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>toN-addF <span class="ot">{</span>mn<span class="ot">}</span> <span class="ot">(</span>c , a , b<span class="ot">)</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>  <span class="kw">rewrite</span> toN-+F <span class="ot">{</span>mn<span class="ot">}</span> <span class="ot">(</span>c +F a , b<span class="ot">)</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>        <span class="ot">|</span> toN-+F <span class="ot">(</span>c , a<span class="ot">)</span> <span class="ot">=</span> refl</span></code></pre></div>
<p>Bundling these up into an arrow proves that <code>addN</code> is a model for <code>addF</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>add=&gt;&gt;0 <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN3 <span class="ot">{</span><span class="dv">2</span> , m , n<span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span>m + n<span class="ot">}</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>add=&gt;&gt;0 <span class="ot">=</span> comma-hom addF addN $ extensionality toN-addF</span></code></pre></div>
<p>The paper also makes clear that we can show that <code>&lt;+&gt;</code> is a model for <code>addN</code> via <code>carryIn</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>carryIn <span class="ot">:</span> Nat3 <span class="ot">-&gt;</span> Nat2</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>carryIn <span class="ot">(</span>c , a , b<span class="ot">)</span> <span class="ot">=</span> c + a , b</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>addN=&gt;&gt; <span class="ot">:</span> carryIn =&gt;&gt; id <span class="ot">{</span>A <span class="ot">=</span> Nat<span class="ot">}</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>addN=&gt;&gt; <span class="ot">=</span> comma-hom addN &lt;+&gt; refl</span></code></pre></div>
<h2 id="commentary">Commentary</h2>
<p>At this point, it‚Äôs starting to become clear what this paper is really <em>about.</em> The idea is that we specify super simple pieces, and then build slightly more complicated things, showing equivalence to the last piece we built. In this way, we can slowly derive complexity. Not only does it give us a fool-proof means of getting results, but it also means we can reuse the proof work. As someone whose first real project in Agda was to implement and prove the correctness of a few adders, this is a godsend. I wrote a ripple-carry adder, but was unable to use my half-adder proof to prove it correctly implements addition. And then I had to throw all of that work away when I wanted to subsequently write and prove a carry-forward adder.</p>
<h2 id="section-5-category-stuff">Section 5: Category stuff</h2>
<p>This section shows we went through too much effort to implement <code>add=&gt;&gt;0</code>. Really what‚Äôs going on here is we‚Äôre doing three things in a row, for the specification, implementation and proof. First, we‚Äôre reassociating the tuple, from <code>N x (N x N)</code> to <code>(N x N) x N</code>. Then we‚Äôre doing addition on the first element of the pair, and then doing addition on the resulting pair.</p>
<p>This is all stuff you can do in any category with all finite products. But I was too lazy to implement that in full generality, so I hard-coded it. Because arrow categories lift products, and in <code>SET</code> products are just the product type, it‚Äôs easy to implement categorical objects:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">_</span>√óC<span class="ot">_</span> <span class="ot">:</span> Obj Comma <span class="ot">-&gt;</span> Obj Comma <span class="ot">-&gt;</span> Obj Comma</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="ot">_</span>√óC<span class="ot">_</span> <span class="ot">(</span>comma-obj <span class="ot">{</span>A1<span class="ot">}</span> <span class="ot">{</span>B1<span class="ot">}</span> f<span class="ot">)</span> <span class="ot">(</span>comma-obj <span class="ot">{</span>A2<span class="ot">}</span> <span class="ot">{</span>B2<span class="ot">}</span> g<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  comma-obj <span class="ot">{</span>A1 √ó A2<span class="ot">}</span> <span class="ot">{</span>B1 √ó B2<span class="ot">}</span> <span class="ot">Œª</span> <span class="ot">{</span> <span class="ot">(</span>x , y<span class="ot">)</span> <span class="ot">‚Üí</span> <span class="ot">(</span>f x , g y<span class="ot">)</span> <span class="ot">}</span></span></code></pre></div>
<p>And then we can implement <code>first</code> and <code>assoc</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>first <span class="ot">:</span>  <span class="ot">{</span>A B X <span class="ot">:</span> Obj Comma<span class="ot">}</span> <span class="ot">-&gt;</span> Comma [ A , B ] <span class="ot">-&gt;</span> Comma [ <span class="ot">(</span>A √óC X<span class="ot">)</span> , <span class="ot">(</span>B √óC X<span class="ot">)</span> ]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>first <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">{</span>X<span class="ot">}</span> <span class="ot">(</span>comma-hom f g p<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>  comma-hom <span class="ot">(</span>do-first f<span class="ot">)</span> <span class="ot">(</span>do-first g<span class="ot">)</span> $ cong <span class="ot">(\</span>k <span class="ot">(</span>a , x<span class="ot">)</span> <span class="ot">-&gt;</span> k a , xf x<span class="ot">)</span> p</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    do-first <span class="ot">:</span> <span class="ot">{</span>A B X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B<span class="ot">)</span> <span class="ot">-&gt;</span> A √ó X <span class="ot">-&gt;</span> B √ó X</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    do-first f <span class="ot">=</span> <span class="ot">(Œª</span> <span class="ot">{</span> <span class="ot">(</span>a , x<span class="ot">)</span> <span class="ot">‚Üí</span> f a , x <span class="ot">})</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>assoc <span class="ot">:</span> <span class="ot">{</span>A B X <span class="ot">:</span> Obj Comma<span class="ot">}</span> <span class="ot">-&gt;</span> Comma [ A √óC <span class="ot">(</span>B √óC X<span class="ot">)</span> , <span class="ot">(</span>A √óC B<span class="ot">)</span> √óC X ]</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>assoc <span class="ot">=</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>  comma-hom reassoc reassoc ?</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    reassoc <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> A √ó <span class="ot">(</span>B √ó C<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A √ó B<span class="ot">)</span> √ó C</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>    reassoc <span class="ot">=</span> <span class="ot">(Œª</span> <span class="ot">{</span> <span class="ot">(</span>a , b , c<span class="ot">)</span> <span class="ot">‚Üí</span> <span class="ot">(</span>a , b<span class="ot">)</span> , c <span class="ot">})</span></span></code></pre></div>
<p>where the proof is left as an exercise to the reader :)</p>
<p>We can now implement <code>add=&gt;&gt;</code> more succinctly:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>add=&gt;&gt; <span class="ot">:</span> <span class="ot">{(</span>m , n<span class="ot">)</span> <span class="ot">:</span> Nat2<span class="ot">}</span> <span class="ot">-&gt;</span> toN3 <span class="ot">{</span><span class="dv">2</span> , m , n<span class="ot">}</span> =&gt;&gt; toN <span class="ot">{</span>m + n<span class="ot">}</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>add=&gt;&gt; <span class="ot">=</span> Comma [ Comma [ assoc &gt;&gt; first +=&gt;&gt; ] &gt;&gt; +=&gt;&gt; ]</span></code></pre></div>
<p>While this is cool, I must admit I‚Äôm a little confused. Do <code>first</code> and <code>assoc</code> have most-general types when expressd via <code>_=&gt;&gt;_</code>? Thinking aloud here, I think not. Using the <code>_=&gt;&gt;_</code> notation is for choosing two <em>particular</em> morphisms in <code>SET</code>, while using the more general <code>COMMA [ X , Y ]</code> is for <em>any</em> pair morphisms in <code>SET</code> with the right type. But I‚Äôm not confident about this.</p>
<h2 id="section-6-carrying-out">Section 6: Carrying out</h2>
<p>Carry-in is great, but what about going the other direction?</p>
<p>Elliott starts by makig the following observation: if we fix <code>m = n</code>, then the type of our finitary adder is <code>Fin2 (m , m) -&gt; Fin (m + m)</code>, which we can rewrite the codomain as <code>Fin (2 * m)</code> and then reinterpret as <code>Fin 2 x Fin m</code>. That is to say, the type of finitary adding is to output a single digit in base <code>m</code>, and a bit corresponding to whether or not a carry occurred. This is a great little reminder in the value of type isomorphisms. How cool is it that we can get carry-outs for free just with some algebraic manipulations?</p>
<p>Of course, the trick is to prove it. Start by defining two helper type synonyms:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>CarryIn <span class="ot">:</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>CarryIn m <span class="ot">=</span> Fin3 <span class="ot">(</span><span class="dv">2</span> , m , m<span class="ot">)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>CarryOut <span class="ot">:</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>CarryOut m <span class="ot">=</span> Fin2 <span class="ot">(</span><span class="dv">2</span> , m<span class="ot">)</span></span></code></pre></div>
<p>Elliott presents the following ‚Äúpuzzle‚Äù of a commutative diagram:</p>
<pre><code>              addF
CarryIn m   --------&gt; Fin (m + m)
   ^                      ^
id |                      | ?
   |           ?          |
CarryIn m   --------&gt; Fin (2 * m)
   ^                      ^
id |                      | ?
   |           ?          |
CarryIn m   --------&gt; CarryOut m</code></pre>
<p>It‚Äôs unclear how exactly one formulates these diagrams in the first place. I guess the top is pinned by <code>addF</code>, while the bottom corners are pinned by our desired carrying out. The middle is thus the isomorphism presented immediately before this. All of that makes sense, but I‚Äôm not convinced I could reproduce it on my own yet.</p>
<p>So the game now is to fill in the question marks. I don‚Äôt know how to get Agda to help me with this, so I‚Äôm just going to try literally putting question marks in and seeing what happens. When doing that, we get this:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>puzzle1 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>       <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>   <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>                , comma-obj <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> <span class="ot">{</span>Fin <span class="ot">(</span>m + m<span class="ot">)}</span> ?</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>                ]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>puzzle1 <span class="ot">=</span> comma-hom ? addF ?</span></code></pre></div>
<p>Figuring out the first question-mark is simple enough, it‚Äôs an isomorphism on <code>Fin</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>n+zero <span class="ot">:</span> <span class="ot">(</span>n <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> n + zero == n</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>n+zero zero <span class="ot">=</span> refl</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>n+zero <span class="ot">(</span>suc n<span class="ot">)</span> <span class="kw">rewrite</span> n+zero n <span class="ot">=</span> refl</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>2*m==m+m <span class="ot">:</span> <span class="ot">(</span>m <span class="ot">:</span> Nat<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)</span> == m + m</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>2*m==m+m zero <span class="ot">=</span> refl</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>2*m==m+m <span class="ot">(</span>suc m<span class="ot">)</span> <span class="kw">rewrite</span> 2*m==m+m m <span class="ot">|</span> n+zero m <span class="ot">=</span> refl</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>castF <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>m == n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin m <span class="ot">-&gt;</span> Fin n</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>castF p <span class="kw">rewrite</span> p <span class="ot">=</span> id</span></code></pre></div>
<p>Our first hole is thus <code>cast $ 2*m==m+m m</code>. Interestingly, this doesn‚Äôt refine our other hole, since it‚Äôs already fully specified by the vertial components of <code>idA</code> and the horizontal component of <code>addF</code>. However, as the paper points out, we can get the second hole for free. Because <code>cast</code> is invertable, we can make this square commute by taking <code>id &gt;&gt; addF &gt;&gt; cast-1</code>. It feels a bit like cheating, but it does indeed satisfy the commutativity diagram:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>puzzle1 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>       <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>   <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>                , comma-obj <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> <span class="ot">{</span>Fin <span class="ot">(</span>m + m<span class="ot">)}</span> <span class="ot">(</span>cast $ 2*m==m+m m<span class="ot">)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>                ]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>puzzle1 <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  comma-hom</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>    <span class="ot">(</span>SET [ addF &gt;&gt; cast $ sym $ 2*m==m+m m ]<span class="ot">)</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>    addF</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>    ?</span></code></pre></div>
<p>where the proof is trivial (but I don‚Äôt know how to make it terse):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>   SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; cast $ 2*m==m+m m ]</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>== SET [ id &gt;&gt; addF ]</span></code></pre></div>
<p>Probably there is a category of proofs, where I can just do <code>reassoc &gt;&gt; second sym (sym-is-id $ 2*m==m+m m) &gt;&gt; id-r addF &gt;&gt; sym (id-l addF)</code>. But I don‚Äôt have that setup, and this would be annoying to do in the equational reasoning style. So it remains a hole, and you, gentle reader, can fill it in if you are keen. Also, I‚Äôd love to know how to write a proof as simple as my sketch above.</p>
<p>So that gives us the first half of our puzzle. Now that we have the middle arrow, let‚Äôs play the same game:</p>
<pre><code>                          addF
CarryIn m   -------------------------------&gt; Fin (m + m)
   ^                                           ^
id |                                           | cast $ 2*m==m+m m
   |                                           |
   |          addF &gt;&gt; cast (sym (2*m==m+m m))  |
CarryIn m   -------------------------------&gt; Fin (2 * m)
   ^                                           ^
id |                                           | ?
   |                       ?                   |
CarryIn m   -----------------------------&gt; CarryOut m</code></pre>
<p>So how do we turn a <code>CarryOut m = Fin2 (2 , m)</code> into a <code>Fin (2 * m)</code>? Algebraically I think this is a bit tricky, but thankfully <code>Data.Fin.Base</code> has us covered:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>combine <span class="ot">:</span> <span class="ot">‚àÄ</span> <span class="ot">{</span>n k<span class="ot">}</span> <span class="ot">‚Üí</span> Fin n <span class="ot">‚Üí</span> Fin k <span class="ot">‚Üí</span> Fin <span class="ot">(</span>n * k<span class="ot">)</span></span></code></pre></div>
<p>which we can uncurry:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>comb <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Fin2 <span class="ot">(</span>m , n<span class="ot">)</span> <span class="ot">-&gt;</span> Fin <span class="ot">(</span>m * n<span class="ot">)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>comb <span class="ot">(</span>f1 , f2<span class="ot">)</span> <span class="ot">=</span> combine f1 f2</span></code></pre></div>
<p>and then use this to fill in the vertical arrow. Because <code>comb</code> is one half of an isomorphism (the other half is formed by <code>remQuot : ‚àÄ {n} k ‚Üí Fin (n * k) ‚Üí Fin n √ó Fin k</code>), we can do the same trick to get the horizontal arrow for free:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>puzzle2 <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>      <span class="ot">-&gt;</span> Comma [ comma-obj <span class="ot">{</span>CarryIn m<span class="ot">}</span>  <span class="ot">{</span>CarryIn m<span class="ot">}</span>   id</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>               , comma-obj <span class="ot">{</span>CarryOut m<span class="ot">}</span> <span class="ot">{</span>Fin <span class="ot">(</span><span class="dv">2</span> * m<span class="ot">)}</span> comb</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>               ]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>puzzle2 <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>  comma-hom</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>    <span class="ot">(</span>SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; remQuot m ]<span class="ot">)</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>    <span class="ot">(</span>SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ]<span class="ot">)</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>    ?</span></code></pre></div>
<p>The proof is again trivial but verbose.</p>
<p>Let‚Äôs call the implementation arrow <code>addCarry</code>, because we‚Äôll need it in section 8.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>addCarry <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> SET [ CarryIn m , CarryOut m ]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>addCarry <span class="ot">{</span>m<span class="ot">}</span> <span class="ot">=</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>  SET [ SET [ addF &gt;&gt; cast <span class="ot">(</span>sym <span class="ot">(</span>2*m==m+m m<span class="ot">))</span> ] &gt;&gt; remQuot m ]</span></code></pre></div>
<h2 id="section-7-vertical-composition">Section 7: Vertical composition</h2>
<p>Finally, we can use <em>vertical</em> composition to combine our two puzzles:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>puzzle <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> id =&gt;&gt; <span class="ot">(</span>cast <span class="ot">(</span>2*m==m+m m<span class="ot">)</span> ‚àò comb <span class="ot">{</span><span class="dv">2</span><span class="ot">}</span> <span class="ot">{</span>m<span class="ot">})</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>puzzle <span class="ot">=</span> transpose $ Comma [ transpose puzzle2 &gt;&gt; transpose puzzle1 ]</span></code></pre></div>
<p>using our <code>transpose</code> machinery from earlier. Vertical composition composes along the axis of specification ‚Äî if the implementation of one arrow matches the specification another, we can combine them into one.</p>
<h2 id="section-8-moving-away-from-unary-representations">Section 8: Moving away from unary representations</h2>
<p>Unary sucks. Let‚Äôs generalize our adding machinery to any arbitrary type. First we‚Äôll make types corresponding to <code>CarryIn</code> and <code>CarryOut</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>DIn <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>DIn t <span class="ot">=</span> Bool √ó t √ó t</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>DOut <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>DOut t <span class="ot">=</span> t √ó Bool</span></code></pre></div>
<p>I‚Äôm going to go rogue for a while, and try to do this section without referencing the paper. We want to make a morphism in the arrow category corresponding to using <code>addCarry</code> as the specification for addition over <code>DIn</code> and <code>DOut</code>. Let‚Äôs play the same puzzle game, and set up a commutative diagram.</p>
<p>At the top is our specification, <code>addCarry : CarryIn m -&gt; CarryOut m</code>. That then pins our top two objects, and obviously our bottom two are <code>DIn t</code> and <code>DOut t</code>:</p>
<pre><code>                          addCarry
              CarryIn m  ---------&gt;  CarryOut m
                 ^                      ^
 bval x (Œº x Œº)  |                      | Œº x bval
                 |         addD         |
               DIn t  -------------&gt;  DOut t</code></pre>
<p>where <code>bval : Bool -&gt; Fin 2</code>. Here, <code>Œº</code> plays the part of <code>toNat</code>, and <code>addD</code> is addition over <code>D t</code>-indexed numbers.</p>
<p>We can package this up into a record indexed by <code>Œº</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">record</span> Adder <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">(</span>Œº <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>  <span class="kw">constructor</span> <span class="ot">_</span>-|<span class="ot">_</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>    addD <span class="ot">:</span> DIn t <span class="ot">-&gt;</span> DOut t</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>    is-adder <span class="ot">:</span> SET [ addD &gt;&gt; bimap Œº bval ]</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>            == SET [ bimap bval <span class="ot">(</span>bimap Œº Œº<span class="ot">)</span> &gt;&gt; addCarry ]</span></code></pre></div>
<p>and trivially construct the desired commutative diagram from an <code>Adder</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>Adder=&gt;&gt; <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">{</span>Œº <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">}</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>        <span class="ot">-&gt;</span> Adder Œº</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>        <span class="ot">-&gt;</span> bimap bval <span class="ot">(</span>bimap Œº Œº<span class="ot">)</span> =&gt;&gt; bimap Œº bval</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>Adder=&gt;&gt; <span class="ot">(</span>addD -| proof<span class="ot">)</span> <span class="ot">=</span> comma-hom addD addCarry proof</span></code></pre></div>
<p>So let‚Äôs implement a full-adder. This is a ‚Äúwell-known‚Äù result, but I didn‚Äôt know it offhand. I‚Äôm sure I could have sussed this out on my own, but instead I just found it on Wikipedia:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>and <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>and true b <span class="ot">=</span> b</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>and false b <span class="ot">=</span> false</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>or <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>or true b <span class="ot">=</span> true</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>or false b <span class="ot">=</span> b</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>xor <span class="ot">:</span> Bool <span class="ot">-&gt;</span> Bool <span class="ot">-&gt;</span> Bool</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true"></a>xor true true <span class="ot">=</span> false</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true"></a>xor true false <span class="ot">=</span> true</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true"></a>xor false true <span class="ot">=</span> true</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true"></a>xor false false <span class="ot">=</span> false</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true"></a>full-add <span class="ot">:</span> DIn Bool <span class="ot">-&gt;</span> DOut Bool</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true"></a>full-add <span class="ot">(</span>cin , a , b<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true"></a>  <span class="kw">let</span> o <span class="ot">=</span> xor a b</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true"></a>   <span class="kw">in</span> xor o cin , or <span class="ot">(</span>and a b<span class="ot">)</span> <span class="ot">(</span>and o cin<span class="ot">)</span></span></code></pre></div>
<p>We can construct an <code>Adder</code> for <code>full-add</code> with observation <code>bval</code> by case-bashing our way through the proof:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>BitAdder <span class="ot">:</span> Adder bval</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>BitAdder <span class="ot">=</span> full-add -| extensionality</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>  <span class="ot">\</span> <span class="ot">{</span> <span class="ot">(</span>false , false , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>false , false , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>false , true , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>false , true , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>true , false , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>true , false , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>true , true , false<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true"></a>    <span class="ot">;</span> <span class="ot">(</span>true , true , true<span class="ot">)</span> <span class="ot">-&gt;</span> refl</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true"></a>    <span class="ot">}</span></span></code></pre></div>
<p>The next step is obviously to figure out how to compose <code>Adder</code>s ‚Äî ideally to construct adders for vectors. But I don‚Äôt know how to do this offhand. So it‚Äôs time to look back at the paper.</p>
<p>OK, right. So we have an obvious tensor over <code>Œº</code>, which is just to lift two of them over a pair:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>tensorŒº</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>tm tn <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">{</span>m n <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tm <span class="ot">-&gt;</span> Fin m<span class="ot">)</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tn <span class="ot">-&gt;</span> Fin n<span class="ot">)</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>tm √ó tn <span class="ot">-&gt;</span> Fin <span class="ot">(</span>n * m<span class="ot">))</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>tensorŒº Œºm Œºn <span class="ot">(</span>tm , tn<span class="ot">)</span> <span class="ot">=</span> comb $ Œºn tn , Œºm tm</span></code></pre></div>
<p>Likewise, we have one over the adding functions themselves, pushing the carry-out of one into the carry-in of the next:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>tensorAdd</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn m <span class="ot">-&gt;</span> DOut m<span class="ot">)</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn n <span class="ot">-&gt;</span> DOut n<span class="ot">)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>DIn <span class="ot">(</span>m √ó n<span class="ot">)</span> <span class="ot">-&gt;</span> DOut <span class="ot">(</span>m √ó n<span class="ot">))</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>tensorAdd addm addn <span class="ot">(</span>cin , <span class="ot">(</span>ma , na<span class="ot">)</span> , <span class="ot">(</span>mb , nb<span class="ot">))</span> <span class="ot">=</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a>  <span class="kw">let</span> <span class="ot">(</span>m , cin&#39;<span class="ot">)</span> <span class="ot">=</span> addm $ cin  , ma , mb</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>      <span class="ot">(</span>n , cout<span class="ot">)</span> <span class="ot">=</span> addn $ cin&#39; , na , nb</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true"></a>   <span class="kw">in</span> <span class="ot">(</span>m , n<span class="ot">)</span> , cout</span></code></pre></div>
<p>Allegedly these form a true adder as witnessed by <code>Adder (tensorŒº Œºm Œºn)</code>, but the proof isn‚Äôt included in the paper, and I had a hard time tracking it down in the source code. So rather than taking this by fiat, let‚Äôs see if we can convince ourselves.</p>
<p>As a first attempt of convincing myself, I tried to construct <code>adder22 : Adder (tensorŒº bval bval)</code> which is a tensor of two full-adders. I constructed a case bash for the proof, and Agda complained! After some sleuthing, I had missed a swap somewhere in the paper, and thus had my carry bit in the wrong place in <code>full-adder</code>.</p>
<p>After sorting that out, the case bash works on <code>adder22</code>. So that‚Äôs a good sanity check that this works as promised. But, why? Presuably I should be able to run my commutative diagram all the way to its specification to debug what‚Äôs going on.</p>
<p>A few hours later‚Ä¶</p>
<p>I came up with the following, which can run a commutative diagram:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>arrowOf <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> CommaObj<span class="ot">}</span> <span class="ot">-&gt;</span> CommaArr A B <span class="ot">-&gt;</span> CommaObj √ó CommaObj</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>arrowOf <span class="ot">{</span>A<span class="ot">}</span> <span class="ot">{</span>B<span class="ot">}</span> <span class="ot">_</span> <span class="ot">=</span> A , B</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>debug <span class="ot">:</span> <span class="ot">{</span>A B C D <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>f <span class="ot">:</span> A <span class="ot">-&gt;</span> B<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{</span>g <span class="ot">:</span> C <span class="ot">-&gt;</span> D<span class="ot">}</span> <span class="ot">-&gt;</span> f =&gt;&gt; g <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> D</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>debug arr x <span class="ot">=</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>  <span class="kw">let</span> <span class="ot">(_</span> , comma-obj y<span class="ot">)</span> <span class="ot">=</span> arrowOf arr</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a>      <span class="ot">(</span>comma-hom f <span class="ot">_</span> <span class="ot">_)</span> <span class="ot">=</span> arr</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a>  <span class="kw">in</span> y <span class="ot">(</span>f x<span class="ot">)</span></span></code></pre></div>
<p>Of course, the diagrams we get from <code>Adder=&gt;&gt;</code> only get us as far as <code>addCarry</code>. In order to get all the way to <code>Nat</code>s, we need to vertically compose a bunch of other diagrams too. In order, they‚Äôre <code>puzzle</code>, <code>addF=&gt;&gt;</code> and <code>addN=&gt;&gt;</code>. The actual diagram I came up with was this attrocious thing:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a>Adder=&gt;&gt;N</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>    <span class="ot">:</span> Cat2<span class="ot">.</span>CommaArr<span class="ot">.</span>f</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>        <span class="ot">(</span>Comma [</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true"></a>         Comma [ Comma [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span> &gt;&gt; transpose puzzle ]</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true"></a>         &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true"></a>         &gt;&gt; transpose addN=&gt;&gt; ]<span class="ot">)</span> =&gt;&gt; Cat2<span class="ot">.</span>CommaArr<span class="ot">.</span>g</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true"></a>                 <span class="ot">(</span>Comma [</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true"></a>                  Comma [ Comma [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true"></a>                               &gt;&gt; transpose puzzle ]</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true"></a>                  &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true"></a>                  &gt;&gt; transpose addN=&gt;&gt; ]<span class="ot">)</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true"></a>Adder=&gt;&gt;N <span class="ot">=</span> transpose $</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true"></a>  Comma</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true"></a>    [ Comma</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true"></a>    [ Comma</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true"></a>    [ transpose <span class="ot">(</span>Adder=&gt;&gt; adder22<span class="ot">)</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true"></a>   &gt;&gt; transpose puzzle ]</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true"></a>   &gt;&gt; transpose addF=&gt;&gt; ]</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true"></a>   &gt;&gt; transpose addN=&gt;&gt; ]</span></code></pre></div>
<p>and finally, I can evaluate the thing:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>debug&#39; <span class="ot">:</span> Nat</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a>debug&#39; <span class="ot">=</span> debug Adder=&gt;&gt;N <span class="ot">(</span>false , <span class="ot">(</span>true , false<span class="ot">)</span> , <span class="ot">(</span>true , false<span class="ot">))</span></span></code></pre></div>
<p>Nice. OK, so back to answering the question. Each of the <code>Bool x Bool</code> tuples is a little-endian vector, which get added together, plus the carry. In the process of doing all of this work, I inadvertantly figured out how the tensoring works. What‚Äôs more interesting is tensoring together two different adders. For example, the <code>trivial-add</code> (section 8.3):</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="kw">data</span> One <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>  one <span class="ot">:</span> One</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>oneval <span class="ot">:</span> One <span class="ot">-&gt;</span> Fin <span class="dv">1</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>oneval one <span class="ot">=</span> zero</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>trivial-add <span class="ot">:</span> DIn One <span class="ot">-&gt;</span> DOut One</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a>trivial-add <span class="ot">(</span>b , <span class="ot">_</span> , <span class="ot">_)</span> <span class="ot">=</span> one , b</span></code></pre></div>
<p>If we construct <code>tensorAdder trivial-add BitAdder</code>, we get an adder whose vectors are <code>One x Bool</code>. This is an extremely interesting representation, as it means our number system doesn‚Äôt need to have the same base for each digit. In fact, that‚Äôs where the compositionality comes from. We‚Äôre pretty comfortable assigning <code>2^i</code> to each digit position, but this representation makes it clear that there‚Äôs nothing stopping us from choosing arbitrary numbers. What‚Äôs really doing the work here is our old friend <code>comb : {m n : Nat} -&gt; Fin2 (m , n) -&gt; Fin (n * m)</code>. Expanding the type synonym makes it a little clearer <code>comb : {m n : Nat} -&gt; Fin m x Fin n -&gt; Fin (n * m)</code> ‚Äî this thing is literally multiplying two finite numbers into one!</p>
<p>Looking at <code>tensorAdd</code> under this new lens makes it clearer too. Recall:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a>tensorAdd addm addn <span class="ot">(</span>cin , <span class="ot">(</span>ma , na<span class="ot">)</span> , <span class="ot">(</span>mb , nb<span class="ot">))</span> <span class="ot">=</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>  <span class="kw">let</span> <span class="ot">(</span>m , cin&#39;<span class="ot">)</span> <span class="ot">=</span> addm $ cin  , ma , mb</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true"></a>      <span class="ot">(</span>n , cout<span class="ot">)</span> <span class="ot">=</span> addn $ cin&#39; , na , nb</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true"></a>   <span class="kw">in</span> <span class="ot">(</span>m , n<span class="ot">)</span> , cout</span></code></pre></div>
<p>Here we‚Äôre pointwise adding the digits, where <code>m</code> is the least significant of the two digits. Our carry-in goes into the <code>m</code>, and its carry-out goes into <code>n</code>. OK, so this thing is just doing adder-chaining.</p>
<p>Section 8.4 talks about extending this to vectors, but the trick is just to fold them via <code>tensorAdd</code>. The paper uses a right-fold. I‚Äôm curious about what happens if you do a left fold, but might circle back around to that question since I only have a few more hours to get this post out and I want to spend some time <em>in</em> Mexico while I‚Äôm here. Upon deeper thought, I don‚Äôt think anythig would change ‚Äî we‚Äôd still get a ripple carry adder. Worth playing around with though.</p>
<h2 id="section-9-speculation">Section 9: Speculation</h2>
<p>Section 9 is the most exciting part of the paper in my eyes. It defines speculation, which Elliott uses to implement a carry-ahead adder. I think the paper cheats a bit in this section ‚Äî and makes it clear that we might have been cheating a bit earlier too. But first some preliminaries. The paper defines <code>speculate</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>speculate <span class="ot">:</span> <span class="ot">{</span>A C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Bool √ó A <span class="ot">-&gt;</span> C<span class="ot">)</span> <span class="ot">-&gt;</span> <span class="ot">(</span>Bool √ó A <span class="ot">-&gt;</span> C<span class="ot">)</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a>speculate f <span class="ot">(</span>b , a<span class="ot">)</span> <span class="ot">=</span> if b then f <span class="ot">(</span>true , a<span class="ot">)</span> else f <span class="ot">(</span>false , a<span class="ot">)</span></span></code></pre></div>
<p>This looks like it should be a no-op, and indeed, there‚Äôs a trivial proof that <code>speculate f =o= f</code>. The trick then is to lift <code>speculate</code> over an adder:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>spec</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>t <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">{</span>m <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">{</span>Œº <span class="ot">:</span> t <span class="ot">-&gt;</span> Fin m<span class="ot">}</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> Adder Œº</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> Adder Œº</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>spec <span class="ot">(</span>adder -| proof<span class="ot">)</span> <span class="ot">=</span> speculate adder -| ?</span></code></pre></div>
<p>and the claim is that if we now do the same vector fold over <code>spec a</code> instead of <code>a</code>, we will get a carry-ahead adder! Sorcery! Magic!</p>
<p>But also‚Ä¶ wat? Is that actually true?</p>
<p>I think here is where the paper is playing fast and loose. In <code>SET</code>, <code>speculate a</code> is exactly <code>a</code>. But the paper shows us a circuit diagram for this speculated fold, and it does indeed show the right behavior. So what‚Äôs going on?</p>
<p>What‚Äôs going on is that the paper isn‚Äôt actually working in <code>SET</code>. Well, it is. Sorta. In fact, I think there‚Äôs some fancy-pants compiling-to-categories going on here. In the same way that <code>xor</code> presented above is a <code>SET</code>-equivalent version of the <code>xor</code> operation in the <code>CIRCUIT</code> category (but is not actually <code>xor</code> in <code>CIRCUIT</code>), <code>if_then_else_</code> is actually the <code>SET</code> version of an equivalent operation in <code>CIRCUIT</code>. In <code>CIRCUIT</code>, <code>if_then_else_</code> is actually implemented as inlining both its true and false branches, and switching between them by <code>and</code>ing their outputs against the conditional.</p>
<p>So, the carry-ahead adder is not nearly as simple as it‚Äôs presented in this paper. There‚Äôs a huge amount of work going on behind the scenes:</p>
<ol type="1">
<li>defining the <code>CIRCUIT</code> category</li>
<li>implementing <code>if_then_else_</code> in <code>CIRCUIT</code></li>
<li>showing that the arrow category lifts <code>if_then_else_</code></li>
</ol>
<p>Furthermore, I‚Äôm not exactly sure how this all <em>works.</em> Like, when we define <code>speculate</code> as <code>if b then f (true , a) else f (false , a)</code>, are we literally inlining <code>f</code> with the conditional fixed, and <em>simplfying</em> the resulting circuit? I mean, we could just fix <code>true</code> by tying it to <code>HIGH</code>, but the diagrams included in the paper don‚Äôt appear to do that. If so, who is responsible for simplfying? Does it matter? This is a big hole in the paper, and in my opinion, greatly diminishes its impact, since it‚Äôs the claim I was most excited about.</p>
<p>To the paper‚Äôs credit, the vector fold and speculative fold turn into nice combinators, and give us a little language for building adders, which is extremely cool.</p>
<h2 id="section-10-reusing-circuitry-over-time">Section 10: Reusing circuitry over time</h2>
<p>Ripple-carry adders are slow but use few gates. Carry-ahead adders are much faster, but use asymptotically more gates. Clearly there is a tradeoff here between latency and manufacturing cost. Section 10 gives us another point in the design space where we just build one full-adder, and loop it into itself. This also sounds exciting, but I‚Äôm a bit wary after section 9.</p>
<p>And as presented, I don‚Äôt think I trust the paper to deliver on this front. There is some finagling, but at it‚Äôs core, we are given a looping construct:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a>loop</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>A B S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="ot">(</span>S √ó A <span class="ot">-&gt;</span> B √ó S<span class="ot">)</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>   <span class="ot">-&gt;</span> S √ó Vec A n</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a>   <span class="ot">-&gt;</span> Vec B n √ó S</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a>loop f <span class="ot">(</span>s , nil<span class="ot">)</span> <span class="ot">=</span> nil , s</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>loop f <span class="ot">(</span>s , cons a v<span class="ot">)</span> <span class="ot">=</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true"></a>  <span class="kw">let</span> b , s&#39; <span class="ot">=</span> f <span class="ot">(</span>s , a<span class="ot">)</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true"></a>   <span class="kw">in</span> bimap <span class="ot">(</span>cons b<span class="ot">)</span> id <span class="ot">(</span>loop f <span class="ot">(</span>s&#39; , v<span class="ot">))</span></span></code></pre></div>
<p>Thinking about what this would mean in <code>CIRCUIT</code> makes it unclear how we would go about implementing such a thing in real hardware ‚Äî especially so if the embedding sticks <code>f</code> into the hardware and then loops over it over time. You‚Äôre going to need some sort of ring buffer to read off the outputs and stick them in the resulting vector. You‚Äôre going to need timing signals to know when your ring buffer is consistent. There‚Äôs clearly a lot going on in this section that is left unsaid, and there aren‚Äôt even any pretty pictures to help us reverse engineer the missing bits.</p>
<p>So I‚Äôm going to leave it there.</p>
<h2 id="conclusion">Conclusion</h2>
<p><em>Adders and Arrows</em> was a fun paper to go through. It forced me to up my category game, and I got a much better sense of what the arrow category does, and how it can be useful. Furthermore, just going through a non-trivial project aggressively improved my Agda competencies, and I‚Äôm excited to do more along these lines.</p>
<p>The paper itself is a bit too terse for my liking. I would have liked a section saying ‚Äúhere‚Äôs what we‚Äôre going to do, and here‚Äôs how we‚Äôre going to go about it,‚Äù rather than just being thrown in and trying to deduce this for myself. In particular, it took me an embarassing amount of time to realize how to get natural numbers out of my adder arrows, and why the first 6 sections were worth having done.</p>
<p>Technically, I found the ergonomics of working with arrow-category arrows very challenging. Two of the <code>SET</code> morphisms show up in the type, but the other two show up as values, and there is no easy way to see which diagrams can be vertically composed. My <code>Adder=&gt;&gt;N</code> arrow abve shows the pain of trying to give a type to such a thing.</p>
<p>I had two major points of complaint about this paper. The first is that the source code isn‚Äôt very accessible. It exists in a repo, but is scattered around a bunch of modules and whenever I wanted to find something I resorted to just looking at each ‚Äî being unable to make rhyme or reason of how things were organized. Worse, a huge chunk of the underlying machinery is in a separate repo, one which is significantly more advanced in its Agda usage than I am. A proliferation of weird unicode symbols that aren‚Äôt the ones that show up in the PDF make this especially challenging to navigate.</p>
<p>My other major complaint is that sections 9 and 10 were extremely underwhelming, though. If the paper does what it promises, it doesn‚Äôt actually show <em>how.</em> There is a lot going on behind the scenes that aren‚Äôt even alluded to in the paper. Granted, the version I‚Äôm reading is a draft, so hopefully this will be cleared up.</p>
<p>I don‚Äôt yet have a major takeaway from this paper, other than that arrow categories are cool for specifying problems and proving that your implementations adhere to those specifications. But as implemented, for my given adeptness at Agda, they are too hard to use. Composition is tricky to wrap ones head around given the type signatures used in this paper, but hopefully that‚Äôs an aesthetic problem more than a fundamental issue. In particular, <code>tranpose</code> needs to have type <code>CommaArr A B C D -&gt; CommaArr C D A B</code> ‚Äî this would make vertical and horizontal composition much easier to think about.</p>
<p>All in all, powering through this paper has given me some new tools for thought, and helped me see how category theory might be useful to mere mortals.</p>
<p><a href="https://github.com/isovector/agda-playground/blob/88dabf47b5e251cad55dd4cce3b54df5ab4aff13/AddArrows.agda">My implementation of this code is available on Github.</a></p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Automatically Migrating Eq of No (/=)</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/comby/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/comby/index.html</guid>
      <pubDate>2021-11-21T13:38:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>We‚Äôve all spent more time <a href="/blog/century-of-the-fruitbat/">talking</a> about <a href="https://github.com/haskell/core-libraries-committee/issues/3"><code>Eq</code> of no <code>(/=)</code></a> than it deserves. Today Bodigrim published <a href="https://github.com/haskell/core-libraries-committee/blob/main/guides/no-noneq-in-eq.md">Migration guide for Eq of no <code>(/=)</code></a> which describes all the steps you‚Äôll need to take in order to update your codebase for the century of the fruitbat.</p>
<p>But that made me think ‚Äî why do humans need to do this by hand? Computers are good at this sort of thing. So I wrote a tiny little <a href="https://comby.dev/">comby</a> config that does the replacements we want. Comby is a fantastic ‚Äúparser parser combinator‚Äù ‚Äî which is to say, a little DSL for writing program transformations. You just write the pattern you want to match, and comby lifts it to work over whitespace, and ensures that your greedy matches are parenthesis-aware, and that sort of thing. It‚Äôs quite lovely. The config I wrote is listed at the end of this post.</p>
<p>Here‚Äôs a problematic module that will be very broken by <code>Eq</code> of no <code>(/=)</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">Neq</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Prelude</span> (<span class="dt">Eq</span> (..), <span class="dt">Bool</span>(..), (||))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.Eq</span> (<span class="dt">Eq</span> (..))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span> <span class="dt">Bool</span> <span class="dt">Bool</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">A</span> <span class="kw">where</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="dt">A</span> x1 x2 <span class="op">/=</span> <span class="dt">A</span> y1 y2 <span class="ot">=</span> x1 <span class="op">/=</span> y1 <span class="op">||</span> x2 <span class="op">/=</span> x2</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">B</span> <span class="dt">Bool</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">B</span> <span class="kw">where</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>  <span class="dt">B</span> x <span class="op">==</span> <span class="dt">B</span> y <span class="ot">=</span> x <span class="op">==</span> y</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>  <span class="dt">B</span> x <span class="op">/=</span> <span class="dt">B</span> y <span class="ot">=</span> x <span class="op">/=</span> y</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">C</span> a <span class="ot">=</span> <span class="dt">C</span> a</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="kw">instance</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>  <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">C</span> a)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>  <span class="dt">C</span> x <span class="op">==</span> <span class="dt">C</span> y <span class="ot">=</span> x <span class="op">==</span> y</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>  <span class="dt">C</span> x <span class="op">/=</span> <span class="dt">C</span> y <span class="ot">=</span> x <span class="op">/=</span> y</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">D</span> <span class="ot">=</span> <span class="dt">D</span> <span class="dt">Bool</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">D</span> <span class="kw">where</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>  <span class="dt">D</span> x <span class="op">/=</span> <span class="dt">D</span> y <span class="ot">=</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    x <span class="op">/=</span> y</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>  <span class="dt">D</span> x <span class="op">==</span> <span class="dt">D</span> y <span class="ot">=</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>    x <span class="op">==</span> y</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">E</span> <span class="ot">=</span> <span class="dt">E</span> <span class="dt">Bool</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">E</span> <span class="kw">where</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>  <span class="dt">E</span> x <span class="op">/=</span> <span class="dt">E</span> y <span class="ot">=</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>    <span class="kw">let</span> foo <span class="ot">=</span> x <span class="op">/=</span> y <span class="kw">in</span> foo</span></code></pre></div>
<p>After running <code>comby</code>, we get the following diff:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a> module Neq where</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">-import Prelude (Eq (..), Bool)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="st">-import Data.Eq (Eq (..))</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="st">-</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="st">-data A = A Bool</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="va">+import Prelude (Eq, (==), (/=), Bool(..), (||))</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="va">+import Data.Eq (Eq, (==), (/=))</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="va">+data A = A Bool Bool</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a> instance Eq A where</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="st">-  A x1 x2 /= A y1 y2 = x1 /= y1 || x2 /= x2</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="st">-</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="va">+  A x1 x2 == A y1 y2 = not $ x1 /= y1 || x2 /= x2</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a> data B = B Bool</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a> instance Eq B where</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>   B x == B y = x == y</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="st">-  B x /= B y = x /= y</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a> data C a = C a</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a> instance Eq a =&gt; Eq (C a) where</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>   C x == C y = x == y</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a><span class="st">-  C x /= C y = x /= y</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a><span class="st">-</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a> data D = D Bool</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a> instance Eq D where</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a><span class="st">-  D x /= D y = x /= y</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a>   D x == D y = x == y</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a> data E = E Bool</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a> instance Eq E where</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a><span class="st">-  E x /= E y =</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a><span class="st">-    let foo = x /= y in foo</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a><span class="va">+  E x == E y = not $ let foo = x /= y in foo</span></span></code></pre></div>
<p>Is it perfect? No, but it‚Äôs pretty good for the 10 minutes it took me to write. A little effort here goes a <em>long</em> way!</p>
<hr />
<p>My config file to automatically migrate <code>Eq</code> of no <code>(/=)</code>:</p>
<pre class="toml"><code>[only-neq]
match=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x] /= :[y] = :[z\n]
&#39;&#39;&#39;
rewrite=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x] == :[y] = not $ :[z]
&#39;&#39;&#39;


[both-eq-and-neq]
match=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x1] == :[y1] = :[z1\n]
  :[x2] /= :[y2] = :[z2\n]
&#39;&#39;&#39;
rewrite=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x1] == :[y1] = :[z1]
&#39;&#39;&#39;


[both-neq-and-eq]
match=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x2] /= :[y2] = :[z2\n]
  :[x1] == :[y1] = :[z1\n]
&#39;&#39;&#39;
rewrite=&#39;&#39;&#39;
instance :[ctx]Eq :[name] where
  :[x1] == :[y1] = :[z1]
&#39;&#39;&#39;


[import-prelude]
match=&#39;&#39;&#39;
import Prelude (:[pre]Eq (..):[post])
&#39;&#39;&#39;
rewrite=&#39;&#39;&#39;
import Prelude (:[pre]Eq, (==), (/=):[post])
&#39;&#39;&#39;


[import-data-eq]
match=&#39;&#39;&#39;
import Data.Eq (:[pre]Eq (..):[post])
&#39;&#39;&#39;
rewrite=&#39;&#39;&#39;
import Data.Eq (:[pre]Eq, (==), (/=):[post])
&#39;&#39;&#39;</code></pre>
<p>Save this file as <code>eq.toml</code>, and run <code>comby</code> in your project root via:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>$ <span class="ex">comby</span> -config eq.toml -matcher .hs -i -f .hs</span></code></pre></div>
<p>Comby will find and make all the changes you need, in place. Check the diff, and make whatever changes you might need. In particular, it might bork some of your whitespace ‚Äî there‚Äôs an issue to get comby to play more nicely with layout-aware languages. A more specialized tool that had better awareness of Haskell‚Äôs idiosyncrasies would help here, if you have some spare engineering cycles. But when all‚Äôs said and done, comby does a damn fine job.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Dragging Haskell Kicking and Screaming into the Century of the Fruitbat</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/century-of-the-fruitbat/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/century-of-the-fruitbat/index.html</guid>
      <pubDate>2021-11-12T12:15:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Yesterday, the new Haskell CLC <a href="https://github.com/haskell/core-libraries-committee/issues/3">decided</a> to remove <code>(/=)</code> from the <code>Eq</code> typeclass. As expected, the community has <a href="https://twitter.com/Augustsson/status/1458963074556256257">embraced</a> this change <a href="https://twitter.com/snoyberg/status/1459118062674890752">with</a> <a href="https://twitter.com/haskellhutt/status/1459147447863816200?s=20">characteristic</a> <a href="https://twitter.com/ChShersh/status/1458935578137931780">grace</a>. The usual state of affairs is that people who like the changes are silent, while people who don‚Äôt are exceptionally vocal. The result: people working hard to improve things only ever get yelled at, and nobody says ‚Äúhey, you‚Äôre doing a great job. Thank you!‚Äù</p>
<p>To the new Haskell CLC, with my deepest sincerity:</p>
<p><strong>You‚Äôre doing a great job! Thank you.</strong></p>
<p>Today I‚Äôd like to talk a little about the problems I see in the Haskell ecosystem. These are by no means insurmountable problems. They‚Äôre not even technical problems. They‚Äôre <em>social</em> problems, which suck, because those are the sort that are hard to solve.</p>
<p>The <code>(/=)</code> proposal has caused a surprising amount of uproar about such a stupid change. But why? Nobody <em>actually</em> cares technically about whether we can define not-equals instead of equals. I mean, I don‚Äôt care. You don‚Äôt care. I‚Äôm willing to bet dollars to donuts that nobody reading this essay <em>has actually ever defined <code>(/=)</code> in an instance.</em></p>
<p>No, the outcry is because <code>(/=)</code> is a proxy for the real issue. As best I can tell, there are three camps, and everyone is talking past one another. This is my attempt to organize the camps, steel-man them (well, two out of three), and respond with my commentary.</p>
<p><em>Personally,</em> I support the removal of <code>(/=)</code> because it‚Äôs a tiny, inconspicuous change that nobody is going to notice. It‚Äôs a bright beacon in the darkness of the ecosystem saying ‚Äúhey, the situation sucks, <em>but we‚Äôre willing to improve the situation.</em>‚Äù Haskell has tons of problems like this, none of which are controversial ‚Äî things like how <code>head</code> is antithetical to everything we like about Haskell, and yet it‚Äôs included <em>by default</em> in every fucking module of all time. Yes, there are valid arguments as to why it shouldn‚Äôt be removed, but nobody would argue to put it in if we were designing <code>Prelude</code> today.</p>
<p>In my eyes, removing <code>(/=)</code> from <code>Eq</code> shows that we as a community are willing to pay the cost to move out of a bad Nash equilibrium. Because as far as I see it, there are only two options:</p>
<ol type="1">
<li>break backwards compatibility and pay the migration costs</li>
<li>don‚Äôt break backwards compatibility, and pay the costs of having a shitty standard library forever</li>
</ol>
<p>Asymptotically, option 1 is better than option 2. There is a constant amount of code today that we will need to fix, compared to a linear (or worse!) amount of work in the future to work around having a shitty standard library. And yes, that cost probably is forever, because if we have too much code to break today, we‚Äôre going to have even more code that will break tomorrow.</p>
<p>I want us to be able to remove <code>(/=)</code>, because it gives me hope that one day we will be able to add <code>Foldable1</code>, and get <code>join</code> and <code>liftA2</code> into <code>Prelude</code>, and the other hundreds of tiny improvements that would <em>all of our lives better.</em> Not profoundly, but each one saves us a few seconds, multiplied by the number of practitioners, integrated over all of our careers.</p>
<p>And yes, those things will come at a cost, but it‚Äôs a cost that is getting bigger the longer we don‚Äôt pay it.</p>
<p>In the particular example of <code>(/=)</code>, there isn‚Äôt even any cost. There are ~50 packages that define <code>(/=)</code>, and the solution is just to delete those definitions. Yes, it‚Äôs churn, but <em>I personally</em> am willing to send a patch to each package. If you‚Äôre the maintainer of such a package, email me and I‚Äôll just go fix it for you.</p>
<p>This is not a big issue.</p>
<p><em>The second camp</em> as best I can tell, are educators who aren‚Äôt particularly up to date on what Haskell <em>is</em> in 2021. These are the people saying ‚Äúthis will break our tutorials‚Äù (and, I suspect, are also the ones who say ‚Äúwe need <code>head</code> in <code>Prelude</code> because it‚Äôs good for beginners‚Äù.) While this group clearly has good intentions, I don‚Äôt think they <em>get it.</em> Educational materials for everything go obsolete, made much worse by the <a href="https://en.wikipedia.org/wiki/Half-life_of_knowledge">half-life of knowledge</a>. If this is truly a thing you care about, <em>just update your tutorials.</em> There is no shortage of people in the community writing explanatory material, and I guarantee they will rush in to fill any void.</p>
<p>Of much more importance is <em>third camp.</em> They also seems to not care about <code>(/=)</code> <em>in particular.</em> But they are concerned about ‚Äúbackwards compatibility at all costs.‚Äù And to them, it seems, <code>(/=)</code> is a slippery slope. If we can‚Äôt maintain backwards compatibility for something as stupid as <code>(/=)</code>, we‚Äôve got no chance of having long-term maintainability. It‚Äôs a perfectly good argument.</p>
<p>To quote <a href="https://github.com/haskell/core-libraries-committee/issues/12#issuecomment-967204354">Dmitrii</a>:</p>
<blockquote>
<p>The size of breakage doesn‚Äôt matter. Breakage is breakage.</p>
</blockquote>
<p>My personal rebuttal against this attitude is that it gets us stuck in extremely suboptimal equilibria. If we can never break anything, then every mistake must exist <em>for perpetuity.</em> By virtue of being human, we‚Äôre unfortunately fallible, and thus are going to make mistakes.</p>
<p>However, I can definitely sympathize here. If every week you are called on to fix a tiny, breaking change, sooner than later you‚Äôre going to quit. We should not encourage any behavior that leads to burnout in our best players. That‚Äôs a bad long term plan.</p>
<p>But in my experience, it‚Äôs not breaking changes that are the problem. It‚Äôs <em>lots</em> of breaking changes that are the problem. Breaking changes are annoying, sure, but what‚Äôs worse is the <em>context shifting</em> necessary to fix a breaking change. Doing the work is <span class="math inline">\(O(n)\)</span> with respect to the breakages, but there is an extremely high constant factor. With this in mind, one big breakage is significantly better than lots of tiny breakages.</p>
<p>Since we‚Äôre just about to break things, might I again suggest we add <code>Foldable1</code>, and clean up <code>Prelude</code>? If breakage is breakage (it is), we might as well take advantage of it and do as much cleanup as possible. This is an excellent opportunity. The status-quo is for all of us to argue about it every week, with half the people saying ‚Äúthese are bad circumstances and we should fix them,‚Äù with the other half saying ‚Äúyes, they are bad circumstances, but breakage is worse.‚Äù</p>
<p>But given that <em>we now have breakage,</em> let‚Äôs make the most of it.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Proving Commutativity of Polysemy Interpreters</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/proving-commutativity/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/proving-commutativity/index.html</guid>
      <pubDate>2021-10-21T00:53:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>To conclude this <a href="/tags/polysemy.html">series of posts</a> on <a href="https://github.com/polysemy-research/polysemy-check">polysemy-check</a>, today we‚Äôre going to talk about how to ensure your effects are sane. That is, we want to prove that correct interpreters compose into correct programs. If you‚Äôve followed along with the series, you won‚Äôt be surprised to note that <code>polysemy-check</code> can test this right out of the box.</p>
<p>But first, what does it mean to talk about the correctness of composed interpreters? This idea comes from Yang and Wu‚Äôs <a href="https://dl.acm.org/doi/10.1145/3473578">Reasoning about effect interaction by fusion</a>. The idea is that for a given program, changing the order of two subsequent actions from different effects should not change the program. Too abstract? Well, suppose I have two effects:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">foo ::</span> <span class="dt">Member</span> <span class="dt">Foo</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">bar ::</span> <span class="dt">Member</span> <span class="dt">Bar</span> r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span></code></pre></div>
<p>Then, the composition of interpreters for <code>Foo</code> and <code>Bar</code> is correct if and only if<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> the following two programs are equivalent:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">forall</span> m1 m2<span class="op">.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  m1 <span class="op">&gt;&gt;</span> foo <span class="op">&gt;&gt;</span> bar <span class="op">&gt;&gt;</span> m2</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">=</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  m1 <span class="op">&gt;&gt;</span> bar <span class="op">&gt;&gt;</span> foo <span class="op">&gt;&gt;</span> m2</span></code></pre></div>
<p>That is, since <code>foo</code> and <code>bar</code> are actions from different effects, they should have <em>no influence on one another.</em> This sounds like an obvious property; effects correspond to individual units of functionality, and so they should be completely independent of one another. At least ‚Äî that‚Äôs how we humans think about things. Nothing actually forces this to be the case, and extremely hard-to-find bugs will occur if this property doesn‚Äôt hold, because it breaks a mental abstraction barrier.</p>
<p>It‚Äôs hard to come up with good examples of this property being broken in the wild, so instead we can simulate it with a different broken abstraction. Let‚Äôs imagine we‚Äôre porting a legacy codebase to <code>polysemy</code>, and the old code hauled around a giant stateful god object:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">TheWorld</span> <span class="ot">=</span> <span class="dt">TheWorld</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> counter ::</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  ,<span class="ot"> lots    ::</span> <span class="dt">Int</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  ,<span class="ot"> more&#39;   ::</span> <span class="dt">Bool</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  ,<span class="ot"> stuff   ::</span> [<span class="dt">String</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  }</span></code></pre></div>
<p>To quickly <a href="/blog/porting-to-polysemy/">get everything ported</a>, we replaced the original <code>StateT TheWorld IO</code> application monad with a <code>Member (State TheWorld) r</code> constraint. But we know better than to do that for the long haul, and instead are starting to carve out effects. We introduce <code>Counter</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Counter</span> m a <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="dt">Increment</span><span class="ot"> ::</span> <span class="dt">Counter</span> m ()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">GetCount</span><span class="ot"> ::</span> <span class="dt">Counter</span> m <span class="dt">Int</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;Counter</span></span></code></pre></div>
<p>with an interpretation into our god object:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>runCounterBuggy</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">TheWorld</span>) r</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Counter</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>runCounterBuggy <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="dt">Increment</span> <span class="ot">-&gt;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    modify <span class="op">$</span> \world <span class="ot">-&gt;</span> world</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>                         { counter <span class="ot">=</span> counter world <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>                         }</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>  <span class="dt">GetCount</span> <span class="ot">-&gt;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    gets counter</span></code></pre></div>
<p>On its own, this interpretation is fine. The problem occurs when we use <code>runCounterBuggy</code> to handle <code>Counter</code> effects that coexist in application code that uses the <code>State TheWorld</code> effect. Indeed, <code>polysemy-check</code> tells us what goes wrong:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>quickCheck <span class="op">$</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  prepropCommutative <span class="op">@</span>&#39;[<span class="dt">State</span> <span class="dt">TheWorld</span>] <span class="op">@</span>&#39;[<span class="dt">Counter</span>] <span class="op">$</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="fu">pure</span> <span class="op">.</span> runState defaultTheWorld <span class="op">.</span> runCounterBuggy</span></code></pre></div>
<p>we see:</p>
<pre><code>Failed.

Effects are not commutative!

k1  = Get
e1 = Put (TheWorld 0 0 False [])
e2 = Increment
k2  = Pure ()

(k1 &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; k2) /= (k1 &gt;&gt; e2 &gt;&gt; e1 &gt;&gt; k2)
(TheWorld 1 0 False [],()) /= (TheWorld 0 0 False [],())</code></pre>
<p>Of course, these effects are not commutative under the given interpreter, because changing <code>State TheWorld</code> will overwrite the <code>Counter</code> state! That‚Äôs not to say that this sequence of actions <em>actually exists</em> anywhere in your codebase, but it‚Äôs a trap waiting to happen. Better to take defensive action and make sure nobody can ever even <em>accidentally</em> trip this bug!</p>
<p>The bug is fixed by using a different data store for <code>Counter</code> than <code>TheWorld</code>. Maybe like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>runCounter</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Sem</span> (<span class="dt">Counter</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>runCounter <span class="ot">=</span> (evalState <span class="dv">0</span>) <span class="op">.</span> reinterpret <span class="op">@</span>_ <span class="op">@</span>(<span class="dt">State</span> <span class="dt">Int</span>) <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  <span class="dt">Increment</span> <span class="ot">-&gt;</span> modify (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="dt">GetCount</span> <span class="ot">-&gt;</span> get</span></code></pre></div>
<p>Contrary to the old handler, <code>runCounter</code> now introduces its own anonymous <code>State Int</code> effect (via <code>reinterpret</code>), and then immediately eliminates it. This ensures the state is invisible to all other effects, with absolutely no opportunity to modify it. In general, this <code>evalState . reintrpret</code> pattern is a very good one for implementing pure effects.</p>
<p>Of course, a really complete solution here would also remove the <code>counter</code> field from <code>TheWorld</code>.</p>
<p>Behind the scenes, <code>prepropCommutative</code> is doing exactly what you‚Äôd expect ‚Äî synthesizing monadic preludes and postludes, and then randomly pulling effects from each set of rows and ensuring everything commutes.</p>
<p>At first blush, using <code>prepropCommutative</code> to test all of your effects feels like an <span class="math inline">\(O(n^2)\)</span> sort of deal. But take heart, it really isn‚Äôt! Let‚Äôs say our application code requires <code>Members (e1 : e2 : e3 : es) r</code>, and our eventual composed interpreter is <code>runEverything :: Sem ([e] ++ es ++ [e3, e2, e1] ++ impl) a -&gt; IO (f a)</code>. Here, we only need <span class="math inline">\(O(es)\)</span> calls to <code>prepropCommutative</code>:</p>
<ul>
<li><code>prepropCommutative @'[e2] @'[e1] runEverything</code></li>
<li><code>prepropCommutative @'[e3] @'[e2, e1] runEverything</code></li>
<li>‚Ä¶</li>
<li><code>prepropCommutative @'[e] @'(es ++ [e2, e1]) runEverything</code></li>
</ul>
<p>The trick here is that we can think of the composition of interpreters as an interpreter of composed effects. Once you‚Äôve proven an effect commutes with a particular row, you can then add that effect into the row and prove a different effect commutes with the whole thing. Induction is pretty cool!</p>
<p>As of today there is no machinery in <code>polysemy-check</code> to automatically generate this linear number of checks, but it seems like a good thing to include in the library, and you can expect it in the next release.</p>
<p>To sum up these last few posts, <code>polysemy-check</code> is an extremely useful and versatile tool for proving correctness about your <code>polysemy</code> programs. It can be used to show the semantics of your effects (and adherence of such for their interpreters.) It can show the equivalence of interpreters ‚Äî such as the ones you use for testing, and those you use in production. And now we‚Äôve seen how to use it to ensure that the composition of our interpreters maintains its correctness.</p>
<p>Happy testing!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Well, there is a second condition regarding distributivity that is required for correctness. The paper goes into it, but <code>polysemy-check</code> doesn‚Äôt yet implement it.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
  <item>
      <title>Proving Equivalence of Polysemy Interpreters</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/proving-equivalence/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/proving-equivalence/index.html</guid>
      <pubDate>2021-10-16T12:06:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Let‚Äôs talk <a href="https://reasonablypolymorphic.com/blog/polysemy-check/">more</a> about <a href="https://github.com/polysemy-research/polysemy-check"><code>polysemy-check</code></a>. Last week we looked at how to do property-testing for a <code>polysemy</code> effects‚Äô laws. Today, we‚Äôll investigate how to show that two interpretations are equivalent.</p>
<p>To continue with last week‚Äôs example, let‚Äôs say we have an effect that corresponds to having a <code>Stack</code> that we can push and pop:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stack</span> s m a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="dt">Push</span><span class="ot">      ::</span> s <span class="ot">-&gt;</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="dt">Pop</span><span class="ot">       ::</span> <span class="dt">Stack</span> s m (<span class="dt">Maybe</span> s)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="dt">RemoveAll</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="dt">Size</span><span class="ot">      ::</span> <span class="dt">Stack</span> s m <span class="dt">Int</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> s <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Stack</span> s m a)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>deriveGenericK &#39;<span class="dt">&#39;Stack</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>Since we‚Äôd like to prove the equivalence of two interpretations, we‚Äôll need to first write two interpretations. But, to illustrate, we‚Äôre going simulate multiple interpreters via a single interpretation, parameterized by which bugs should be present in it.</p>
<p>purposes of brevity, we‚Äôll write a single interpretation of <code>Stack s</code> in terms of <code>State [s]</code>, and then interpret <em>that</em> in two different ways. In essence, what we‚Äôre really testing here is the equivalence of two <code>State</code> interpretations, but it‚Äôs good enough for an example.</p>
<p>We‚Äôll start with the bugs:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Bug</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">PushTwice</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">DontRemove</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bug</span> <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  arbitrary <span class="ot">=</span> elements [<span class="fu">minBound</span><span class="op">..</span><span class="fu">maxBound</span>]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="ot">hasBug ::</span> [<span class="dt">Bug</span>] <span class="ot">-&gt;</span> <span class="dt">Bug</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>hasBug <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">elem</span></span></code></pre></div>
<p>The <code>PushTwice</code> bug, as you might expect, dispatched a <code>Push</code> command so that it pushes twice onto the stack. The <code>DontRemove</code> bug causes <code>RemoveAll</code> to be a no-op. Armed with our bugs, we can write a little interpreter for <code>Stack</code> that translates <code>Stack s</code> commands into <code>State [s]</code> commands, and then immediately runs the <code>State</code> effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>runStack</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ot">    ::</span> [<span class="dt">Bug</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Stack</span> s &#39;<span class="op">:</span> r) a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ([s], a)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>runStack bugs <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  (runState [] <span class="op">.</span>) <span class="op">$</span> reinterpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="dt">Push</span> s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>      modify (s <span class="op">:</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>      when (hasBug bugs <span class="dt">PushTwice</span>) <span class="op">$</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        modify (s <span class="op">:</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    <span class="dt">Pop</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>      r <span class="ot">&lt;-</span> gets listToMaybe</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>      modify (<span class="fu">drop</span> <span class="dv">1</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>      <span class="fu">pure</span> r</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    <span class="dt">RemoveAll</span> <span class="ot">-&gt;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>      unless (hasBug bugs <span class="dt">DontRemove</span>) <span class="op">$</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        put []</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    <span class="dt">Size</span> <span class="ot">-&gt;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>      gets <span class="fu">length</span></span></code></pre></div>
<p>For our efforts we are rewarded: <code>runState</code> gives rise to four interpreters for the price of one. We can now ask whether or not these interpreters are equivalent. Enter <code>propEquivalent</code>:</p>
<p>With these interpreters out of the way, it‚Äôs time to answer our original question: are <code>pureStack</code> and <code>ioStack</code> equivalent? Which is to say, do they get the same answer for every possible program? Enter <code>propEquivalent</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>prepropEquivalent</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> effs r1 r2 f</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>     <span class="op">.</span> ( <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (f a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>       , <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f a)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>       )</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> ( <span class="dt">Inject</span> effs r1</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>       , <span class="dt">Inject</span> effs r2</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>       , <span class="dt">Arbitrary</span> (<span class="dt">Sem</span> effs <span class="dt">Int</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>       )</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r1 a <span class="ot">-&gt;</span> <span class="dt">IO</span> (f a))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r2 a <span class="ot">-&gt;</span> <span class="dt">IO</span> (f a))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span></code></pre></div>
<p>All of the functions in <code>polysemy-check</code> have fun type signatures like this one. But despite the preponderance of <code>forall</code>s, it‚Äôs not as terrible as you might think. The first ten lines here are just constraints. There are only two arguments to <code>prepropEquivalent</code>, and they are the two interpreters you‚Äôd like to test.</p>
<p>This type is crazy, and it will be beneficial to understand it. There are four type variables, three of which are effect rows. We can distinguish between them:</p>
<ul>
<li><code>effs</code>: The effect(s) you‚Äôre interested in testing. In our case, our interpreter handles <code>Stack s</code>, so we let <code>effs ~ Stack s</code>.</li>
<li><code>r1</code>: The effects handled by interpreter 1. Imagine we had an interpreter for <code>Stack s</code> that ran it via <code>IO</code> instead. In that case, <code>r1 ~ '[State s, Embed   IO]</code>.</li>
<li><code>r2</code> The effects handled by interpreter 2.</li>
</ul>
<p>The relationships that must between <code>effs</code>, <code>r1</code> and <code>r2</code> are <span class="math inline">\(effs \subset r1\)</span> and <span class="math inline">\(effs \subset r2\)</span>. When running <code>prepropEquivalent</code>, you <em>must</em> type-apply <code>effs</code>, because Haskell isn‚Äôt smart enough to figure it out for itself.</p>
<p>The other type variable to <code>prepropEquivalent</code> is <code>f</code>, which allows us to capture the ‚Äúresulting state‚Äù of an interpreter. In <code>runStack :: [Bug] -&gt; Sem (Stack s ': r) a -&gt; Sem r ([s], a)</code>, you‚Äôll notice we transform a program returning <code>a</code> into one returning <code>([s], a)</code>, and thus <code>f ~ (,) [s]</code>. If your interpreter doesn‚Äôt produce any resulting state, feel free to let <code>f ~ Identity</code>.</p>
<p>We‚Äôre finally ready to test our interpreters! For any equivalence relationship, we should expect something to be equivalent to itself. And this is true regardless of which bugs we enable:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">prop_reflexive ::</span> <span class="dt">Property</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>prop_reflexive <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  bugs <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="fu">pure</span> <span class="op">$</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    prepropEquivalent <span class="op">@</span>&#39;[<span class="dt">Stack</span> <span class="dt">Int</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack bugs)  <span class="co">-- pure is getting us into IO</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack bugs)</span></code></pre></div>
<p>So what‚Äôs happening here? Internally, <code>prepropEquivalent</code> is generating random programs of type <code>Sem '[Stack Int] Int</code>, and lifting that into <code>Sem r1 Int</code> and <code>Sem r2 Int</code>, and then running both interpreters and ensuring the result is the same for every program. Note that this means any fundamental non-determinism in your interpretation will break the test! Make sure to use appropriate interpreters for things like clocks and random values!</p>
<p>To strengthen our belief in <code>prepropEquivalent</code>, we can also check that <code>runStack</code> is <em>not</em> equivalent to itself if different bugs are enabled:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">prop_bugsNotEquivalent ::</span> <span class="dt">Property</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>prop_bugsNotEquivalent <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  expectFailure <span class="op">$</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    prepropEquivalent <span class="op">@</span>&#39;[<span class="dt">Stack</span> <span class="dt">Int</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack [<span class="dt">PushTwice</span>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack [])</span></code></pre></div>
<p>Running this test will give us output like:</p>
<pre><code>+++ OK, failed as expected. Falsified (after 3 tests):
([0,0],1) /= ([0],1)</code></pre>
<p>The counterexample here isn‚Äôt particularly helpful (I haven‚Äôt yet figured out how to <code>show</code> the generated program that fails,) but you can get a hint here by noticing that the stack (the <code>[0,0]</code>) is twice as big in the first result as in the second.</p>
<p>Importantly, by specifying <code>@'[Stack Int]</code> when calling <code>prepropEquivalent</code>, we are guaranteed that the generated program will <em>only</em> use actions from <code>Stack Int</code>, so it‚Äôs not too hard to track down. This is another win for <code>polysemy</code> in my book ‚Äî that we can isolate bugs with this level of granularity, even if we can‚Äôt yet perfectly point to them.</p>
<p>All of today‚Äôs code (and more!) is <a href="https://github.com/polysemy-research/polysemy-check/blob/master/test/ExampleSpec.hs">available</a> as a test in <code>polysemy-check</code>, if you‚Äôd like to play around with it. But that‚Äôs all for now. Next week we‚Äôll investigate how to use <code>polysemy-check</code> to ensure that the composition of your effects <em>themselves</em> is meaningful. Until then!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Testing Polysemy With polysemy-check</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/polysemy-check/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/polysemy-check/index.html</guid>
      <pubDate>2021-10-09T14:23:00Z</pubDate>
      <content:encoded><![CDATA[
        <p><a href="/blog/porting-to-polysemy/">Last week</a> we covered how to port an existing codebase to <a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a>. The ‚Äúwhy you might want to do this‚Äù was left implicit, but to be more explicit about things, it‚Äôs because littering your codebase with <code>IO</code> makes things highly-coupled and hard to test. By forcing yourself to think about effects, you are forced to pull concerns apart, and use the type-system to document what‚Äôs going on. But more importantly for today, it gives us a layer of indirection inside of which we can insert testing machinery.</p>
<p>To take an extreme example from the codebase I‚Äôm currently working on, compare a function with its original (non-polysemized) type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">api ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">API</span> <span class="dt">App</span></span></code></pre></div>
<p>which looks very simple, and gives the false impression that <code>api</code> is fairly uninteresting. However, there is an amazing amount of <code>IO</code> hiding inside of <code>App</code>, which becomes <em>significantly more evident</em> when we give this type explicit dependency constraints:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">api ::</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">Members</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    &#39;[ <span class="dt">AReqIDStore</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>       <span class="dt">AssIDStore</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>       <span class="dt">BindCookieStore</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>       <span class="dt">BrigAccess</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>       <span class="dt">DefaultSsoCode</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>       <span class="dt">Error</span> <span class="dt">SparError</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>       <span class="dt">GalleyAccess</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>       <span class="dt">IdP</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>       <span class="dt">Input</span> <span class="dt">Opts</span>,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>       <span class="dt">Logger</span> (<span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>       <span class="dt">Logger</span> <span class="dt">String</span>,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>       <span class="dt">Now</span>,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>       <span class="dt">Random</span>,</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>       <span class="dt">Reporter</span>,</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>       <span class="dt">SAML2</span>,</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>       <span class="dt">SAMLUserStore</span>,</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>       <span class="dt">SamlProtocolSettings</span>,</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>       <span class="dt">ScimExternalIdStore</span>,</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>       <span class="dt">ScimTokenStore</span>,</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>       <span class="dt">ScimUserTimesStore</span>,</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>     ]</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>    r <span class="ot">=&gt;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>  <span class="dt">Opts</span> <span class="ot">-&gt;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>  <span class="dt">ServerT</span> <span class="dt">API</span> (<span class="dt">Sem</span> r)</span></code></pre></div>
<p>Wow! Not so innocent-looking now, is it? Each <code>Member</code> constraint here is a unit of functionality that was previously smuggled in via <code>IO</code>. Not only have we made them more visible, but we‚Äôve now exposed a big chunk of testable surface-area. You see, each one of these members provides an abstract interface, which we can implement in any way we‚Äôd like.</p>
<p>Because <code>IO</code> is so hard to test, the idea of <code>polysemy</code> is that we can give several interpretaions for our program ‚Äî one that is pure, lovely, functional, and, importantly, very easy to test. Another interpretation is one that that runs fast in <code>IO</code>. The trick then is to decompose the problem of testing into two steps:</p>
<ol type="1">
<li>show that the program is correct under the model interpreter</li>
<li>show that the model interpreter is equivalent to the real interpreter</li>
</ol>
<p>This sounds great in principle, but as far as I know, it‚Äôs never been actually done in practice. My suspicion is that people using <code>polysemy</code> in the wild don‚Äôt get further than step 1 (which is OK ‚Äî a good chunk of the value in effect systems is in the decomposition itself.) Doing all of the work to show equivalence of your interpreters is a significant amount of work, and until now, there have been no tools to help.</p>
<p><strong>Introducing <a href="https://hackage.haskell.org/package/polysemy-check"><code>polysemy-check</code></a>:</strong> a new library for proving all the things you‚Äôd want to prove about a <code>polysemy</code> codebase. <code>polysemy-check</code> comes with a few tools for synthesizing <a href="https://hackage.haskell.org/package/QuickCheck"><code>QuickCheck</code></a> properties, plus machinery for getting <code>Arbitrary</code> instances for effects for free.</p>
<h2 id="using-polysemy-check">Using polysemy-check</h2>
<p>To get started, you‚Äôre going to need to give two instances for every effect in your system-under-test. Let‚Äôs assume we have a stack effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stack</span> s m a <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="dt">Push</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">Pop</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m (<span class="dt">Maybe</span> s)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  <span class="dt">RemoveAll</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span class="dt">Size</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m <span class="dt">Int</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>The instances we need are given by:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Show</span> s, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Stack</span> s m a)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>deriveGenericK &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>where <code>deriveGenericK</code> is TemplateHaskell that from <a href="https://hackage.haskell.org/package/kind-generics"><code>kind-generics</code></a> (but is re-exported by <code>polysemy-check</code>.) <code>kind-generics</code> is <code>GHC.Generics</code> on steroids: it‚Äôs capable of deriving generic code for GADTs.</p>
<p>The first thing that probably comes to mind when you consider <code>QuickCheck</code> is ‚Äúchecking for laws.‚Äù For example, we should expect that <code>push s</code> followed by <code>pop</code> should be equal to <code>pure (Just s)</code>. Laws of this sort <em>give meaning to effects,</em> and act as <em>sanity checks on their interpreters.</em></p>
<p>Properties for laws can be created via <code>prepropLaw</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>prepropLaw</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> effs r a f</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>     <span class="op">.</span> ( (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Eq</span> z <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f z))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Show</span> z <span class="ot">=&gt;</span> <span class="dt">Show</span> (f z))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>       )</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> ( <span class="dt">Eq</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>       , <span class="dt">Show</span> a</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>       , <span class="dt">ArbitraryEff</span> effs r</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>       )</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Gen</span> (<span class="dt">Sem</span> r a, <span class="dt">Sem</span> r a)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Sem</span> r (a, z) <span class="ot">-&gt;</span> <span class="dt">IO</span> (f (a, z)))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span></code></pre></div>
<p>Sorry for the atrocious type. If you‚Äôre looking for Boring Haskell, you‚Äôd best look elsewhere.</p>
<p>The first argument here is a <code>QuickCheck</code> generator which produces two programs that should be equivalent. The second argument is the interpreter for <code>Sem</code> under which the programs must be equivalent, or will fail the resulting <code>Property</code>. Thus, we can write the <code>push/pop</code> law above as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>law_pushPop</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> s r f effs res</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>     <span class="op">.</span> (</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>         <span class="co">-- The type that our generator returns</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>         res <span class="op">~</span> (<span class="dt">Maybe</span> s)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>         <span class="co">-- The effects we want to be able to synthesize for contextualized</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>         <span class="co">-- testing</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>       , effs <span class="op">~</span> &#39;[<span class="dt">Stack</span> s]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>         <span class="co">-- Misc constraints you don&#39;t need to care about</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>       , <span class="dt">Arbitrary</span> s</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>       , <span class="dt">Eq</span> s</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>       , <span class="dt">Show</span> s</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>       , <span class="dt">ArbitraryEff</span> effs r</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>       , <span class="dt">Members</span> effs r</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Eq</span> z <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f z))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Show</span> z <span class="ot">=&gt;</span> <span class="dt">Show</span> (f z))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>       )</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r (res, a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (f (res, a)))</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>law_pushPop <span class="ot">=</span> prepropLaw <span class="op">@</span>effs <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  s <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>  <span class="fu">pure</span> ( push s <span class="op">&gt;&gt;</span> pop</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>       , <span class="fu">pure</span> (<span class="dt">Just</span> s)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>       )</span></code></pre></div>
<p>Sorry. Writing gnarly constraints is the cost not needing to write gnarly code. If you know how to make this better, please open a PR!</p>
<p>There‚Äôs something worth paying attention to in <code>law_pushPop</code> ‚Äî namely the type of the interpreter <code>(forall a. Sem r (Maybe s, a) -&gt; IO (f (Maybe s, a)))</code>. What is this <code>forall a</code> thing doing, and where does it come from? As written, our generator would merely checks the equivalence of the exact two given programs, but this is an insufficient test. We‚Äôd instead like to prove the equivalence of the <code>push/pop</code> law <em>under all circumstances.</em></p>
<p>Behind the scenes, <code>prepropLaw</code> is synthesizing a monadic action to run <em>before</em> our given law, as well as some actions to run <em>after</em> it. These actions are randomly pulled from the effects inside the <code>effs ~ '[Stack s]</code> row (and so here, they will only be random <code>Stack</code> actions.) The <code>a</code> here is actually the result of these ‚Äúcontextual‚Äù actions. Complicated, but you really only need to get it right once, and can copy-paste it forevermore.</p>
<p>Now we can specialize <code>law_pushPop</code> (plus any other laws we might have written) for a would-be interpreter of <code>Stack s</code>. Any interpreter that passes all the properties is therefore proven to respect the desired semantics of <code>Stack s</code>.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p><code>polysemy-check</code> can do lots more, but this post is overwhelming already. So next week we‚Äôll discuss how to prove the equivalence of interpreters, and how to ensure your effects are sane with respect to one another.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Porting to Polysemy</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/porting-to-polysemy/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/porting-to-polysemy/index.html</guid>
      <pubDate>2021-10-02T22:46:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Many years ago, when I first started using free monads in anger, I was tasked with porting our giant codebase to something that used an effect system. While it was a noble goal, my efforts slowly imploded upon their own weight. I didn‚Äôt know how to go about doing such a dramatic refactoring on a live codebase, and unwisely tried to do the whole thing in a single PR. A month later, as you might expect, it became overwhelming obvious that we were never going to merge the thing, and it died there.</p>
<p>Several years older (and wiser), I‚Äôve recently been contracted to port another codebase to Polysemy. Today we hit our first big milestone, and the experience has gone swimmingly. I wanted to spend some time today discussing how to actually go about Polysemizing a codebase. It‚Äôs not too onerous if you proceed cautiously. The trick is to do several passes over the codebase, each time introducing a few more effects, but at no point ever actually changing any code paths.</p>
<h2 id="getting-your-foot-in-the-door">Getting Your Foot in the Door</h2>
<p>The first step is to introduce Polysemy into your codebase. Your program is almost certainly structured around a main application monad, and that‚Äôs the right place to start. As a first step, we will swap out <code>IO</code> for <code>Sem</code>. For example, if your main monad were:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">App</span> a <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  {<span class="ot"> unApp ::</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> (<span class="dt">ExceptT</span> <span class="dt">AppError</span> <span class="dt">IO</span>) a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  }</span></code></pre></div>
<p>we will change it to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">App</span> r a <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  {<span class="ot"> unApp ::</span> <span class="dt">Member</span> (<span class="dt">Final</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> (<span class="dt">ExceptT</span> <span class="dt">AppError</span> (<span class="dt">Sem</span> r)) a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  }</span></code></pre></div>
<p>This change exposes the effect row (the <code>r</code> type variable,) and asserts that we always have a <code>Final IO</code> member in that row. Exposing <code>r</code> means we can gradually introduce <code>Member</code> constraints in application code as we begin teasing apart effects, and <code>Final IO</code> gives us a way to implement <code>MonadIO</code> for <code>App</code>. Let‚Äôs start with that:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> (<span class="dt">App</span> r) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  liftIO a <span class="ot">=</span> <span class="dt">App</span> <span class="op">$</span> lift <span class="op">$</span> lift <span class="op">$</span> embedFinal a</span></code></pre></div>
<p>Due to some quirks of how Haskell deals with impredicativity, this function can‚Äôt be written point-free.</p>
<p>This change of <code>App</code> to <code>App r</code> isn‚Äôt the end-goal; it‚Äôs <em>just</em> enough that we can get Polysemy into the project without it being a huge change. In the medium term, our goal is to eliminate the <code>App</code> newtype altogether, leaving a bare <code>Sem</code> in its place. But one step at a time.</p>
<p>You‚Äôll need to rewrite any instances on <code>App</code> that you were previously newtype deriving. This sucks, but the answer is always just to <code>lift</code>. You might find that some instances used to be derived via <code>IO</code>, and thus now cannot be implemented via <code>lift</code>. In these cases, don‚Äôt be afraid to give an orphan instance for <code>Sem r</code>; orphans are bad, but we‚Äôll be cleaning this all up very soon.</p>
<p>Take some time to get everything compiling. It‚Äôs a lot of drudgery, but all you need to do is to add the <code>r</code> type variable to every type signature in your codebase that mentions <code>App</code>.</p>
<p>You will also need an introduction function, to lift Polysemy actions into <code>App</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">liftSem ::</span> <span class="dt">Sem</span> r a <span class="ot">-&gt;</span> <span class="dt">App</span> r a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>liftSem a <span class="ot">=</span> <span class="dt">App</span> <span class="op">$</span> lift <span class="op">$</span> lift a</span></code></pre></div>
<p>as well as an elimination function which will evolve as you add effects. At some point in your (existing) program, you will need to actually run <code>App</code> down to <code>IO</code>. It probably looks something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">runApp ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>runApp env <span class="ot">=</span> runExceptT <span class="op">.</span> <span class="fu">flip</span> runReaderT env <span class="op">.</span> unApp</span></code></pre></div>
<p>instead we are going to create the <em>canonical</em> interpretation down to <code>IO</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">CanonicalEffects</span> <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  &#39;[ <span class="dt">Final</span> <span class="dt">IO</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   ]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="ot">canonicalAppToIO ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> <span class="dt">CanonicalEffects</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>canonicalAppToIO env</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  <span class="ot">=</span> runFinal</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  <span class="op">.</span> runExceptT</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="op">.</span> <span class="fu">flip</span> runReaderT env</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span class="op">.</span> unApp</span></code></pre></div>
<p>As we pull effects out of the program, we will add them to <code>CanonicalEffects</code>, and their interpreters to <code>canonicalAppToIO</code>. But for now, this function is very boring.</p>
<p>Once everything is up and compiling, all of the old tests should still pass. We haven‚Äôt changed anything, just installed some new machinery. But importantly, all of code paths are still exactly the same. Remember, this is a refactoring task! The goal is to do lots of little refactors, each one pulling out some effect machinery, but not changing any code paths. The entire porting project should be a series of no-op PRs that slowly carve your codebase into one with explicitly described effects.</p>
<h2 id="first-effects">First Effects</h2>
<p>Your medium term goal is to eliminate the <code>Final IO</code> constraint inside of <code>App</code>, which exists only to provide a <code>MonadIO</code> instance. So, our <em>real</em> goal is to systematically eliminate raw <code>IO</code> from <code>App</code>.</p>
<p>The usual culprits here are database access, HTTP requests, and logging. If your team has been disciplined, database access and HTTP requests should already be relatively isolated from the rest of the codebase. Isolated here means ‚Äúdatabase calls are in their own functions,‚Äù rather than being inlined directly in the application code whenever it wants to talk to the database. If your database accesses are not isolated, take some time to uninline them before continuing.</p>
<p>Our next step is to identify CRUD groups on the database. We generously interpret the ‚Äúread‚Äù in CRUD to be any queries that exist against the logical datastructure that you‚Äôre serializing in the database. These CRUD groups might be organized by table, but they don‚Äôt necessarily need to be; by table is good enough for now if it corresponds to how the queries exist today.</p>
<p>For each CRUD group, we want to make a new Polysemy effect, and thread it through the application, replacing each direct call to the database with a call to the effect action. Finish working on each effect before starting on the next; each group makes for a good PR.</p>
<p>For example, maybe we‚Äôve identified the following database accesses for table <code>users</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">insertUser       ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">lookupUser       ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> <span class="dt">User</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ot">getUsersByRegion ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">Region</span> <span class="ot">-&gt;</span> m [<span class="dt">User</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="ot">setUserLapsed    ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="ot">unsetUserLapsed  ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="ot">purgeUser        ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserNamr</span> <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>This CRUD group corresponds to an effect:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">App.Sem.UserStore</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">UserStore</span> m a <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="dt">Insert</span><span class="ot">      ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  <span class="dt">Lookup</span><span class="ot">      ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m (<span class="dt">Maybe</span> <span class="dt">User</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="dt">GetByRegion</span><span class="ot"> ::</span> <span class="dt">Region</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m [<span class="dt">User</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  <span class="dt">SetLapsed</span><span class="ot">   ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  <span class="dt">UnsetLapsed</span><span class="ot"> ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  <span class="dt">Purge</span><span class="ot">       ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;UserStore</span></span></code></pre></div>
<p>We can now replace all calls across the codebase to <code>insertUser a b</code> with <code>liftSem $ UserStore.insert a b</code>. Doing so will require you to propagate a <code>Member UserStore r</code> constraint throughout the callstack. I really like this process. It‚Äôs a bit annoying to push constraints upwards, but it really gives you a good sense for the hidden complexity in your program. As it turns out, <code>MonadIO</code> is hiding a metric ton of spaghetti code!</p>
<p>All of this replacing and constraint propagating has given you dependency injection. But remember, at this step we‚Äôd like all of our changes to be no-ops, so we still need to inject the old codepath. For this we will make an interpreter of the <code>UserStore</code> effect:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">App.Sem.UserStore.IO</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">TheDatabase</span> <span class="kw">as</span> <span class="dt">DB</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">App.Sem.UserStore</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>userStoreToDB</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> m r a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>     <span class="op">.</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> m) r, <span class="dt">MonadDB</span> m)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">UserStore</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>userStoreToDB <span class="ot">=</span> interpret <span class="op">$</span> embed <span class="op">@</span>m <span class="op">.</span> \<span class="kw">case</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  <span class="dt">Insert</span> un u    <span class="ot">-&gt;</span> DB.insertUser un u</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  <span class="dt">Lookup</span> un      <span class="ot">-&gt;</span> DB.lookupUser un</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  <span class="dt">GetByRegion</span> r  <span class="ot">-&gt;</span> DB.getUsersByRegion r</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  <span class="dt">SetLapsed</span> un   <span class="ot">-&gt;</span> DB.setUserLapsed un</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  <span class="dt">UnsetLapsed</span> un <span class="ot">-&gt;</span> DB.unsetUserLapsed un</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  <span class="dt">Purge</span> un       <span class="ot">-&gt;</span> DB.purgeUser un</span></code></pre></div>
<p>Make sure to add <code>UserStore</code> (and its dependency, <code>Embed DB</code>) to the head of <code>CanonicalEffects</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">CanonicalEffects</span> <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  &#39;[ <span class="dt">UserStore</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>   , <span class="dt">Embed</span> <span class="dt">DB</span>  <span class="co">-- dependency of UserStore</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>   , <span class="dt">Embed</span> <span class="dt">IO</span>  <span class="co">-- dependency of Embed DB</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>   , <span class="dt">Final</span> <span class="dt">IO</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>   ]</span></code></pre></div>
<p>and then we can update the canonical interpreter:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">canonicalAppToIO ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> <span class="dt">CanonicalEffects</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>canonicalAppToIO env</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="ot">=</span> runFinal</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="op">.</span> embedToFinal</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="op">.</span> runEmbedded <span class="op">@</span><span class="dt">DB</span> <span class="op">@</span><span class="dt">IO</span> (however you run the <span class="dt">DB</span> <span class="kw">in</span> <span class="dt">IO</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  <span class="op">.</span> userStoreToDB <span class="op">@</span><span class="dt">DB</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  <span class="op">.</span> runExceptT</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  <span class="op">.</span> <span class="fu">flip</span> runReaderT env</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  <span class="op">.</span> unApp</span></code></pre></div>
<p>The general principle here is that you add the new effect somewhere near the top of the <code>CanonicalEffects</code> stack, making sure to add any effects that your intended interpreter requires lower in the stack. Then, add the new interpreter to <code>canonicalAppToIO</code>, in the same order (but perhaps presented ‚Äúbackwards‚Äù, since function application is right to left.) Make sure to add interpreters for the depended-upon effects too!</p>
<p>As you pull more and more effects out, you‚Äôll find that often you‚Äôll already have the depended-upon effects in <code>CanonicalEffects</code>. This is a good thing ‚Äî we will probably have several effects that can all be interpreted via <code>Embed DB</code>.</p>
<p>The benefit here is that we have now separated our <em>application code</em> from the particular choice of database implementation. While we want to use <code>userStoreToDB</code> in production, it might make less sense to use in local testing environments, where we don‚Äôt want to spin up a database. Instead, we could just write a little interpreter that emulates the <code>UserStore</code> interface purely in memory! Once you‚Äôve fully exorcised <code>IO</code> from your codebase, this approach gets extremely powerful.</p>
<h2 id="choosing-effects">Choosing Effects</h2>
<p>Carving out your effects is probably the hardest thing to do here. What‚Äôs difficult is that you need to forget your instincts! Things that would make a good MTL-style typeclass are often <em>terrible</em> choices for effects.</p>
<p>Why‚Äôs that? There‚Äôs this extremely common pattern in the Haskell ecosystem for libraries that want to expose themselves to arbitrary applications‚Äô monad stacks. To continue with the <code>MonadDB</code> example, it‚Äôs likely something like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadThrow</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadDB</span> m <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">  liftDB ::</span> <span class="dt">DB</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>While this works fine for a single underlying implementation, it‚Äôs an awful effect for the same reason: there‚Äôs only one interpretation! Any meaningful interpreter for <code>MonadDB</code> is equivalent to writing your own implementation of the database! It‚Äôs the same reason we don‚Äôt like <code>IO</code> ‚Äî <code>IO</code> is so big that every possible interpretation of it would necessarily need to be able to talk to the file system, to the network, to threads, and <em>everything else</em> that we can do in <code>IO</code>.</p>
<p>Instead, when you‚Äôre looking for effects to pull out, you need to <em>forget entirely about the implementation,</em> and just look at the abstract interface. Don‚Äôt use an HTTP effect to talk to a REST API ‚Äî it‚Äôs too big, and would require you to implement an entire HTTP protocol. Instead, just define an effect that talks to exactly the pieces of the API that you need to talk to. Forget that it‚Äôs REST entirely! That‚Äôs an implementation detail, and implementation details are the domain of the interpreter, not the effect.</p>
<p>Furthermore, if you‚Äôre just using the standard <code>Polysemy</code> effects, pick the smallest effect that you can get away with. You‚Äôll probably reach for <code>Reader</code> more often than you should. You don‚Äôt need to use <code>Reader</code> unless you need <code>local</code> ‚Äî otherwise, prefer <code>Input</code>.</p>
<h2 id="summing-up">Summing Up</h2>
<p>That‚Äôs all I have for today, but I have a few more posts in mind for this series. One on how to actually go about testing all of this stuff, and another on how to follow up the refactoring of your new Polysemy codebase now that all of the <code>IO</code> has been removed.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Exploring Case Law</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/exploring-case-law/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/exploring-case-law/index.html</guid>
      <pubDate>2021-02-08T00:14:00Z</pubDate>
      <content:encoded><![CDATA[
        <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="/js/charts.js"></script>
<p><link rel="stylesheet" href="/css/law.css"></p>
<h2 id="overview">Overview</h2>
<p>In early 2021, spurred on by many discussions with my incredible, law-student (among many other fantastic characteristics) girlfriend, I decided to try my hand at analyzing Canada‚Äôs legal system. Absolutely everything I know about the law I‚Äôve learned from TV shows and a year‚Äôs worth of hanging out with law students ‚Äî which is to say, I don‚Äôt know anything.</p>
<p>Oh yeah, and also I don‚Äôt know anything about data science or visualization. I‚Äôm a computer scientist by trade, and can navigate my way around complicated mathematics better than your average Joe. This projected seemed like a good opportunity to teach myself some of the more obscure bits of graph theory, interactive web design (most of the charts on this page are interactive,) data scraping and subsequent mining.</p>
<p>Often, outsiders can bring new ideas and techniques to otherwise insular communities. Despite knowing nothing, I managed to:</p>
<ul>
<li>determine the speed at which our court of appeal system works</li>
<li>find that somewhere between 33% and 50% of all cases are completely trivial and could be easily automated away</li>
<li>reliably find decisions that are important enough to have Wikipedia articles</li>
<li>find the asymptotics of the growth rate of Canadian case law</li>
<li>determine that BC and Alberta are by far the most powerful provinces with respect to the influence of their decisions, and,</li>
<li>separate decisions automatically into 860 different ‚Äúareas of law‚Äù</li>
</ul>
<p>These are not half-bad results, if I do say so myself. And if one guy who doesn‚Äôt really know how to use this technology can do this well, imagine how much damage someone with high-quality data, a budget, and knowledge could do. If you are in the legal field and aren‚Äôt yet positioning yourself for the upcoming automation wave, maybe this essay will help convince you that the system isn‚Äôt nearly as robust to automation as you might think. I did all of this in two weeks, as an outsider, with no domain knowledge. That should scare you.</p>
<p>Overall, I needed to collect and analyze all of the data myself. I spent maybe fifteen hours programming things, and roughly 336 hours collecting data. I fought with analytics tools for another ten hours, and this write-up took maybe twenty hours. It was a fun project, but I‚Äôm happy to be done with it.</p>
<h2 id="methodology">Methodology</h2>
<p>My assumption is that the citation graph of Canadian case law is sufficient to find interesting data in the law. Unfortunately, this data doesn‚Äôt seem to exist in any convenient format. <a href="https://canlii.org">CanLII</a> makes the data available on the web, but doesn‚Äôt provide any sort of downloadable database. So I needed to make my own.</p>
<p>I wired up a small web-scraper that would connect to CanLII and crawl through the millions of cases available there. My program loaded all the cases from the Supreme Court and provincial courts of appeal, then followed every cited case. And every case cited by every one of <em>those.</em> And so on and so forth, until there were no more cited cases I hadn‚Äôt yet downloaded.</p>
<p>After a few weeks of downloading, I was finished. In total, I downloaded 378,732 decisions from 269 different courts. Between these cases, there are 1,998,118 citations. Frighteningly, this is nowhere near the extent of Canadian case law; it‚Äôs maybe one tenth of the full corpus. But I feel comfortable in saying that <em>this subset is the law as it exists today.</em> If a case doesn‚Äôt lie anywhere in the transitive dependencies of the Supreme Court or a court of appeals, it‚Äôs not contentious for anyone to care about.</p>
<p>Despite the large number of cases, it‚Äôs important to discuss just how little data I‚Äôve got <em>per</em> case. The totality of my data about cases is of this form:</p>
<figure>
<table>
<TR>
<TH>
name
</TH>
<TH>
year
</TH>
<TH>
language
</TH>
<TH>
jurisdiction
</TH>
<TH>
court
</TH>
</TR>
<TR>
<TD>
Bamba c. R.
</TD>
<TD>
2019
</TD>
<TD>
fr
</TD>
<TD>
qc
</TD>
<TD>
qcca
</TD>
</TR>
<TR>
<TD>
R. v. Leach
</TD>
<TD>
2019
</TD>
<TD>
en
</TD>
<TD>
bc
</TD>
<TD>
bcca
</TD>
</TR>
<TR>
<TD>
R. v. Pruski
</TD>
<TD>
2006
</TD>
<TD>
en
</TD>
<TD>
on
</TD>
<TD>
oncj
</TD>
</TR>
<TR>
<TD>
Regina v. Imperial Optical Co. Ltd.
</TD>
<TD>
1972
</TD>
<TD>
en
</TD>
<TD>
on
</TD>
<TD>
oncj
</TD>
</TR>
<TR>
<TD>
Windheim c. Windheim
</TD>
<TD>
2012
</TD>
<TD>
en
</TD>
<TD>
qc
</TD>
<TD>
qcca
</TD>
</TR>
</table>
<figcaption>
decision data
</figcaption>
</figure>
<p>Notice that there is no information about the <em>contents</em> of these cases. I don‚Äôt know which judge was presiding, what was said, what the case was about, keywords, or even who won.</p>
<p>In principle I could have extracted the involved parties by trying to tear apart the name, but it seemed challenging to do well, and I don‚Äôt think it would buy me much information without knowing who won.</p>
<p>On the citation front, all I know is this:</p>
<figure>
<table>
<TR>
<TH>
citing_case
</TH>
<TH>
citing_year
</TH>
<TH>
cited_case
</TH>
<TH>
cited_year
</TH>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
Automobile and Supply Co. v. Hands, Ltd.
</TD>
<TD>
1913
</TD>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
The Queen v. Hammond
</TD>
<TD>
1898
</TD>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
The Queen v. Harris
</TD>
<TD>
1898
</TD>
</TR>
<TR>
<TD>
Gallagher v. Hogg
</TD>
<TD>
1993
</TD>
<TD>
Katz v. Katz
</TD>
<TD>
1990
</TD>
</TR>
<TR>
<TD>
Gallagher v. Hogg
</TD>
<TD>
1993
</TD>
<TD>
Lagimodiere v. Lagimodiere
</TD>
<TD>
1991
</TD>
</TR>
</table>
<figcaption>
citation data
</figcaption>
</figure>
<p>Again, no <em>actual</em> information here.</p>
<p>To reiterate, there‚Äôs nothing at all that we can use to learn what any particular case was <em>about.</em> In this database, the vanishing majority of the information available to us is which cases cite whom. Anything we want to figure out needs to be inferred from that.</p>
<h3 id="possible-issues">Possible Issues</h3>
<p>The Canadian legal system has existed much longer than the idea that information should be freely available. While CanLII is an excellent source of data, it explicitly states how complete its records are from each court. For example, while CanLII has the entire corpus of Supreme Court decisions, it‚Äôs only maintained continuous coverage of the BC Court of Appeal (BCCA) since 1990. Other courts have different starting dates for their continuous coverage.</p>
<p>This presents a systematic bias in our data, namely that more recent cases are more readily available. To illustrate, the database contains 6,212 cases from the BCCA before 1990, but 19,368 cases since. While we might be interested in whether the volume of law is increasing over time, we must be careful to restrict ourselves to the range of continuous coverage.</p>
<p>Looking only at citation data introduces another systematic bias in the dataset: older cases have had a longer time to accumulate citations. Because we mainly keep track of relationships between cases, it‚Äôs possible for recent cases to contradict previous decisions. Such a case is clearly very important to the law, but will fly under our radar until it becomes commonly cited.</p>
<h2 id="verifying-the-dataset">Verifying the Dataset</h2>
<p>Before getting started, let‚Äôs make sure our data is sane. For example, since case law is immutable, it‚Äôs impossible for a case to cite a decision in the future. Therefore we should never see any time-traveling citations in our dataset.</p>
<p>But in fact, there are 1197 cases on CanLII which cite decisions in the future! For example, <a href="https://www.canlii.org/en/ab/abqb/doc/1998/1998abqb476/1998abqb476.html">Molson v. Molson, 1998</a> cites <a href="https://www.canlii.org/en/sk/skqb/doc/2016/2016skqb387/2016skqb387.html">C.T.G. v R.R.G., 2016</a>. Clicking through the first link here shows that what is labeled as ‚ÄúMolson v. Molson, 1998‚Äù is <em>actually</em> ‚ÄúRichardson v. Richardson, 2019.‚Äù</p>
<p>A few other oddities show up, some of which are trial level courts citing their appeal. These seem more reasonable, and I read this as <em>whoever was doing data entry was typing in the wrong field.</em></p>
<p>This erroneous data makes up only 0.31% of our dataset, so it doesn‚Äôt seem like fixing it is worth the effort.</p>
<h2 id="average-age-of-citation">Average Age of Citation</h2>
<p>How long do decisions stay relevant for? By looking at the average age at which a decision is cited, we can get a feel.</p>
<figure>
<div id="avg-duration">
<p>select avg_age, count(*) from (select cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year group by dst_hash) group by avg_age;</p>
<script>
    lineChart(
      "#avg-duration",
      "/data/1612727565.csv",
      "Avg Age of Decision when Cited",
      d => +parseInt(d.avg_age),
      "Decisions",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of cases, by average age at time of citation
</figcaption>
</figure>
<p>It looks like cases stay relevant for about 11 years, at which point the inflection point of this graph switches, and we see the long tail. This is for the law in aggregate, but what about if we look at the average age when cited, broken down by court?</p>
<figure>
<div id="avg-duration-by-court">
<p>select dst_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and dst_court in (select court from important_courts order by max desc limit 15) group by dst_court;</p>
<script>
    barChart(
      "#avg-duration-by-court",
      "/data/1612746186.csv",
      d => d.dst_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age at time of citation, by court
</figcaption>
</figure>
<p>This chart shows the top 15 most important courts. Among them, the <em>really big, important courts</em> hold sway longer than the smaller courts. But is the story different for the smallest courts?</p>
<figure>
<div id="avg-duration-by-smallest-court">
<p>select dst_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and dst_court in (select court from important_courts order by max asc limit 10) group by dst_court;</p>
<script>
    barChart(
      "#avg-duration-by-smallest-court",
      "/data/1612746614.csv",
      d => d.dst_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age at time of citation, by small court
</figcaption>
</figure>
<p>Definitely a different story here. These smaller courts‚Äô decisions fall off in relevance significantly faster than their larger counterparts.</p>
<p>A corollary to this question of law relevance is to look <em>not at the citee, but the citing case.</em> What is the average age of a case‚Äôs citations?</p>
<figure>
<div id="avg-age">
<p>select avg_age, count(*) from (select cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year group by src_hash) group by avg_age;</p>
<script>
    lineChart(
      "#avg-age",
      "/data/1612727606.csv",
      "Avg Age of Cited Decisions",
      d => +parseInt(d.avg_age),
      "Decisions",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of cases, by average age of citation
</figcaption>
</figure>
<p>The fall-off here is closer to 20 years ‚Äî compared to the ten year average lifespan of a decision. The discrepancy between these numbers suggests that cases are likely to a few old cases and numerous newer ones. Maybe cases will cite an original precedent, and then many other cases that have followed the precedent?</p>
<p>When looking at average age of citation, we can look for trends over time. How has the average age of citation changed over the years?</p>
<figure>
<div id="avg-age-by-year">
<p>select src_year, avg(avg_age) as avg_age from (select src_year, avg(src_year - dst_year) as avg_age from expanded_citations where src_year &gt;= dst_year group by src_hash) group by src_year;</p>
<script>
    lineChart(
      "#avg-age-by-year",
      "/data/1612747472.csv",
      "Year",
      d => +parseInt(d.src_year),
      "Avg (Avg Age) of Cited Decisions",
      d => +parseFloat(d.avg_age).toFixed(2))
  </script>
</div>
<figcaption>
Average average age of citation, by year
</figcaption>
</figure>
<p>And again, let‚Äôs compare these average ages by big courts:</p>
<figure>
<div id="avg-age-by-court">
<p>select src_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and src_court in (select court from important_courts order by max desc limit 15) group by src_court;</p>
<script>
    barChart(
      "#avg-age-by-court",
      "/data/1612747795.csv",
      d => d.src_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age of citation, by court
</figcaption>
</figure>
<p>Wow! Look at the big courts. There is almost no variance in the average age of citations ‚Äî they‚Äôre all clustered right around 13. Seeing as these are all of the appeal-level courts, it strongly suggests that <strong>this is the speed of our legal system.</strong> It takes thirteen years on average to make it through the entire appeal process. Disgustingly slow.</p>
<p>There‚Äôs nothing interesting in the small courts graph ‚Äî they show the same variances as in the duration of case relevance.</p>
<h2 id="complexity-of-the-law">Complexity of the Law</h2>
<p>Although there are nearly 400,000 cases in our dataset, I don‚Äôt think most of those can possibly be interesting. My understanding of case law is that usually a precedent has already been set, and the judge almost always defers to that precedent. To find cases like these, we can look at the number of decisions cited by a case. If a case cites only a few decisions (let‚Äôs say three or fewer,) it‚Äôs probably just agreeing with precedent.</p>
<figure>
<div id="complexity">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) group by src_hash) group by c; BUCKETED BY HAND</p>
<script>
    pieChart(
      "#complexity",
      "/data/1612748474.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited
</figcaption>
</figure>
<p>The number of cases cited falls off exponentially as we‚Äôd expect, so I bucketed the higher number of citations in this chart. But take a look: roughly one third of all cases cite three or fewer decisions, and nearly a sixth cite <em>only one!</em></p>
<p>If our hypothesis is true, it means that one sixth of all cases are glaringly obvious wastes of time, and a third are trivially decided. But does this hold true across all courts? Let‚Äôs look at the breakdown for a few of the highest importance courts:</p>
<figure>
<div id="complexity-scc">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_year &gt;= 1950 and src_court = ‚Äòscc‚Äô group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-scc",
      "/data/1612750035.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (SCC, 1950+)
</figcaption>
</figure>
<p>I filtered the SCC decisions to only look at cases after 1950 ‚Äî earlier ones were too likely to not have their citations available on CanLII, and would thus throw off our analysis. But amazingly, even of cases that make it to the Supreme Court, still more than a third of them cite only three or fewer decisions.</p>
<p>That sounds a little crazy to me, so I went on CanLII and randomly clicked on a few supreme court cases. And sure enough, many of them <em>do</em> only cite one case! Inspecting them visually, these cases come with extraordinarily short documents ‚Äî many are under 1000 words.</p>
<p>Let‚Äôs see if this holds for the AB, BC, ON and QC courts of appeal as well:</p>
<figure>
<div id="complexity-abca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‚Äòabca‚Äô group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-abca",
      "/data/1612750541.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (ABCA)
</figcaption>
</figure>
<figure>
<div id="complexity-bcca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‚Äòbcca‚Äô group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-bcca",
      "/data/1612750650.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (BCCA)
</figcaption>
</figure>
<figure>
<div id="complexity-onca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‚Äòonca‚Äô group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-onca",
      "/data/1612750834.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (ONCA)
</figcaption>
</figure>
<figure>
<div id="complexity-qcca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‚Äòqcca‚Äô group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-qcca",
      "/data/1612750959.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (QCCA)
</figcaption>
</figure>
<p>Pretty close to <em>half</em> of the cases that come through these appeal-level courts are trivial. If we could automate decisions of this sort, we should be able to make the appeal system roughly 70% faster ‚Äî reducing the average time per case from 13 years to 7.5. I can‚Äôt find any numbers on how expensive the court system is to run, but this would reduce its cost by 70% as well, which is almost certainly something worth investigating.</p>
<h2 id="volume-of-law">Volume of Law</h2>
<p>What‚Äôs the rate of law being accumulated? Is it accelerating? We can look at the number of cases per year per court over the last 30 years<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> to get a sense of the acceleration of accumulation:</p>
<figure>
<div id="volume">
<p>select court, year, count(*) as count from decisions d where court in (select court from important_courts order by max desc limit 10) and year &gt;= 1990 and year &gt;= (select year from coverage c where d.court = c.court) and 2021 &gt; year group by court, year;</p>
<script>
    multiLineChart(
      "#volume",
      "/data/1612761383.csv",
      d => d.court,
      d => +parseInt(d.year),
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Volume of decisions by top courts, starting after dates of continuing coverage
</figcaption>
</figure>
<p>Those lines all look pretty constant to me, which makes sense if you assume the courts are limited by time and that they have no gains in efficiency (lol.) So no, the volume at which law is accumulating in Canada is not accelerating. But remember that this graph is the velocity of change, which means the volume of law is growing linearly with respect to time.</p>
<figure>
<div id="total-volume">
<p>select y.year, count(*) as volume from (select distinct year from decisions order by year) y inner join decisions d on y.year &gt;= d.year where 2021 &gt; y.year group by y.year;</p>
<script>
    lineChart(
      "#total-volume",
      "/data/1612762714.csv",
      "Year",
      d => +parseInt(d.year),
      "Volume of Law",
      d => +parseInt(d.volume))
  </script>
</div>
<figcaption>
Number of cases in existence, by year
</figcaption>
</figure>
<p>No, wait, that <em>does</em> look exponential. I forgot. While the volume <em>per court</em> is staying constant, the number <em>of courts</em> grows with year:</p>
<figure>
<div id="total-volume-courts">
<p>select y.year, count(*) as volume from (select distinct year from decisions order by year) y inner join (select min(year) as year from decisions group by court) c on y.year &gt;= c.year where 2021 &gt; y.year group by y.year;</p>
<script>
    lineChart(
      "#total-volume-courts",
      "/data/1612762752.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Courts",
      d => +parseInt(d.volume))
  </script>
</div>
<figcaption>
Number of courts in existence, by year
</figcaption>
</figure>
<p>This graph estimates the number of courts in existence by the first decision we have from that court being the year it was created ‚Äî which seems like a satisfactory proxy. The curve appears to have leveled off, but I think this is due to 2020 being a GLOBAL PANDEMIC. If I had to guess, I‚Äôd say the inflection point around 1997 is an artifact of the digitization of law, and that this curve will continue linearly.</p>
<h2 id="who-cites-whom">Who Cites Whom?</h2>
<p>Are certain provinces ‚Äúfriends?‚Äù Which provinces influence which others? Let‚Äôs look at the percentage by which one provinces‚Äô courts cite another provinces:</p>
<figure>
<div id="juris-cite-juris">
<p>with data as (select src_jurisdiction, dst_jurisdiction, count(<em>) as count from expanded_citations where src_jurisdiction != dst_jurisdiction group by src_jurisdiction, dst_jurisdiction), totals as (select src_jurisdiction, sum(count) as total from data group by src_jurisdiction) select d.src_jurisdiction, d.dst_jurisdiction, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_jurisdiction = t.src_jurisdiction;</p>
<script>
    heatTable(
      "#juris-cite-juris",
      "/data/1612768242.csv",
      d => d.dst_jurisdiction,
      d => d.src_jurisdiction,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing jurisdiction (left) by cited jurisdiction (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>Yow! The fed is understandably white hot, and dominates this chart. Let‚Äôs remove it to look more closely at the provinces:</p>
<figure>
<div id="juris-cite-juris-no-ca">
<p>with data as (select src_jurisdiction, dst_jurisdiction, count(<em>) as count from expanded_citations where src_jurisdiction != dst_jurisdiction and src_jurisdiction != ‚Äòca‚Äô and dst_jurisdiction != ‚Äòca‚Äô group by src_jurisdiction, dst_jurisdiction), totals as (select src_jurisdiction, sum(count) as total from data group by src_jurisdiction) select d.src_jurisdiction, d.dst_jurisdiction, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_jurisdiction = t.src_jurisdiction;</p>
<script>
    heatTable(
      "#juris-cite-juris-no-ca",
      "/data/1612769065.csv",
      d => d.dst_jurisdiction,
      d => d.src_jurisdiction,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing jurisdiction (left) by cited jurisdiction (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>Now Ontario dominates, followed closely by BC and Alberta. Nobody cites the territories ‚Äî but also, nobody cites Quebec. No wonder they feel discriminated against.</p>
<p>Let‚Äôs look at the same chart, but this time split by big courts rather than provinces.</p>
<figure>
<div id="court-cite-court">
<p>with courts as (select court from important_courts order by max desc limit 13), data as (select src_court, dst_court, count(<em>) as count from expanded_citations where src_court != dst_court and src_court in courts and dst_court in courts group by src_court, dst_court), totals as (select src_court, sum(count) as total from data group by src_court) select d.src_court, d.dst_court, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_court = t.src_court;</p>
<script>
    heatTable(
      "#court-cite-court",
      "/data/1612769747.csv",
      d => d.dst_court,
      d => d.src_court,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing court (left) by cited court (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>There‚Äôs an interesting feature of this graph, namely the ‚Äúfriendship pairs‚Äù that lie along the diagonal. For example, <code>bcsc</code> cites <code>bcca</code> much more than it cites anything but the <code>scc</code> ‚Äî and vice versa! Thinking about it, I guess this makes sense, and is mainly showing us the hierarchical nature of such courts. Of course <code>bcsc</code> cites <code>bcca</code> more than chance, since it must defer. And vice versa also makes sense, because a case must go through <code>bcsc</code> in order to get to <code>bcca</code>.</p>
<p>Well, not every stream you pan will have gold.</p>
<h2 id="determining-important-cases">Determining Important Cases</h2>
<p>The sheer size of the case law corpus is staggering. My dataset contains roughly 400,000 decisions ‚Äî a small fraction of the <em>actual law.</em> And this is a few orders of magnitude larger than any human could possibly remember.</p>
<p>Thankfully, most of this data is noise. Most cases taken to court are decided uninterestingly: the presiding judge simply defers to precedent and everyone goes on their way. It‚Äôs safe to say that decisions of this sort are unimportant. In my opinion, the desired end-state of the law is for all cases to be decided like this ‚Äî at that point, we‚Äôve got a stable, entirely-predictable system.</p>
<p>But that is not (yet!) the world we live in. Some cases <em>are</em> interesting ‚Äî for example, the ones which <em>set</em> precedent, and the ones which <em>contradict</em> precedent. How can we find these cases?</p>
<p>Humans would probably look at the cases, and think about first principles, and talk to other people they think are smart, and think really hard, and maybe go consult some textbooks, in an attempt to determine which cases are important. The computer is too dumb to do any of that. It‚Äôs only good at moving numbers around ridiculous fast, and I‚Äôm very good at turning problems that don‚Äôt sound like they involve numbers into ones that do.</p>
<p>So how can we introduce numbers into this problem?</p>
<p>Rather than trying to compute importance directly, let‚Äôs instead try to approximate it. Intuitively, cases which are important will be cited more often than cases which are not important. Thus, citation count is ‚Äî to a first approximation ‚Äî a good model for importance. Indeed, this seems to be how most <a href="https://www.lexisnexis.com/ln-media/totg/p/lotg.aspx?mediaid=121105">law software</a> computes importance.</p>
<p>To improve our model, let‚Äôs take an intellectual detour and think about the importance of websites. Imagine the website for Reputable News Network (RNN). By virtue of being a reputable news site, it will naturally be linked to quite often. Like in the case law example, this should improve our estimate of RNN being an important site.</p>
<p>But now consider <em>the sites that RNN links to.</em> Maybe RNN is running a story on bloggers, and links to Paul Podunk‚Äôs Personal Page (PPPP). PPPP is news-worthy by definition due to being on RNN, and surely news-worthy things are more important than non-influential things. Thus, PPPP should be considered more important, sheerly by virtue of having been linked-to by an important thing.</p>
<p>Of course, this new influence that PPPP has acquired from RNN should also be accounted for ‚Äî sites that PPPP links to become more important due to their relevance to PPPP. And so on, and so forth. But critically, these sites are considered <em>less</em> important than they would be if RNN linked to them directly, since RNN is significantly more influential than PPPP.</p>
<p>The key assumption of this model is that important things run in the same circles as other important things. This jives with my intuition. It‚Äôs clearly true in the news cycle. It‚Äôs why people name drop in order to raise their social standing ‚Äî if they know important people, they must too be important. Of course, this is not a perfect model for importance, but it gets the broad strokes.</p>
<p>And, if you have any remaining doubts, this exact algorithm is what powers Google search. Clearly, Google (an important entity) wouldn‚Äôt be using this technique if it didn‚Äôt work. Therefore it probably does work. See? This technique works <em>everywhere.</em></p>
<p>Returning to law, let‚Äôs replace ‚Äúwebsites‚Äù with ‚Äúdecisions,‚Äù and ‚Äúlinks‚Äù with ‚Äúcitations.‚Äù We can compute the importance of cases by seeing which important cases they‚Äôre connected to.</p>
<h3 id="verifying-important-cases">Verifying Important Cases</h3>
<p>After crunching the numbers for a few hours, I came up with an <em>importance score</em> for each case. It‚Äôs hard to get a real intuition for <a href="https://en.wikipedia.org/wiki/Eigenvector_centrality">what these scores <em>are</em></a>, but a safe interpretation is that a higher importance score corresponds to a more-important case.</p>
<p>To verify that these importance scores actually correspond with reality, I took the names and years of the top 50 cases, and searched for a Wikipedia page on the topic. My theory is that <em>really</em> important cases will be important enough to have Wikipedia commentary about them for laypeople like me.</p>
<p>At time of writing, of the top 50 cases, 34 have Wikipedia articles. And among those, 22 are described in the first sentence as either a ‚Äúlandmark‚Äù or a ‚Äúleading‚Äù case.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> That‚Äôs a pretty good sign.</p>
<p>Without further ado, here are the 50 most important cases by my analysis:</p>
<ol>
<li>
<a href="https://en.wikipedia.org/wiki/Dunsmuir_v_New_Brunswick">Dunsmuir v. New Brunswick</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Minister_of_Citizenship_and_Immigration)_v_Khosa">Canada (Citizenship and Immigration) v. Khosa</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Baker_v_Canada_(Minister_of_Citizenship_and_Immigration)">Baker v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Dunsmuir_v_New_Brunswick">Newfoundland and Labrador Nurses‚Äô Union v. Newfoundland and Labrador (Treasury Board)</a>
</li>
<li>
Housen v. Nikolaisen, 2002
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Hunter_v_Southam_Inc">Hunter et al. v. Southam Inc.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Collins_(1987)">R. v. Collins</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Oakes">R. v. Oakes</a>
</li>
<li>
Alberta (Information and Privacy Commissioner) v. Alberta Teachers‚Äô Association, 2011
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Pushpanathan_v_Canada_(Minister_of_Citizenship_and_Immigration)">Pushpanathan v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Re_Rizzo_%26_Rizzo_Shoes_Ltd">Rizzo &amp; Rizzo Shoes Ltd. (Re)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Dr_Q_v_College_of_Physicians_and_Surgeons_of_British_Columbia">Dr.¬†Q. v. College of Physicians and Surgeons of British Columbia</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Director_of_Investigation_and_Research)_v_Southam_Inc">Canada (Director of Investigation and Research) v. Southam Inc.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Law_Society_of_New_Brunswick_v_Ryan">Law Society of New Brunswick v. Ryan</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Big_M_Drug_Mart_Ltd">R. v. Big M Drug Mart Ltd.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Grant">R. v. Grant</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Reference_Re_BC_Motor_Vehicle_Act">Re B.C. Motor Vehicle Act</a>
</li>
<li>
Agraira v. Canada (Public Safety and Emergency Preparedness), 2013
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canadian_Union_of_Public_Employees_v_Ontario_(Minister_of_Labour)">C.U.P.E. v. Ontario (Minister of Labour)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Suresh_v_Canada_(Minister_of_Citizenship_and_Immigration)">Suresh v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Stillman">R. v. Stillman</a>
</li>
<li>
R. v. M. (C.A.), 1996
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_O%27Connor">R. v. O‚ÄôConnor</a>
</li>
<li>
Toronto (City) v. C.U.P.E., Local 79, 2003
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Andrews_v_Law_Society_of_British_Columbia">Andrews v. Law Society of British Columbia</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Irwin_Toy_Ltd_v_Quebec_(AG)">Irwin Toy Ltd. v. Quebec (Attorney General)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(AG)_v_Mossop">Canada (Attorney General) v. Mossop</a>
</li>
<li>
Bell ExpressVu Limited Partnership v. Rex, 2002
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Minister_of_Citizenship_and_Immigration)_v_Vavilov">Canada (Minister of Citizenship and Immigration) v. Vavilov</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canadian_Union_of_Public_Employees,_Local_963_v_New_Brunswick_Liquor_Corp">C.U.P.E. v. N.B. Liquor Corporation</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Edwards_Books_and_Art_Ltd">R. v. Edwards Books and Art Ltd.</a>
</li>
<li>
R. v. Lyons, 1987
</li>
<li>
McLean v. British Columbia (Securities Commission), 2013
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Union_des_Employes_de_Service,_Local_298_v_Bibeault">U.E.S., Local 298 v. Bibeault</a>
</li>
<li>
Canada (Canadian Human Rights Commission) v. Canada (Attorney General), 2011
</li>
<li>
R. v. Garofoli, 1990
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Blencoe_v_British_Columbia_(Human_Rights_Commission)">Blencoe v. British Columbia (Human Rights Commission)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Therens">R. v. Therens</a>
</li>
<li>
Smith v. Alliance Pipeline Ltd., 2011
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_W_(D)">R. v. W.(D.)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/RJR-MacDonald_Inc_v_Canada_(AG)">RJR-MacDonald Inc. v. Canada (Attorney General)</a>
</li>
<li>
Sketchley v. Canada (Attorney General), 2005
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Mann">R. v. Mann</a>
</li>
<li>
Cepeda-Gutierrez v. Canada (Minister of Citizenship and Immigration), 1998
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Slaight_Communications_Inc_v_Davidson">Slaight Communications Inc. v. Davidson</a>
</li>
<li>
Committee for Justice and Liberty et al. v. National Energy Board et al., 1976
</li>
<li>
R. v. Debot, 1989
</li>
<li>
Mission Institution v. Khela, 2014
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Morgentaler">R. v. Morgentaler</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Sharpe">R. v. Sharpe</a>
</li>
</ol>
<p>If you‚Äôre a law professional, you might disagree with this list. Maybe the ordering is wrong. Maybe there are some glaring omissions, or some strange choices. Glaring omissions are probably caused by recency bias ‚Äî new important decisions simply haven‚Äôt had time to accumulate citations (and thus importance.) The wrong ordering? That‚Äôs just like, your opinion, man.</p>
<p>But of particular interest to me are the cases on this list that <em>aren‚Äôt on Wikipedia.</em> Assuming Wikipedia is a reasonable proxy for what lawyers think are important cases, the missing articles here have previously-unacknowledged importance.</p>
<p>Anyway, it seems like my calculated importance score correlates pretty well with real-world importance. But let‚Äôs try to falsify that hypothesis, and see if the bottom-ranked cases have Wikipedia articles.</p>
<p>I checked. They don‚Äôt. Not a single hit in the 50 I tried<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. I also checked for Wikipedia articles on a randomly-selected set of 50 cases, in an attempt to find the base-rate we should expect to see. Again, there wasn‚Äôt a single hit.</p>
<p>These negative results add strong evidence that my importance score is <em>measuring something real.</em> Remember, there is absolutely no human judgment going into this analysis; <em>my program is simply crunching the numbers based on who cites whom.</em> The fact that it can identify <em>any</em> important cases whatsoever is jaw-dropping.</p>
<h3 id="statistical-biases">Statistical Biases</h3>
<p>So we‚Äôve successfully found important cases. My first question is, how necessary was all of this fancy math? Could I just have ignored it and gone straight to number of citations? How correlated is the importance metric with the raw number of citations? Let‚Äôs see:</p>
<figure>
<div id="correlation">
<p>select dst_importance, count(*) as count from expanded_citations group by dst_hash order by dst_importance desc limit 1000 offset 1;</p>
<script>
    scatter(
      "#correlation",
      "/data/1612759421.csv",
      "Importance",
      d => parseFloat(d.dst_importance).toFixed(5),
      "Citation Count",
      d => +d.count)
  </script>
</div>
<figcaption>
Correlation between the importance metric and the number of times cited.
</figcaption>
</figure>
<p>If the two metrics were strongly correlated, we should see a nice sharp diagonal line going up and to the right. We don‚Äôt. Instead we see, well, I‚Äôll leave the Rorschach test up to you. There‚Äôs clearly some correlation, but it‚Äôs not particularly strong. So no ‚Äî we can‚Äôt just use the citation count!</p>
<p>Another thing you might be wondering is, ‚Äúwhat courts do all these important cases come from?‚Äù Good question:</p>
<figure>
<div id="court-of-important-cases">
<p>select court, count(*) as count from (select court from decisions order by importance desc limit 1000) x group by court having count &gt; 20; THEN OTHER = 1000 -</p>
<script>
    pieChart(
      "#court-of-important-cases",
      "/data/1612753367.csv",
      d => d.court,
      d => d.count)
  </script>
</div>
<figcaption>
Courts of the top 1000 important cases
</figcaption>
</figure>
<p>Interesting. The Supreme Court takes most of the cake, but Ontario and Quebec are crowded out by BC and Alberta. Drilling down into the ‚Äúother‚Äù category from the chart above:</p>
<figure>
<div id="court-of-other-cases">
<p>select court, count(*) as count from (select court from decisions order by importance desc limit 1000) x group by court having count &lt;= 20 and count &gt; 5;</p>
<script>
    pieChart(
      "#court-of-other-cases",
      "/data/1612753494.csv",
      d => d.court,
      d => d.count)
  </script>
</div>
<figcaption>
Drilling down on the ‚Äúother‚Äù category
</figcaption>
</figure>
<p>It surprising to me that Ontario and Quebec are so underrepresented in their number of important cases, compared to their populations and age. I don‚Äôt know what‚Äôs going on here ‚Äî please let me know if you do, gentle reader.</p>
<p>The other big question I have is to what degree this importance factor is biased by the courts‚Äô continuous coverage. That is to say, of the most important cases identified, how many of them are from before CanLII started continuous coverage?</p>
<!--
select count(*) as count, c.year from decisions d inner join coverage c on d.court = c.court where d.hash in (select hash from decisions where court != 'scc' order by importance desc limit 1000) and d.year < c.year;
-->
<p>Only 13 of the top 1000 (1.3%) cases are from before the year of continuous coverage. This doesn‚Äôt jive with my intuition ‚Äî presumably the cases which are on CanLII before the date of continuous coverage <em>are the most important ones.</em> They‚Äôre the cases that someone went in and added manually, before the system was set up to track this stuff automatically.</p>
<p>OK, so the importance metric is clearly biased against old cases. But is it also biased against <em>new</em> cases? Let‚Äôs look at the number of top important cases by year:</p>
<figure>
<div id="new-bias">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by importance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#new-bias",
      "/data/1612754087.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases, by year
</figcaption>
</figure>
<p>Rather surprisingly, it doesn‚Äôt seem to be. I‚Äôd expect newer cases to not have had time to accumulate citations, and to thus be biased-against in the importance metric. So what‚Äôs going on here? It‚Äôs that I slightly lied to you earlier; that our importance metric doesn‚Äôt take into account the direction of the citation. In essence, it means that you get the same amount of influence for citing important cases as you would for important cases citing you. This is often a better approach than the directed version for datasets in which there are no loops. In the absence of loops (where X cites Y which cites Z which cites X again,) all of the influence gets pooled at the very oldest cases, and in effect tracks progeny.</p>
<p>Switching to this directed importance metric will likely show the bias against recency that we‚Äôd expect to see. So let‚Äôs look at that same chart as before, except using the directed importance metric instead:</p>
<figure>
<div id="dimportance">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by dimportance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#dimportance",
      "/data/1612754125.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases with the directed importance metric, by year
</figcaption>
</figure>
<!-- TODO(sandy): add support for missing data to lineChart -->
<p>This metric nicely prioritizes old cases, like our previous metric emphasized newer cases. In fact, the directed importance score puts 865 of the its top 1000 (86.5%) cases before the date of continuous coverage.</p>
<p>We‚Äôd be very happy if we could somehow mix the two metrics together to get an importance score that has no time-bias. Unfortunately, it‚Äôs unclear to me how to combine the two together; we probably can‚Äôt meaningfully add eigenvalues ‚Äî but let‚Äôs try it anyway.</p>
<figure>
<div id="both-importance">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by importance + dimportance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#both-importance",
      "/data/1612754230.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases with the sum importance metric, by year
</figcaption>
</figure>
<p>I don‚Äôt know if this is meaningful. It seems unlikely that there was a period of 40 years from 1940 to 1980 in which no important decisions were made ‚Äî but then I realized this corresponds pretty closely when with Canada became a Commonwealth nation (1931) and when it became sovereign (1982). To quote the <a href="https://www.history.com/news/canada-independence-from-britain-france-war-of-1812">first link on Google I found</a>:</p>
<blockquote>
<p>In 1931, England put Canada on equal footing with other Commonwealth countries through the Statute of Westminster, which essentially gave its dominions full legal freedom and equal standing with England and one another. However, Britain still had the ability to amend the Canadian constitution, and <strong>Canada took time to cut its legal ties to England</strong>. Meanwhile, it adopted its own national symbols, like the Canadian flag, featuring the maple leaf, which debuted in 1965.</p>
<p>It took five decades after the Statute of Westminster for Canada to make its final step toward full sovereignty. In 1982, it adopted its own constitution and became a completely independent country.</p>
</blockquote>
<p>Emphasis mine. Maybe this ‚Äútaking its time‚Äù stuff was just Canada coasting? Hopefully the law and/or history people can get in touch and let me know if this graph of mine is at all meaningful. This is flaw in the data-driven approach ‚Äî your analysis can only be as good as your data is. We‚Äôre always going to need subject matter experts.</p>
<h2 id="discovering-neighborhoods">Discovering Neighborhoods</h2>
<p>Imagine I give you a map of the world‚Äôs road network, with all of the topological features like water and altitude removed, as well as all landmarks and zoning information. For example:</p>
<p><img src="/images/law/city.png" style="width: 100%"></p>
<p>There are two cities on this map. It‚Äôs not very hard to spot them, is it? The cities are exceptionally dense networks of roads, compared to the relatively spare highways that connect them.</p>
<p>Interestingly, this same phenomenon occurs within cities:</p>
<p><img src="/images/law/neighborhood.png" style="width: 100%"></p>
<p>It‚Äôs easy to find downtown on this map, and if you pay attention to what are obviously bridges, you can find the smaller cities that make up the big metropolitan area. Again, the trick is to identify areas that have tightly woven intra-road networks, but relatively sparse interconnections.</p>
<p>We can use this same trick to identify ‚Äúneighborhoods‚Äù of law ‚Äî that is, clusters of cases that commonly cite one another, but which rarely cite other neighborhoods. <a href="https://en.wikipedia.org/wiki/Louvain_method">Our algorithm</a> starts by putting every case in its own (very lonely) community, and then merging communities which are more interconnected than should be expected by random.</p>
<p>After crunching the numbers, the five most important decisions in each of our three most important, highly-populated communities are:</p>
<h3 id="community-249">Community 249</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2008/2008scc9/2008scc9.html">Dunsmuir v. New Brunswick</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2009/2009scc12/2009scc12.html">Canada (Citizenship and Immigration) v. Khosa</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1999/1999canlii699/1999canlii699.html">Baker v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2011/2011scc62/2011scc62.html">Newfoundland and Labrador Nurses‚Äô Union v. Newfoundland and Labrador (Treasury Board)</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2011/2011scc61/2011scc61.html">Alberta (Information and Privacy Commissioner) v. Alberta Teachers‚ÄôAssociation</a>
</li>
</ul>
<p>In order to try and figure out what community this is (249 isn‚Äôt a <em>great</em> name<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>), I clicked on each CanLII link and read (with my <em>eyes,</em> like a <em>peasant</em>) the tags that whoever filed these cases wrote down. They are:</p>
<ul>
<li>Administrative law ‚Äì Procedural fairness</li>
<li>Administrative law ‚Äì Review of discretion ‚Äì Approach to review of discretionary decision making.</li>
<li>Administrative law ‚Äì Judicial review ‚Äì Implied decision</li>
<li>Administrative law ‚Äì Judicial review ‚Äì Standard of review</li>
<li>Administrative law ‚Äì Natural justice ‚Äì Procedural fairness</li>
<li>Administrative law ‚Äì Role and adequacy of reasons ‚Äì Procedural fairness</li>
<li>Administrative law ‚Äì Standard of review</li>
<li>Courts ‚Äì Appellate review</li>
</ul>
<p>Looks like community 249 is really some sort of administrative review of law.</p>
<p>Remember, I only looked at these tags in order to try to give a human-appropriate name to community 249. The computer didn‚Äôt have access to these tags when it was discovering it; it was merely looking at where the roads are dense.</p>
<h3 id="community-527">Community 527</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1986/1986canlii46/1986canlii46.html">R. v. Oakes</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1985/1985canlii69/1985canlii69.html">R. v. Big M Drug Mart Ltd.</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1985/1985canlii81/1985canlii81.html">Re B.C. Motor Vehicle Act</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1989/1989canlii2/1989canlii2.html">Andrews v. Law Society of British Columbia</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1989/1989canlii87/1989canlii87.html">Irwin Toy Ltd. v. Quebec (Attorney General)</a>
</li>
</ul>
<p>The tags here are:</p>
<ul>
<li>Constitutional law ‚Äì Canadian Charter of Rights and Freedoms</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Application</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Freedom of expression</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Fundamental justice</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Presumption of innocence</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Reasonable limits</li>
</ul>
<p>Seems pretty cut and dried. ‚ÄúCharter of Rights.‚Äù</p>
<h3 id="community-192">Community 192</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1984/1984canlii33/1984canlii33.html">Hunter et al. v. Southam Inc.</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1987/1987canlii84/1987canlii84.html">R. v. Collins</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2009/2009scc32/2009scc32.html">R. v. Grant</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1997/1997canlii384/1997canlii384.html">R. v. Stillman</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1990/1990canlii52/1990canlii52.html">R. v. Garofoli</a>
</li>
</ul>
<p>With tags:</p>
<ul>
<li>Constitutional law ‚Äì Canadian Charter of Rights and Freedoms ‚Äì Unreasonable search and seizure</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Admissibility of evidence</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Arbitrary detention</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Enforcement ‚Äî Exclusion of evidence</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Search and seizure</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Security of person</li>
<li>Constitutional law ‚Äì Charter of Rights ‚Äì Unreasonable search and seizure</li>
<li>Criminal law ‚Äì Interception of private communications ‚Äì Access to sealed packet ‚Äì Validity of wiretap authorizations</li>
<li>Criminal law ‚Äì Interception of private communications ‚Äì Admissibility of evidence</li>
<li>Criminal law ‚Äì Power of search incidental to arrest</li>
</ul>
<p>This one is very clearly on the police being naughty and doing things they shouldn‚Äôt.</p>
<p>I‚Äôve said it before but I‚Äôm going to say it again. There is <em>very clearly</em> a theme in these cases, and <em>we found it using only math, with absolutely no knowledge of the law.</em></p>
<h3 id="continuing-analysis-of-communities">Continuing Analysis of Communities</h3>
<p>Just for fun, let‚Äôs chart decisions by year and community for the six most populated communities.</p>
<figure>
<div id="chart-importance">
<p>select name, year, importance, community from decisions where community in (19, 192, 225, 249, 527, 635) order by importance desc limit 500;</p>
<script>
    dotChart(
      "#chart-importance",
      "/data/1612756205.csv",
      d => +d.year,
      d => +d.community,
      d => parseFloat(d.importance).toFixed(4),
      d => +d.community,
      d => truncateString(d.name, 80))
  </script>
</div>
<figcaption>
Important cases by year and community. Larger dots are more important. Community is on the Y axis.
</figcaption>
</figure>
<p>This gives us a sense of what sorts of things the law is focused on over time. For example, since 2010 there‚Äôs been a huge flurry of activity in community 249 (review of law.) Why? I don‚Äôt know, but clearly something is going on. The activity seems to be precipitated by <em>Dunsmuir v. New Brunswick,</em> so what we‚Äôre seeing is all the fallout from that case.</p>
<p>And we can see that community 192 (police being naughty) was very active from 1985 to 1995, but quieted down until a spike in 2009, and has been quiet since 2014. Maybe the police have been on good behavior since then?</p>
<h2 id="conclusion">Conclusion</h2>
<p>I‚Äôve now been writing for eight hours straight, and I can no longer reliably spell ‚Äújurisdiction.‚Äù So it‚Äôs time to finish this up and then go directly to bed.</p>
<p>Personally, I find it fascinating just how much information can be gleamed from nothing but citation data and some clever choices of visualizations. The biggest takeaways in terms of policy from this project in my opinion are:</p>
<ul>
<li>The amount of case law is growing super-linearly ‚Äî and, horrifyingly, the curve appears to be exponential. Despite every court generating law at a constant rate, the growth rate of courts themselves is increasing. <em>This is clearly an untenable system.</em></li>
<li>Most decisions become irrelevant after only one year; the vast majority of hem are forgotten after ten.</li>
<li>Somewhere between 33% and 50% of all decisions just follow precedent. That‚Äôs a waste of everyone‚Äôs time and the countries resources. There are huge efficiencies to be gained here if we can find a way of automating that stuff.</li>
</ul>
<p>In aggregate, this means our legal system is doing a huge amount of work churning out an ever growing number of decisions which get added to the annals of time ‚Äî a good chunk of which are completely trivial, and almost all of which are forgotten soon after. This is extremely good evidence that the court system structuring itself as an <a href="https://en.wikipedia.org/wiki/Append-only">append-only datastructure</a> is a bad design. There‚Äôs no reason to continuously write down the answer you already know, and never check it again; automate that stuff, don‚Äôt add it to the corpus of law, and save the courts for more important matters.</p>
<p>While we‚Äôre talking about automating things, someone could <em>definitely</em> use the community-finding algorithm to put the poor bastard responsible for adding keywords to case summaries out of his misery.</p>
<p>Some intriguing takeaways, with no relevance to anything:</p>
<ul>
<li>There appear to be many extremely important decisions (in terms of influence) that are not well-enough recognized to be on Wikipedia. Is this a flaw in Wikipedia‚Äôs coverage, or is the importance of these cases unknown to the world of law?</li>
<li>This math stuff is actually useful for real-life things.</li>
</ul>
<p>If you‚Äôre interested in running your own analysis on this data without needing to scrape CanLII for a few weeks, <a href="https://mega.nz/file/YBomET6L#M2oBRiIRQTN_YJ4eiFiDjlkdNrEf8jbQG2a0wLkahNs">it‚Äôs available as a sqlite3 database.</a> Hidden in the HTML of this page are all of the queries I ran to produce the graphs. Feel free to get in touch if you find anything interesting, I‚Äôd be happy to update this page with, or linking to, your discoveries.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Due to the differing dates of continuing coverage, we unfortunately can‚Äôt look at this metric over the history of Canadian law.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>In a pre-print of this essay that contained only half of the dataset, 42 of the top 50 had Wikipedia articles. Of these cases, 31 were ‚Äúleading‚Äù or ‚Äúlandmark.‚Äù It‚Äôs not clear to me why this metric degraded when adding more data, except possibly that the inclusion of more cases has brought out connections that are harder for humans to keep track of. I‚Äôm very confident in the math here.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3" role="doc-endnote"><p>I‚Äôd like to have checked a few thousand, but this is a very manual process.<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4" role="doc-endnote"><p>‚ÄúThere are only two hard things in Computer Science: cache invalidation and naming things.‚Äù ‚ÄìPhil Karlton<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
</channel>
</rss>
