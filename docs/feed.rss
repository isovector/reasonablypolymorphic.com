<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
  <title>Reasonably Polymorphic</title>
  <link>https://reasonablypolymorphic.com</link>
  <atom:link href="https://reasonablypolymorphic.com/feed.rss" rel="self" type="application/rss+xml" />
  <description>Sandy Maguire's technical blog</description>
  <category>Programming</category>
  <copyright>2022 Sandy Maguire</copyright>
  <pubDate></pubDate>
  <language>en-us</language>
  <image>
      <url>https://reasonablypolymorphic.com/images/favicon.png</url>
    <title>Sandy Maguire</title>
    <link>https://reasonablypolymorphic.com</link>
  </image>
  <item>
      <title>FRP in Yampa: Part 4: Routing</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/yampa-routing/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/yampa-routing/index.html</guid>
      <pubDate>2023-12-26</pubDate>
      <content:encoded><![CDATA[
        <p>In the <a href="/blog/yampa-switching/">last post</a>, we investigated the <code>switch</code> combinator, and saw how it can give us the ability to work with ‚Äústate machine‚Äù-sorts of things in our functionally reactive programs.</p>
<p>Today we turn our attention towards game objects‚Äîthat is, independently operating entities inside of the game, capable of behaving on their own and communicating with one another. I originally learned of this technique from the paper <a href="https://www.antonycourtney.com/pubs/hw03.pdf">The Yampa Arcade</a>, but haven‚Äôt looked at it in a few years, so any shortcomings here are my own.</p>
<p>Nevertheless, the material presented here does in fact work‚ÄîI‚Äôve actually <a href="https://github.com/isovector/ld52/releases/tag/publish">shipped a game</a> using this exact technique!</p>
<h2 id="game-objects"><a href="#game-objects" class="header-link">Game Objects<span class="header-link-emoji">üîó</span></a></h2>
<p>Before we dive into the Yampa, it‚Äôs worth taking some time to think about what it is we‚Äôre actually trying to accomplish. There are a series of constraints necessary to get everything working, and we‚Äôll learn a lot about the problem domain by solving those constraints simultaneously.</p>
<p>The problem: we‚Äôd like several <code>Object</code>s running around, which we‚Äôd like to program independently, but which behave compositionally. There are going to be a lot of moving pieces here‚Äînot only in our game, but also in our solution‚Äîso let‚Äôs take a moment to define a type synonym for ourselves:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Object</span> <span class="ot">=</span> <span class="dt">SF</span> <span class="dt">ObjectInput</span> <span class="dt">ObjectOutput</span></span></code></pre></div>
<p>Of course, we haven‚Äôt yet defined <code>ObjectInput</code> or <code>ObjectOutput</code>, but that‚Äôs OK! They will be subject to a boatload of constraints, so we‚Äôll sort them out as we go. At the very least, we will need the ability for an <code>Object</code> to render itself, so we can add a <code>Render</code> field:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectOutput</span> <span class="ot">=</span> <span class="dt">ObjectOutput</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oo_render ::</span> <span class="dt">Render</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  , <span class="op">...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>We would like <code>Object</code>s to be able to interact with one another. The usual functional approach to this problem is to use message passing‚Äîthat is, <code>Object</code>s can send values of some message type to one another. Those messages could be things like ‚ÄúI shot you!‚Äù or ‚Äúteleport to me,‚Äù or any sort of crazy game-specific behavior you‚Äôd like.</p>
<p>In order to do this, we‚Äôll need some sort of <code>Name</code> for each <code>Object</code>. The exact structure of this type depends on your game. For the purposes of this post we‚Äôll leave the thing abstract:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>We‚Äôll also need a <code>Message</code> type, which again we leave abstract:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Message</span> <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>Sending messages is clearly an <em>output</em> of the <code>Object</code>, so we will add them to <code>ObjectOutput</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectOutput</span> <span class="ot">=</span> <span class="dt">ObjectOutput</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oo_render ::</span> <span class="dt">Render</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_outbox ::</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  , <span class="op">...</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>There are actions we‚Äôd like to perform in the world which are not messages we want to send to anyone; particularly things like ‚Äúkill my <code>Object</code>‚Äù or ‚Äústart a new <code>Object</code>.‚Äù These two are particularly important, but you could imagine updating global game state or something else here.</p>
<pre class="haskel"><code>data Command
  = Die
  | Spawn Name ObjectState Object
  | ...</code></pre>
<p>Commands are also outputs:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectOutput</span> <span class="ot">=</span> <span class="dt">ObjectOutput</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oo_render   ::</span> <span class="dt">Render</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_outbox   ::</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_commands ::</span> [<span class="dt">Command</span>]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  , <span class="op">...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Finally, it‚Äôs often helpful to have some common pieces of state that belong to all <code>Object</code>s‚Äîthings like their current position, and hot boxes, and anything else that might make sense to track in your game. We‚Äôll leave this abstract:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjecState</span> <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectOutput</span> <span class="ot">=</span> <span class="dt">ObjectOutput</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oo_render   ::</span> <span class="dt">Render</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_outbox   ::</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_commands ::</span> [<span class="dt">Command</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oo_state    ::</span> <span class="dt">ObjectState</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Let‚Äôs turn our attention now to the input side. It‚Äôs pretty clear we‚Äôre going to want incoming messages, and our current state:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectInput</span> <span class="ot">=</span> <span class="dt">ObjectInput</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oi_inbox ::</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oi_state ::</span> <span class="dt">ObjectState</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>What‚Äôs more interesting, however, than knowing our own state is knowing everyone‚Äôs state. Once we have that, we can re-derive <code>oi_state</code> if we know our own <code>Name</code>. Thus, instead:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectInput</span> <span class="ot">=</span> <span class="dt">ObjectInput</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> oi_inbox    ::</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oi_me       ::</span> <span class="dt">Name</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> oi_everyone ::</span> <span class="dt">Map</span> <span class="dt">Name</span> <span class="dt">ObjectState</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">oi_state ::</span> <span class="dt">ObjectInput</span> <span class="ot">-&gt;</span> <span class="dt">ObjectState</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>oi_state oi</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> fromMaybe (<span class="fu">error</span> <span class="st">&quot;impossible!&quot;</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> Data.Map.lookup (oi_me oi)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">$</span> oi_everyone oi</span></code></pre></div>
<h2 id="parallel-switching"><a href="#parallel-switching" class="header-link">Parallel Switching<span class="header-link-emoji">üîó</span></a></h2>
<p>Armed with our input and output types, we need now figure out how to implement any of this. The relevant combinator is Yampa‚Äôs <code>pSwitch</code>, with the ridiculous type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pSwitch</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">Functor</span> col</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="kw">forall</span> sf<span class="op">.</span> gi <span class="ot">-&gt;</span> col sf <span class="ot">-&gt;</span> col (li, sf))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> col (<span class="dt">SF</span> li o)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> (gi, col o) (<span class="dt">Event</span> e)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (col (<span class="dt">SF</span> li o) <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (col o))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (col o)</span></code></pre></div>
<p>Yes, there are five type variables here (six, if you include the rank-2 type.) In order, they are:</p>
<ol type="1">
<li><code>col</code>: the data structure we‚Äôd like to store everything in</li>
<li><code>gi</code>: the <em>global</em> input, fed to the eventual signal</li>
<li><code>li</code>: the <em>local</em> input, fed to each object</li>
<li><code>o</code>: the output of each object signal</li>
<li><code>e</code>: the type we will use to articulate desired changes to the world</li>
</ol>
<p>Big scary types like these are an excellent opportunity to turn on <code>-XTypeApplications</code>, and explicitly fill out the type parameters. From our work earlier, we know the types of <code>li</code> and <code>o</code>‚Äîthey ought to be <code>ObjectInput</code> and <code>ObjectOutput</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>pSwitch <span class="op">@</span>_</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span>_</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span><span class="dt">ObjectInput</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span><span class="dt">ObjectOutput</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span>_</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">Functor</span> col</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="kw">forall</span> sf<span class="op">.</span> gi <span class="ot">-&gt;</span> col sf <span class="ot">-&gt;</span> col (<span class="dt">ObjectInput</span>, sf))</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> col (<span class="dt">SF</span> <span class="dt">ObjectInput</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> (gi, col <span class="dt">ObjectOutput</span>) (<span class="dt">Event</span> e)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (col (<span class="dt">SF</span> <span class="dt">ObjectInput</span> <span class="dt">ObjectOutput</span>) <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (col <span class="dt">ObjectOutput</span>))</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (col <span class="dt">ObjectOutput</span>)</span></code></pre></div>
<p>It‚Äôs a little clearer what‚Äôs going on here. We can split it up by its four parameters:</p>
<ol type="1">
<li>The first (value) parameter is this rank-2 function which is responsible for splitting the global input into a local input for each object.</li>
<li>The second parameter is the collection of starting objects.</li>
<li>The third parameter extracts the desired changes from the collection of outputs</li>
<li>The final parameter applies the desired changes, resulting in a new signal of collections.</li>
</ol>
<p>We are left with a few decisions, the big ones are: what should <code>col</code> be, and what should <code>e</code> be? My answer for the first is:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ObjectMap</span> a <span class="ot">=</span> <span class="dt">ObjectMap</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> om_objects  ::</span> <span class="dt">Map</span> <span class="dt">Name</span> (<span class="dt">ObjectState</span>, a)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> om_messages ::</span> <span class="dt">MonoidalMap</span> <span class="dt">Name</span> [(<span class="dt">Name</span>, <span class="dt">Message</span>)]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock <span class="dt">Functor</span></span></code></pre></div>
<p>which not only conveniently associates names with their corresponding objects and states, but also keeps track of the messages which haven‚Äôt yet been delivered. We‚Äôll investigate this further momentarily.</p>
<p>For maximum switching power, we can therefore make our event type be <code>ObjectMap Object -&gt; ObjectMap Object</code>. Filling all the types in, we get:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>pSwitch <span class="op">@</span><span class="dt">ObjectMap</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span>_</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span><span class="dt">ObjectInput</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span><span class="dt">ObjectOutput</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">@</span>(<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="kw">forall</span> sf<span class="op">.</span> gi <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> sf <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> (<span class="dt">ObjectInput</span>, sf))</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> (gi, <span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Event</span> (<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> ( <span class="dt">ObjectMap</span> <span class="dt">Object</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (<span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>     )</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (<span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span></code></pre></div>
<p>which is something that feels almost reasonable. Let‚Äôs write a function that calls <code>pSwitch</code> at these types. Thankfully, we can immediately fill in two of these parameters:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>router</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (<span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>router objs <span class="ot">=</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  pSwitch <span class="op">@</span><span class="dt">ObjectMap</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>_</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectInput</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectOutput</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>(<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    _</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    objs</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    _</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    (\om f <span class="ot">-&gt;</span> router&#39; <span class="op">$</span> (f om) { om_messages <span class="ot">=</span> <span class="fu">mempty</span> })</span></code></pre></div>
<p>We are left with two holes: one which constructs <code>ObjectInput</code>s, the other which destructs <code>ObjectOutput</code>s. The first is simple enough:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">routeInput ::</span> gi <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> sf <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> (<span class="dt">ObjectInput</span>, sf)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>routeInput gi om<span class="op">@</span>(<span class="dt">ObjectMap</span> objs msgs) <span class="ot">=</span> om</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  { om_objects <span class="ot">=</span> <span class="fu">flip</span> Data.Map.mapWithKey objs <span class="op">$</span> \name (_, sf) <span class="ot">-&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>      (, sf) <span class="op">$</span> <span class="dt">ObjectInput</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        { oi_inbox    <span class="ot">=</span> fromMaybe <span class="fu">mempty</span> <span class="op">$</span> Data.MonoidalMap.lookup name msgs</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        , oi_me       <span class="ot">=</span> name</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        , oi_everyone <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">fst</span> objs</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Writing <code>decodeOutput</code> is a little more work‚Äîwe need to accumulate every change that <code>ObjectOutput</code> might want to enact:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeOutput ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ObjectOutput</span> <span class="ot">-&gt;</span> <span class="dt">Endo</span> (<span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>decodeOutput from (<span class="dt">ObjectOutput</span> _ msgs cmds _) <span class="ot">=</span> <span class="fu">mconcat</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  [ <span class="fu">flip</span> <span class="fu">foldMap</span> msgs <span class="op">$</span> <span class="fu">uncurry</span> <span class="op">$</span> send from</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  , <span class="fu">flip</span> <span class="fu">foldMap</span> cmds <span class="op">$</span> decodeCommand from</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">send ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Message</span> <span class="ot">-&gt;</span> <span class="dt">Endo</span> (<span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>send from to msg</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">$</span> <span class="op">#</span>om_messages <span class="op">&lt;&gt;~</span> Data.MonoidalMap.singleton to [(from, msg)]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeCommand ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> <span class="dt">Endo</span> (<span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>decodeCommand _ (<span class="dt">Spawn</span> name st obj)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">$</span> <span class="op">#</span>om_objects <span class="op">.</span> at name <span class="op">?~</span> (st, obj)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>decodeCommand who <span class="dt">Die</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Endo</span> <span class="op">$</span> <span class="op">#</span>om_objects <span class="op">%~</span> Data.Map.delete who</span></code></pre></div>
<p>There‚Äôs quite a lot going on here. Rather than dealing with <code>ObjectMap Object -&gt; ObjectMap Object</code> directly, we instead work with <code>Endo (ObjectMap Object)</code> which gives us a nice monoid for combining endomorphisms. Then by exploiting <code>mconcat</code> and <code>foldMap</code>, we can split up all of the work of building the total transformation into pieces. Then <code>send</code> handles sending a message from one object to another, while also <code>decodeCommand</code> transforms each <code>Command</code> into an endomap.</p>
<p>We can tie everything together:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>router</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (<span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>router objs <span class="ot">=</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  pSwitch <span class="op">@</span><span class="dt">ObjectMap</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>_</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectInput</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectOutput</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>(<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    routeInput</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    objs</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    (arr <span class="op">$</span> <span class="dt">Event</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> appEndo</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> <span class="fu">foldMap</span> (<span class="fu">uncurry</span> decodeOutput)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> Data.Map.assocs</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> om_objects</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> <span class="fu">snd</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>         )</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    (\om f <span class="ot">-&gt;</span> router&#39; <span class="op">$</span> (f om) { om_messages <span class="ot">=</span> <span class="fu">mempty</span> })</span></code></pre></div>
<p>Notice that we‚Äôve again done the monoid trick to run <code>decodeOutput</code> on every output in the <code>ObjectMap</code>. If you‚Äôre not already on the monoid bandwagon, hopefully this point will help to change your mind about that!</p>
<p>So our router is finally done! Except not quite. For some reason I don‚Äôt understand, <code>pSwitch</code> is capable of <em>immediately</em> switching if the <code>Event</code> you generate for <code>decodeOutput</code> immediately fires. This makes sense, but means Yampa will happily get itself into an infinite loop. The solution is to delay the event by an infinitesimal amount:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>router</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">SF</span> gi (<span class="dt">ObjectMap</span> <span class="dt">ObjectOutput</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>router objs <span class="ot">=</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  pSwitch <span class="op">@</span><span class="dt">ObjectMap</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>_</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectInput</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span><span class="dt">ObjectOutput</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">@</span>(<span class="dt">ObjectMap</span> <span class="dt">Object</span> <span class="ot">-&gt;</span> <span class="dt">ObjectMap</span> <span class="dt">Object</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    routeInput</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    objs</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    ((arr <span class="op">$</span> <span class="dt">Event</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> appEndo</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> <span class="fu">foldMap</span> (<span class="fu">uncurry</span> decodeOutput)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> Data.Map.assocs</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> om_objects</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> <span class="fu">snd</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>         ) <span class="op">&gt;&gt;&gt;</span> notYet)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    (\om f <span class="ot">-&gt;</span> router&#39; <span class="op">$</span> (f om) { om_messages <span class="ot">=</span> <span class="fu">mempty</span> })</span></code></pre></div>
<p>There‚Äôs probably a more elegant solution to this problem, and if you know it, please do get in touch!</p>
<h2 id="wrapping-up"><a href="#wrapping-up" class="header-link">Wrapping Up<span class="header-link-emoji">üîó</span></a></h2>
<p>Today we saw how to use the <code>pSwitch</code> combinator in order to build a router capable of managing independent objects, implementing message passing between them in the process.</p>
<p>You should now have enough knowledge of Yampa to get real tasks done, although if I‚Äôm feeling inspired, I might write one more post on integrating a Yampa stream into your <code>main</code> function, and doing all the annoying boilerplate like setting up a game window. Maybe! Watch this space for updates!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>FRP in Yampa: Part 3: Switching</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/yampa-switching/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/yampa-switching/index.html</guid>
      <pubDate>2023-12-24</pubDate>
      <content:encoded><![CDATA[
        <p><a href="https://reasonablypolymorphic.com/blog/arrowized-frp">Yesterday</a> we looked at arrowized FRP in Yampa, and saw how it the <code>proc</code> notation is to arrows as <code>do</code> is for monads. While these syntaxes don‚Äôt give you any new power, notation nevertheless matters and helps us better structure our programs.</p>
<p>So far all of our programs have consisted of a single signal function. We‚Äôve sketched out how to build a lobotomized version of the Snake game, but real games have things like title screens and option menus as well as the actual gameplay component. If you were determined, you could probably figure out how to build these missing components with what we‚Äôve seen so far, but it wouldn‚Äôt be fun.</p>
<p>Instead, we turn our attention to switches.</p>
<h2 id="switching"><a href="#switching" class="header-link">Switching<span class="header-link-emoji">üîó</span></a></h2>
<p>Yampa‚Äôs <code>SF</code> type isn‚Äôt monadic, but the <code>switch</code> combinator gets you surprisingly close:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">switch ::</span> <span class="dt">SF</span> i (o, <span class="dt">Event</span> e) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">SF</span> i o) <span class="ot">-&gt;</span> <span class="dt">SF</span> i o</span></code></pre></div>
<p>The idea is that you run the first <code>SF</code> until the outputted <code>Event</code> produces an event, at which point you take its value and use it to generate a new <code>SF</code>, which you subsequently run.</p>
<p>As an example, let‚Äôs build a little coproduct type for the choices we might make on the menu screen:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MenuOption</span> <span class="ot">=</span> <span class="dt">Start</span> <span class="op">|</span> <span class="dt">Options</span></span></code></pre></div>
<p>Our menu screen is now an <code>SF</code> that outputs the things we‚Äôd like to draw on the screen (a <code>Render</code>), as well as an <code>Event MenuOption</code> corresponding to an event for when we actually make a selection:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">menuScreen ::</span> <span class="dt">SF</span> () (<span class="dt">Render</span>, <span class="dt">Event</span> <span class="dt">MenuOption</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>menuScreen <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>As before, we have our main Snake game, and now a new screen for the options:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mainGame ::</span> <span class="dt">SF</span> () <span class="dt">Render</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>mainGame <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">optionsScreen ::</span> <span class="dt">SF</span> () <span class="dt">Render</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>optionsScreen <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>We can tie it all together by <code>switch</code>ing from <code>menuScreen</code> to the appropriate next <code>SF</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program ::</span> <span class="dt">SF</span> () <span class="dt">Render</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>program <span class="ot">=</span> switch menuScreen <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Start</span>   <span class="ot">-&gt;</span> mainGame</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Options</span> <span class="ot">-&gt;</span> optionsScreen</span></code></pre></div>
<p>Again, you can kind of squint to get the picture, but things get a little gnarlier when you actually get into the gritty details here. For example, in a real game, you might go back to the menu screen after the game ends, and you‚Äôd <em>certainly</em> go back after setting up the appropriate options. If we wanted to encode those rules, we‚Äôd need to fiddle with some types.</p>
<p>Let‚Äôs add <code>Event ()</code>s to <code>mainGame</code> and <code>optionScreen</code>, corresponding to when the player has died and when the options have been set, respectively:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mainGame ::</span> <span class="dt">SF</span> () (<span class="dt">Render</span>, <span class="dt">Event</span> ())</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">optionsScreen ::</span> <span class="dt">SF</span> () (<span class="dt">Render</span>, <span class="dt">Event</span> ())</span></code></pre></div>
<p>With a creative amount of <code>switch</code>ing, it‚Äôs possible to encode everything we‚Äôd like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">program ::</span> <span class="dt">SF</span> () <span class="dt">Render</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>program <span class="ot">=</span> switch menuScreen <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Start</span>   <span class="ot">-&gt;</span> switch mainGame      <span class="op">$</span> <span class="fu">const</span> program</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Options</span> <span class="ot">-&gt;</span> switch optionsScreen <span class="op">$</span> <span class="fu">const</span> program</span></code></pre></div>
<p>Of course, we can use <code>switch</code> for much more than just modeling state machines‚Äîthe following example uses it as a combinator to do something for a while:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">timed ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">SF</span> i o <span class="ot">-&gt;</span> <span class="dt">SF</span> i o</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>timed dur s1 s2 <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  switch</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    (proc i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      o  <span class="ot">&lt;-</span> s1 <span class="op">-&lt;</span> i</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      ev <span class="ot">&lt;-</span> after dur () <span class="op">-&lt;</span> ()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      returnA <span class="op">-&lt;</span> (o, ev)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">$</span> <span class="fu">const</span> s2</span></code></pre></div>
<p>or, more interestingly, a combinator which interpolates a function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">interpolate ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> (<span class="dt">Time</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">SF</span> (i, a) o <span class="ot">-&gt;</span> <span class="dt">SF</span> i o <span class="ot">-&gt;</span> <span class="dt">SF</span> i o</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>interpolate dur f interp final <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  switch</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    (proc i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>      t  <span class="ot">&lt;-</span> time <span class="op">-&lt;</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>      o  <span class="ot">&lt;-</span> s1 <span class="op">-&lt;</span> (i, t <span class="op">/</span> dur)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>      ev <span class="ot">&lt;-</span> after dur () <span class="op">-&lt;</span> ()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>      returnA <span class="op">-&lt;</span> (o, ev)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">$</span> <span class="fu">const</span> final</span></code></pre></div>
<p>The parameter <code>f</code> here will be called with values of time from <code>0</code> to <code>1</code>, linearly increasing until <code>dur</code>. This is the sort of combinator that is extremely useful for animating objects, where you‚Äôd like to tween from a known starting point to a know ending point.</p>
<h2 id="making-a-real-monad"><a href="#making-a-real-monad" class="header-link">Making a Real Monad<span class="header-link-emoji">üîó</span></a></h2>
<p>Most of what I know about Yampa I learned by reverse-engineering <a href="https://das.li/index.html">Alex Stuart</a>‚Äôs excellent game <a href="https://linearity.itch.io/peoplemon">Peoplemon</a> (<a href="https://hub.darcs.net/linearity/pplmonad">source here</a>). As you might expect, it‚Äôs a fun parody on Pokemon.</p>
<p>One night while desperately trying to work out how he programmed up the menu-based battle system in Peoplemon, I came across the mysteriously named <a href="https://hub.darcs.net/linearity/pplmonad/browse/src/Lightarrow.hs">Lightarrow.hs</a>, which makes the following improvement over the <code>switch</code>ing technique above.</p>
<p>He sticks the whole thing into the <code>Cont</code> monad:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span></code></pre></div>
<p>I think this is the first and only time I‚Äôve seen a use for <code>Cont</code> in the wild, that doesn‚Äôt stem <em>directly</em> from trying to CPS everything in order to make your program go faster from fusion. It‚Äôs so COOL to see a real world opportunity to throw <code>Cont</code> at a problem!</p>
<p>Anyway. This type is known as <code>Swont</code>, which I‚Äôve always assumed was something like ‚Äúsignal continuation‚Äù but your guess is as good as mine:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Swont</span> i o a <span class="ot">=</span> <span class="dt">Swont</span> {<span class="ot"> unSwont ::</span> <span class="dt">Cont</span> (<span class="dt">SF</span> i o) a }</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>)</span></code></pre></div>
<p>We can lift any <code>SF i (b, Event c)</code> into a <code>Swont</code> via <code>swont</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swont ::</span> <span class="dt">SF</span> i (o, <span class="dt">Event</span> e) <span class="ot">-&gt;</span> <span class="dt">Swont</span> i o e</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>swont <span class="ot">=</span> <span class="dt">Swont</span> <span class="op">.</span> cont <span class="op">.</span> switch</span></code></pre></div>
<p>and we can lower the whole thing again by way of <code>switchSwont</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">switchSwont ::</span> <span class="dt">Swont</span> i o e <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">SF</span> i o) <span class="ot">-&gt;</span> <span class="dt">SF</span> i o</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>switchSwont sw end <span class="ot">=</span> runCont (unSwont sw) end</span></code></pre></div>
<p>What‚Äôs really nice about <code>Swont</code> is that it is a genuine, bona-fide monad. This gives us a really lovely notation for programming sequential things like state machines or battle animations‚Äîstuff that consists of needing to switch between disparate things with discrete reasons to change.</p>
<p>We can use <code>Swont</code> to encode our above state machine in a much more familiar way:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foreverSwont ::</span> <span class="dt">Swont</span> i o e <span class="ot">-&gt;</span> <span class="dt">SF</span> i o</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>foreverSwont sw <span class="ot">=</span> switchSwont (forever sw) <span class="op">$</span> <span class="fu">error</span> <span class="st">&quot;impossible&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="ot">program ::</span> <span class="dt">SF</span> () <span class="dt">Render</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>program <span class="ot">=</span> foreverSwont <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  menuScreen <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Start</span>   <span class="ot">-&gt;</span> mainGame</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Options</span> <span class="ot">-&gt;</span> optionsScreen</span></code></pre></div>
<p>Not bad at all!</p>
<h2 id="wrapping-up"><a href="#wrapping-up" class="header-link">Wrapping Up<span class="header-link-emoji">üîó</span></a></h2>
<p>Today we looked at Yampa‚Äôs <code>switch</code> combinator, seen how it can be used to string disparate signals together, and seen how wrapping the whole thing in a continuation monad can make the whole thing tolerable to work with.</p>
<p>In tomorrow‚Äôs post, we‚Äôll look at writing object routers in Yampa‚Äîessentially, the main data structure for tracking lots of game objects, and allowing them to communicate with one another. Until then, I hope you‚Äôre having a very special Christmas weekend.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>FRP in Yampa: Part 2: Arrowized FRP</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/arrowized-frp/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/arrowized-frp/index.html</guid>
      <pubDate>2023-12-22</pubDate>
      <content:encoded><![CDATA[
        <p>In the <a href="https://reasonablypolymorphic.com/blog/yampa-frp/index.html">last part</a>, we got a feel for how FRP can help us with real-time programming tasks, especially when contrasted against implicit models of time. However, the interface we looked at yesterday left much to be desired‚Äîstringing together long signal functions felt clunky, and since <code>SF</code>s don‚Äôt form a monad, we couldn‚Äôt alleviate the problem with do-notation.</p>
<p>So today we‚Äôll look at one of Haskell‚Äôs lesser-known features‚Äîarrow notation‚Äîand learn how it can help structure bigger reactive programs.</p>
<h2 id="arrows"><a href="#arrows" class="header-link">Arrows<span class="header-link-emoji">üîó</span></a></h2>
<p>What an awful, overloaded word we‚Äôve found ourselves with. Being Haskell programmers, we‚Äôre all very familiar with the everyday function arrow <code>(-&gt;)</code>, which you should think of as a special case of a more general notion of <em>arrow.</em></p>
<p>Notice how both function arrows (<code>i -&gt; o</code>) and signal functions (<code>SF i o</code>) have two type parameters‚Äîone for the input side of things, and another for the output side. And indeed, we should think of these as <em>sides</em> of the computation, where we are transforming an <code>i</code> into an <code>o</code>.</p>
<p>For our purposes today, we‚Äôll want to be very precise when we differentiate between functions-as-data and functions-as-ways-of-building things. In order to do so, we will give give ourselves a little type synonym to help differentiate:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fn</span> i o <span class="ot">=</span> i <span class="ot">-&gt;</span> o</span></code></pre></div>
<p>And henceforth, we will use the <code>Fn</code> synonym to refer to functions we‚Äôre manipulating, reserving <code>(-&gt;)</code> to talk about combinators for <em>building</em> those functions.</p>
<p>For example, our favorite identity function is a <code>Fn</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">Fn</span> a a</span></code></pre></div>
<p>We usually give the constant function the type <code>a -&gt; b -&gt; a</code>, but my claim is that it ought to be:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Fn</span> b a</span></code></pre></div>
<p>The subtle thing I‚Äôm trying to point out is that there is a (conceptual) difference between the functions we want to operate on at runtime (called <code>Fn</code>s), and the <em>combinators</em> we use to build those functions (called <code>(-&gt;)</code>.)</p>
<p>Like I said, it‚Äôs a bit hard to point to in Haskell, because one of the great successes of functional programming has been to <em>blur</em> this distinction.</p>
<p>Anyway, let‚Äôs return to our discussion of arrows. Both functions and <code>SF</code>s admit a notion of composition, which allow us to line up the <em>output</em> of one arrow with the <em>input</em> of another, fusing the two into a single computation. The types they have are:</p>
<ul>
<li><code>(.)   :: Fn b c -&gt; Fn a b -&gt; Fn a c</code></li>
<li><code>(&lt;&lt;&lt;) :: SF b c -&gt; SF a b -&gt; SF a c</code></li>
</ul>
<p>Despite our intimate familiarity with functions, this pattern of types with both an input and an output is quite uncommon in Haskell. Due to the immense mindshare that the monad meme takes up, we usually think about computation in terms of monads, and it can be hard to remember that not all computation is monadic (nor applicative.)</p>
<p>Monadic values are of the shape <code>M o</code>, with only a single type parameter that corresponds (roughly) with the <em>output</em> of the computation. That is to say, all of the interesting computational structure of a monad exists only in its output, and <em>never in its input</em>‚Äîin fact, we can‚Äôt even <em>talk</em> about the input to a monad. What we do instead is cheat; we take the input side of the computation directly from the function arrow.</p>
<p>If we expand out the types of <code>(&lt;*&gt;)</code> and <code>flip (&gt;&gt;=)</code>, using our <code>Fn</code> notation from above, they get the types:</p>
<ul>
<li><code>(&lt;*&gt;)      :: M (Fn i o) -&gt; Fn (M i) (M o)</code></li>
<li><code>flip (&gt;&gt;=) :: Fn i (M o) -&gt; Fn (M i) (M o)</code></li>
</ul>
<p>which makes it much clearer that the relevant interactions here are some sort of distributivity of our monad over the regular, everyday function arrows. In other words, that monads are cheating by getting their ‚Äúinputs‚Äù from functions.</p>
<h2 id="what-the-hell"><a href="#what-the-hell" class="header-link">What the Hell?<span class="header-link-emoji">üîó</span></a></h2>
<p>Enough philosophy. What the hell <em>are</em> arrows? The example that really made it stick for me is in the domain of <em>digital circuits.</em> A digital circuit is some piece of silicon with wire glued to it, that moves electrons from one side to the other‚Äîwith the trick being that the eventual endpoint of the electrons depends on their original positions. With enough squinting, you can see the whole thing as a type <code>Circuit i o</code>, where <code>i</code> corresponds to which wires we chose to put a high voltage on, and <code>o</code> is which wires have a high voltage at the end of the computation. With a little more squinting, it‚Äôs not too hard to reconceptualize these wires as bits, which we can again reconceptualize as encodings of particular types.</p>
<p>The point I was trying to make earlier about the distinction between <code>(-&gt;)</code> and <code>Fn</code> makes much more sense in this context; just replace <code>Fn</code> with <code>Circuit</code>. Here it makes much more sense to think about the identity circuit:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">Circuit</span> a a</span></code></pre></div>
<p>which is probably just a bundle of wires, and the constant circuit:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">const</span><span class="ot"> ::</span> o <span class="ot">-&gt;</span> <span class="dt">Circuit</span> i o</span></code></pre></div>
<p>which lets you pick some particular <code>o</code> value (at design time), and then make a circuit that is disconnected from its input wires and merely holds the chosen <code>o</code> value over its output wires.</p>
<p>Anyway. The important thing about digital circuits is that you have infinite flexibility when you are designing them, but once they‚Äôre manufactured, they stay that way. If you chose to wire the frobulator directly to the zanzigurgulator, those two components are, and always will be, wired together. In perpetuity.</p>
<p>Of course, you can do some amount of dynamic reconfiguring of a circuit, by conditionally choosing which wires you consider to be ‚Äúrelevant‚Äù right now, but those wires are going to have signals on them whether you‚Äôre interested in them or not.</p>
<p>In other words, there is a strict phase distinction between the components on the board and the data they carry at runtime.</p>
<p>And this is what arrows are all about.</p>
<p>Arrows are about computations whose internal structure must remain constant. You‚Äôve got all the flexibility in the world when you‚Äôre designing them, but you can‚Äôt reconfigure anything at runtime.</p>
<h2 id="arrow-notation"><a href="#arrow-notation" class="header-link">Arrow Notation<span class="header-link-emoji">üîó</span></a></h2>
<p>Yesterday‚Äôs post ended with the following code, written directly with the arrow combinators.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">onPress ::</span> (<span class="dt">Controller</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SF</span> () (<span class="dt">Event</span> a)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>onPress field a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> (<span class="fu">const</span> a)) <span class="op">$</span> <span class="fu">fmap</span> field controller <span class="op">&gt;&gt;&gt;</span> edge</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">arrowEvents ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">SF</span> () (<span class="dt">Event</span> (<span class="dt">V2</span> a))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>arrowEvents <span class="ot">=</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  (\u d l r <span class="ot">-&gt;</span> asum [u, d, l r])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> onPress ctrl_up    (<span class="dt">V2</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_down  (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_left  (<span class="dt">V2</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">0</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_right (<span class="dt">V2</span> <span class="dv">1</span>    <span class="dv">0</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="ot">snakeDirection ::</span> <span class="dt">SF</span> () (<span class="dt">V2</span> <span class="dt">Float</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>snakeDirection <span class="ot">=</span> arrowEvents <span class="op">&gt;&gt;&gt;</span> hold (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="ot">snakePosition ::</span> <span class="dt">SF</span> () (<span class="dt">V2</span> <span class="dt">Float</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>snakePosition <span class="ot">=</span> snakeDirection <span class="op">&gt;&gt;&gt;</span> integral</span></code></pre></div>
<p>While technically you can get anything done in this style, it‚Äôs a lot like writing all of your monadic code directly in terms of <code>(&gt;&gt;=)</code>. Possible certainly, but indisputably clunky.</p>
<p>Instead, let‚Äôs rewrite it with arrow notation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Arrows #-}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">snakePosition ::</span> <span class="dt">SF</span> () (<span class="dt">V2</span> <span class="dt">Float</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>snakePosition <span class="ot">=</span> proc i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  u <span class="ot">&lt;-</span> onPress ctrl_up    <span class="op">$</span> <span class="dt">V2</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">-&lt;</span> i</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  d <span class="ot">&lt;-</span> onPress ctrl_down  <span class="op">$</span> <span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span>    <span class="op">-&lt;</span> i</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  l <span class="ot">&lt;-</span> onPress ctrl_left  <span class="op">$</span> <span class="dt">V2</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">0</span> <span class="op">-&lt;</span> i</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> onPress ctrl_right <span class="op">$</span> <span class="dt">V2</span> <span class="dv">1</span>    <span class="dv">0</span> <span class="op">-&lt;</span> i</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  dir <span class="ot">&lt;-</span> hold <span class="op">$</span> <span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span> <span class="op">-&lt;</span> asum [u, d, l r]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  pos <span class="ot">&lt;-</span> integral <span class="op">-&lt;</span> dir</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> pos</span></code></pre></div>
<p>Much tidier, no? Reading arrow notation takes a little getting used to, but there are really only two things you need to understand. The first is that <code>proc i -&gt; do</code> introduces an arrow computation, much like the <code>do</code> keyword introduces a monadic computation. Here, the input to the entire arrow is bound to <code>i</code>, but you can put any legal Haskell pattern you want there.</p>
<p>The other thing to know about arrow notation is that <code>&lt;-</code> and <code>-&lt;</code> are two halves of the same syntax. The notation here is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> arrow <span class="op">-&lt;</span> input</span></code></pre></div>
<p>where <code>arrow</code> is of type <code>SF i o</code>, and <code>input</code> is any normal everyday Haskell value of type <code>i</code>. At the end of the day, you bind the result to <code>output</code>, whose type is obviously <code>o</code>.</p>
<p>The mnemonic for this whole thing is that you‚Äôre shooting an arrow (of bow and arrow fame) from the input to the output. And the name of the arrow is written on the shaft. It makes more sense if you play around with the whitespace:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>  output   <span class="ot">&lt;-</span>arrow<span class="op">-&lt;</span>   input</span></code></pre></div>
<p>More importantly, the name of that arrow can be any valid Haskell expression, including one with infix operators. Thus, we should parse:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  u <span class="ot">&lt;-</span> onPress ctrl_up <span class="op">$</span> <span class="dt">V2</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">-&lt;</span> i</span></code></pre></div>
<p>as</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  u <span class="ot">&lt;-</span> (onPress ctrl_up <span class="op">$</span> <span class="dt">V2</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>)) <span class="op">-&lt;</span> i</span></code></pre></div>
<p>What‚Äôs likely to bite you as you get familiar with arrow notation is that the computations (the bits between <code>&lt;-</code> and <code>-&lt;</code>) exist in a completely different <em>phase</em>/<em>namespace</em> than the inputs and outputs. That means the following program is illegal:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  proc (i, j) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> blah  <span class="op">-&lt;</span> i</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> bar x <span class="op">-&lt;</span> j</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>because <code>x</code> simply <em>isn‚Äôt in scope</em> in the expression <code>bar x</code>. It‚Äôs the equivalent of designing a circuit board with <code>n</code> capacitors on it, where <code>n</code> will be determined by an input voltage supplied by the end-user. Completely nonsensical!</p>
<h2 id="wrapping-up"><a href="#wrapping-up" class="header-link">Wrapping Up<span class="header-link-emoji">üîó</span></a></h2>
<p>That‚Äôs all for today, folks. The day caught me by surprise, so we‚Äôll be back tomorrow to talk about building state machines in Yampa‚Äîsomething extremely important for making real video games.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>FRP in Yampa: Part 1</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/yampa-frp/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/yampa-frp/index.html</guid>
      <pubDate>2023-12-21</pubDate>
      <content:encoded><![CDATA[
        <p>I‚Äôve been writing some Haskell lately, for the first time in a year, and it‚Äôs a total blast! In particular, school is out for the holidays, so I had some spare time, and thought I‚Äôd waste it by making a video game. In Haskell.</p>
<p>It‚Äôs always more fun to make video games with other people, but the few people I pitched it to all had the same response‚Äî‚ÄúI don‚Äôt know how to do that.‚Äù So it seemed like a good opportunity to dust off the old blog and write about how to make a video game in Haskell, using arrowized FRP.</p>
<p>What the hell does that mean? Get ready to FIND OUT!</p>
<h2 id="frp"><a href="#frp" class="header-link">FRP?<span class="header-link-emoji">üîó</span></a></h2>
<p>FRP is short for <em>functional reactive programming,</em> <a href="http://conal.net/papers/frp.html">originally invented by Conal Elliott</a>. The library we‚Äôll be using today is called <a href="https://hackage.haskell.org/package/Yampa">Yampa</a>, which is certainly inspired by Elliott‚Äôs work, but my guess is it‚Äôs insufficiently true to the core idea for him to be excited about it.</p>
<p>Nevertheless, even an imperfect implementation of the idea is still orders of magnitude for making real-time applications than doing everything by hand. And to this extent, Yampa is an excellent library.</p>
<p>So what exactly is FRP? The core idea is that we want to talk about functions that are continuous in time, which give rise to extremely useful combinators-over-time. Real-time programs written as FRP are much easier to reason about, and significantly more expressive than you‚Äôd manage otherwise.</p>
<h2 id="a-point-of-contrast"><a href="#a-point-of-contrast" class="header-link">A Point of Contrast<span class="header-link-emoji">üîó</span></a></h2>
<p>It‚Äôs informative to compare what writing a video game looks like under an imperative style. The idea is that you have your <em>game loop</em> (a fancy name for ‚Äúinfinite loop‚Äù) running:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  setup<span class="op">();</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>true<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> delta_time <span class="op">=</span> waitForNextFrame<span class="op">();</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    updateGame<span class="op">(</span>delta_time<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    renderFrame<span class="op">();</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and this is kind of fine and manages to get the job done. But it‚Äôs inelegant for a few reasons. The biggest problem is that we are not actually modeling time here; we‚Äôre just running the game discretely, and time happens as a side effect of things changing. There‚Äôs this <code>delta_time</code> variable which counts how long it‚Äôs been since you last updated the game, which is to say it corresponds to ‚Äúhow much work you need to do <em>this</em> frame.‚Äù</p>
<p>What goes wrong is when <code>updateGame</code> or <code>renderFrame</code> takes too long to run; in that case, you might get spikes in how long it‚Äôs been since you last updated. Procedurally-written games compensate by interpolating everything a little further on the next frame, which gives the player the perception that they‚Äôre actually experiencing time.</p>
<p>But things can break down. If your last frame took too long, you need to simulate physics a little more this frame. In practice this usually means that you integrate your velocity a little more than usual‚Äîwhich really means your positions will teleport a little further than usual. This is a common bug in games, where it‚Äôs often easy to clip through obstacles when the frame-rate is too low.</p>
<iframe width="600" height="451" src="https://www.youtube.com/embed/7-E5QFtCbtI" title="Lag Through Vertical Walls" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
<p>The other problem with modeling your time only incidentally is that it makes it really annoying to actually do anything. For example, when you read from the controller you will only get whether the buttons are down or up, but you won‚Äôt get whether the button was <em>just pressed this frame.</em> If you want to know that you‚Äôll have to compute it yourself:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> last_a_button <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> updateGame<span class="op">(</span><span class="dt">float</span> delta_time<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  controller ctrls <span class="op">=</span> getControllerState<span class="op">();</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>ctrls<span class="op">.</span>a_button <span class="op">&amp;&amp;</span> <span class="op">!</span>last_a_button<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// handle a press</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  last_a_button <span class="op">=</span> ctrls<span class="op">.</span>a_button<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It‚Äôs tedious, but it gets the job done. Another common pain point is when you want to do something five seconds in the future:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> timer<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> updateGame<span class="op">(</span><span class="dt">float</span> delta_time<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  timer <span class="op">-=</span> delta_time<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>getWantsToStartTimer<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    timer <span class="op">=</span> <span class="fl">5.0</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>timer <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// handle timer finishing</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Again, nothing you can‚Äôt tackle, but in aggregate, this all becomes very weighty. Not being able to model time explicitly is a real pain, and everywhere you go you need to simulate it by diddling state changes.</p>
<h2 id="signal-functions"><a href="#signal-functions" class="header-link">Signal Functions<span class="header-link-emoji">üîó</span></a></h2>
<p>If you‚Äôve ever written a video game, it probably looked a lot like the examples from the previous section. That‚Äôs the sort of thing we‚Äôd like to abstract over, and work at a much higher level of detail than.</p>
<p>Here comes FRP to the rescue.</p>
<p>The core building block in Yampa is the ‚Äúsignal function‚Äù, written as <code>SF i o</code>. You can think of this as a transformer of signals of <code>i</code> into signals of <code>o</code>, where a signal is a function <code>Time -&gt; a</code>. Unwrapping all of this, an <code>SF i o</code> is a function <code>(Time -&gt; i) -&gt; (Time -&gt; o)</code>.</p>
<p>That‚Äôs everything you need to know about what <code>SF</code>s <em>are</em>. I don‚Äôt know how they‚Äôre implemented, and I don‚Äôt need to, because the abstraction doesn‚Äôt leak. Being a haskell programmer, you‚Äôre probably looking at <code>SF i o</code> and thinking ‚Äúthat thing is clearly a <code>Functor</code>/<code>Applicative</code>/<code>Monad</code>.‚Äù Two out of three‚Äîit‚Äôs a functor and an applicative, but <em>not</em> a monad. We‚Äôll come back to this momentarily.</p>
<p>The trick to working in FRP is to think of continuous streams of values over time. Thus, we can think about the player‚Äôs controller as an <code>SF</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">controller ::</span> <span class="dt">SF</span> () <span class="dt">Controller</span></span></code></pre></div>
<p>which is to say, a continuous stream of <code>Controller</code> values. By marking the input side of the <code>SF</code> as a unit, it means we don‚Äôt need to provide anything in order to get this value, which makes sense since the controller state is obviously at the very periphery of our program.</p>
<p>Since <code>SF</code> is a functor, we can get the state of the A button by fmapping it:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">aState ::</span> <span class="dt">SF</span> () <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>aState <span class="ot">=</span> <span class="fu">fmap</span> a_button controller</span></code></pre></div>
<p>which isn‚Äôt very surprising. But what‚Äôs more interesting are the SF-operating primitives that Yampa gives us. For example, there‚Äôs <code>delay</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">delay ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SF</span> a a</span></code></pre></div>
<p>which delays a signal by the given time, using the <code>a</code> parameter as the value for the initial value of the stream. Thus, we can get the value of the A button two seconds ago via:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">aStateTwoSecondsAgo ::</span> <span class="dt">SF</span> () <span class="dt">Bool</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>aStateTwoSecondsAgo <span class="ot">=</span> aState <span class="op">&gt;&gt;&gt;</span> delay <span class="dv">2</span> <span class="dt">False</span></span></code></pre></div>
<p>where <code>(&gt;&gt;&gt;) :: SF a b -&gt; SF b c -&gt; SF a c</code> is composition of <code>SF</code>s, analogous to function composition.</p>
<p>Already we can see the benefit of this approach. While it‚Äôs not clear exactly <em>why</em> we might want to look at the state of the controller two seconds ago, it‚Äôs also non-obvious how you‚Äôd go about implementing such a thing procedurally with a game loop.</p>
<p>One last signal function we might be interested for the time being is <code>integral</code>, which allows us to compute the integral of a stream:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">integral ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">SF</span> a a</span></code></pre></div>
<h2 id="events"><a href="#events" class="header-link">Events<span class="header-link-emoji">üîó</span></a></h2>
<p><code>SF</code>s are transformers of continuous signals, but often we want to talk about discrete moments in time. For this, we‚Äôve got the <code>Event</code> type, which is isomorphic to <code>Maybe</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Event</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NoEvent</span></span></code></pre></div>
<p>The interpretation you should have for an <code>Event</code> is that it‚Äôs a discrete piece of data arriving at a specific moment in time. In our earlier discussion of things you want to do in games, we‚Äôve already seen two examples of events: when a timer expires, and when the player <em>presses</em> the A button. Under Yampa, the first is particularly easy to code up, by way of the <code>after</code> combinator:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">after ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">SF</span> a (<span class="dt">Event</span> b)</span></code></pre></div>
<p>If we want to trigger a timer after 5 seconds, it‚Äôs just <code>after 5 () :: SF a (Event ())</code>, and we can listen to the output of this stream for an <code>Event ()</code> value in order to know when the timer has elapsed.</p>
<p>Similarly, when we‚Äôre interested in the player pressing a button, what we‚Äôre really interested is in the <em>edges</em> of their button signal. We can get this functionality by way of the <code>edge</code> signal function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">edge ::</span> <span class="dt">SF</span> <span class="dt">Bool</span> (<span class="dt">Event</span> ())</span></code></pre></div>
<p>which generates an event whenever the input boolean goes from false to true.</p>
<p>Of course, just being able to generate events isn‚Äôt very useful if we don‚Äôt have any means of subsequently eliminating them. A simple means of eliminating events is via <code>hold</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">SF</span> (<span class="dt">Event</span> a) a</span></code></pre></div>
<p>The <code>hold</code> function takes a stream of events, and holds onto the most recent value it received.</p>
<h2 id="making-a-game-of-snake"><a href="#making-a-game-of-snake" class="header-link">Making a Game of Snake<span class="header-link-emoji">üîó</span></a></h2>
<p>We‚Äôve already seen enough of FRP in order to make most of the old classic, Snake. In Snake, you are a snake who slithers around in a square, with a constant velocity, continuing in the direction you‚Äôre going until the player asks you to turn.</p>
<p>Begin with a <code>Controller</code>, and an <code>SF</code> to read it:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Controller</span> <span class="ot">=</span> <span class="dt">Controller</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> ctrl_up    ::</span> <span class="dt">Bool</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ctrl_down  ::</span> <span class="dt">Bool</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ctrl_left  ::</span> <span class="dt">Bool</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ctrl_right ::</span> <span class="dt">Bool</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="ot">controller ::</span> <span class="dt">SF</span> () <span class="dt">Controller</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>controller <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>We can then write a little helper function to determine when a button has been pressed‚Äîtagging it with a particular value of our choice:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">onPress ::</span> (<span class="dt">Controller</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SF</span> () (<span class="dt">Event</span> a)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>onPress field a <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> (<span class="fu">const</span> a)) <span class="op">$</span> <span class="fu">fmap</span> field controller <span class="op">&gt;&gt;&gt;</span> edge</span></code></pre></div>
<p>Next, we can sum up an <code>onPress</code> for each direction on the controller, mapping them into direction vectors:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">arrowEvents ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">SF</span> () (<span class="dt">Event</span> (<span class="dt">V2</span> a))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>arrowEvents <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  (\u d l r <span class="ot">-&gt;</span> asum [u, d, l r])</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> onPress ctrl_up    (<span class="dt">V2</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_down  (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_left  (<span class="dt">V2</span> (<span class="op">-</span><span class="dv">1</span>) <span class="dv">0</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> onPress ctrl_right (<span class="dt">V2</span> <span class="dv">1</span>    <span class="dv">0</span>)</span></code></pre></div>
<p>Above, the use of <code>asum</code> allows us to combine these four events into one, meaning that if the player presses two directions at exactly the same moment, we will prefer <code>up</code> over <code>down</code>, and <code>down</code> over <code>left</code>, etc.</p>
<p>By <code>hold</code>ing onto the most recent arrow event, we can get the current direction our snake is facing:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">snakeDirection ::</span> <span class="dt">SF</span> () (<span class="dt">V2</span> <span class="dt">Float</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>snakeDirection <span class="ot">=</span> arrowEvents <span class="op">&gt;&gt;&gt;</span> hold (<span class="dt">V2</span> <span class="dv">0</span> <span class="dv">1</span>)</span></code></pre></div>
<p>which we can then integrate in order to have the snake move around:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">snakePosition ::</span> <span class="dt">SF</span> () (<span class="dt">V2</span> <span class="dt">Float</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>snakePosition <span class="ot">=</span> snakeDirection <span class="op">&gt;&gt;&gt;</span> integral</span></code></pre></div>
<p>Not too shabby at all! This particular snake will move at a rate of 1 unit per second, but we could make him faster by scaling up <code>snakeDirection</code> before taking its <code>integral</code>.</p>
<h2 id="wrapping-up"><a href="#wrapping-up" class="header-link">Wrapping Up<span class="header-link-emoji">üîó</span></a></h2>
<p>Hopefully I‚Äôve given you a taste of how FRP can radically simplify the implementation of real-time applications. Tomorrow we‚Äôll look into arrowized FRP, and get a sense of how to build bigger, more interesting programs.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction: Done!</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/certainty-by-construction/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/certainty-by-construction/index.html</guid>
      <pubDate>2023-10-30</pubDate>
      <content:encoded><![CDATA[
        <p>Happy days and happy news: it‚Äôs done.</p>
<center>
<a href="https://leanpub.com/certainty-by-construction"><img src="/images/cbc.png" alt="Certainty by Construction"></a>
</center>
<p>After a year of work, I‚Äôm <em>thrilled</em> to announce the completion my new book, <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>.</p>
<p>Certainty by Construction is a book on doing mathematics and software design in the proof assistant Agda, which is the language Haskell wants to be when it grows up. The book is part Agda primer, introduction to abstract algebra, and algorithm design manual, with a healthy dose of philosophy mixed in to help build intuition.</p>
<p>If you‚Äôre the sort of person who would like to learn more math (including all the proof burden), and see how to apply it to writing real software, I think you‚Äôd groove on this book. If it sounds up your alley, I‚Äôd highly encourage you to <a href="https://leanpub.com/certainty-by-construction">give it a read</a>.</p>
<p>I‚Äôm not much on social media these days, but if you are, I‚Äôd really appreciate a signal boost on this announcement! Thanks to everyone for their support and understanding over the last year. I love you all!</p>
<p><a href="https://leanpub.com/certainty-by-construction">Go cop Certainty by Construction!</a></p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 10</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report10/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report10/index.html</guid>
      <pubDate>2023-10-12</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I‚Äôm writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you‚Äôre excited about, please do let me know!</p>
<hr />
<p>Thanks for all of your kind words of support after my last report. That‚Äôs the sort of thing that really helps keep me motivated. So thank you!</p>
<p>BUT GOOD NEWS. HERE‚ÄôS SOMETHING ELSE THAT ALSO HELPS TO KEEP ME MOTIVATED.</p>
<p>I just wrapped up the last proof in the book!!!!</p>
<p>It‚Äôs taken me all week to put together these glorious 50 lines of Agda, but it makes for a damn fine finale for the book. So the game plan is now to delete that last chapter I‚Äôve got hanging around that‚Äôs kinda about matrices, rewrite the prose on isomorphisms, and then do one final polish pass where I add things like indices and definitions.</p>
<p>Grad school has been much busier than I was expecting it to be, but no matter! I will persevere. Being so close to the finish line is tantalizing and I expect I‚Äôll just spend the next few days powering through it all. This thing is definitely going to be finished by the end of the year.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 9</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report9/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report9/index.html</guid>
      <pubDate>2023-09-02</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I‚Äôm writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you‚Äôre excited about, please do let me know!</p>
<hr />
<p>It is now the wee hours of Sept 2, and it‚Äôs safe to say I did not make the deadline. The book is not yet finished come hell or high water. Damn. Here‚Äôs the state of the world:</p>
<ul>
<li>Everything up to page 203/296 has been aggressively edited, in terms of prose, code, general presentation, and overall topic order. There are still a few TODOs to write chapter summaries, but those aren‚Äôt the end of the world if they don‚Äôt happen.</li>
<li>It‚Äôs now possible to build semi-readable epubs. Needing to run everything through the Agda compiler makes build pipelines surprisingly hard, but I think this should only require a couple of hours to get it into a good place.</li>
<li>I have commissioned a contest of potential covers for the book; no results yet, but I expect to to have some things to look at by the end of this week.</li>
<li>Since my last update, I realized I had accidentally lost the chapter on ring solving when doing my big refactor. I‚Äôve since found it, but it‚Äôs no longer particularly motivated and is rather out of place, so I think it‚Äôs going to get cut. Kill your darlings and all that.</li>
</ul>
<p>All in all, I‚Äôm bummed I didn‚Äôt make the deadline, but the quality of the book is exponentially better, so I think it‚Äôs a worthwhile trade. I‚Äôve got three/four chapters left to edit (depending on if ring solving gets cut), and I need to write a closing chapter to make the end less jarring.</p>
<p>On a personal note, although the book is much longer in content than my other books, it‚Äôs packed much tighter and thus is going to be <em>physically</em> smaller when I get it printed. For some reason that is holding a lot of space in my head right now, and steering me away from cutting too much. I suppose I shouldn‚Äôt fret too much; there‚Äôs still an index and glossary I need to add which will probably add a bit of length. Also I know this doesn‚Äôt matter, but I care about it nevertheless.</p>
<p>So why didn‚Äôt I get this done on time? The reason seems to be just that it was too ambitious a goal. I definitely underestimated the amount of polish required here. This month I put 65 hours of honest-to-goodness <em>work</em> into the book, which if you measure in terms of the 2.9h average hours of work that an officer worker does in a day is more than a full time job. It‚Äôs very late and I don‚Äôt know if that makes sense but I think it might.</p>
<p>Anyway, here‚Äôs the plan going forwards‚ÄîI‚Äôve got some of this week to work on the book before getting married and starting grad school. The goal is to just keep on at this pace for as long as I possibly can until I die or real life gets in the way. It sucks and I‚Äôm exhausted and would like to be finished with this thing, but it‚Äôs not done with <em>me</em> yet. And so we go on.</p>
<p>But maybe I‚Äôll take tomorrow off because I need to sort out getting married, and I don‚Äôt think this kind of extreme focus is good for my mental health. It‚Äôs a bit of a balancing act though, because life is only going to get more busy after next week.</p>
<p>Sorry for the bleak trail off here. I should go to bed.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 8</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report8/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report8/index.html</guid>
      <pubDate>2023-08-23</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I‚Äôm writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you‚Äôre excited about, please do let me know!</p>
<hr />
<p>Eight days away from my deadline. How‚Äôs it going? Hectic.</p>
<p>I‚Äôve been in a flurry of editing for the last two weeks. As of right now, I‚Äôm currently editing page 138/252. At this rate, it‚Äôs not looking promising, but I did just buy a flat of Red Bull, so you never know.</p>
<p>Besides editing, what‚Äôs new? Lots of minor typesetting stuff, like which paragraphs should be indented. I also did a pass through all the Agda modules with their new, final names, in easy searchable format. Along with that, the end of each chapter now has an explicit export list, which subsequent chapters import (rather than getting it from the stdlib.) This means you can see at a glance whether a chapter has prerequisites you need to read first! Minor stuff, but Nintendo polish nevertheless.</p>
<p>I had to rewrite a good chunk of chapter 2, and a lot of the prose in chapter 3 is from a very early edition of the book, and doesn‚Äôt have the shine as the rest of it. So that‚Äôs getting reworked too. My hope is that the later chapters were written more recently, and therefore will require less elbow grease. It‚Äôs plausible, and would be greatly appreciated. But I fear that the setoids chapter needs a lot of work, and I‚Äôm just trying my best to ignore it. For now.</p>
<p>In other news, I‚Äôm now uploading nightly builds to <a href="https://leanpub.com/certainty-by-construction">Leanpub</a> in order to keep myself honest. There‚Äôs no indication of which half of the book has been edited and which hasn‚Äôt, but that seems like a good idea I should adopt for the next build. That way particularly dedicated readers could follow along and see just how quickly I can get material cleaned up. And it will prevent me from accidentally forgetting where I was and re-editing it all again. Which has happened several times, somehow.</p>
<p>Okay that‚Äôs enough of an update. Back to the grind. Love y‚Äôall.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 7</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report7/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report7/index.html</guid>
      <pubDate>2023-08-12</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I‚Äôm writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you‚Äôre excited about, please do let me know!</p>
<hr />
<p>Where has this dingus Sandy been?? Busy busy busy! I‚Äôm in the middle of planning a wedding (my own), as well as just finished being the best man at my friend‚Äôs wedding. Plus getting the tax man‚Äôs records all sorted out for him, and a bunch of other things that fell into the ‚Äúurgent‚Äù AND ‚Äúimportant‚Äù categories.</p>
<p>Yeesh. Enough excuses though. I‚Äôm back and haven‚Äôt given up on any of this!</p>
<p>These days I‚Äôm calling the book ‚Äúessentially done,‚Äù and all that is required is extensive editing. Which I‚Äôve been doing. Every day on the bus I‚Äôm reading my PDF copy and making notes in the margin. Then I get home and go through the notes and clean up the prose.</p>
<p>It‚Äôs slow going, but that‚Äôs the way of the world. The prose is getting dramatically tightened up, however. It‚Äôs kind of fun to go through, be aware of the point I‚Äôm trying to make, and realize that I haven‚Äôt actually made it. I‚Äôm not calling this ‚Äúrewriting,‚Äù but most paragraphs are changing dramatically.</p>
<p>Today I also sat down and hashed out a bunch of the technical pipeline issues I‚Äôve been putting off for a year. Like getting section references working. So now instead of saying ‚Äúas in <strong>sec:propeq?</strong>‚Äù, the prose now says ‚Äúas in section 3.2‚Äù. The annotations have always been there, but getting the build to actually put in the text has taken away several hours of my life.</p>
<p>More excitingly, I also managed to get inline code snippets properly highlighted‚Äîand, even better, <em>broken code</em> now also highlights. This is a resounding achievement, because the whole idea of literate Agda is that it must compile. And the compiler is what generates the syntax highlighting. It‚Äôs a terrifying marvel of engineering, but it does work.</p>
<p>So that‚Äôs all. I‚Äôm just going to push on this book thing until it‚Äôs done. Or until September 1. Whichever comes sooner. That‚Äôs a terrifying thought, so I guess I‚Äôd better get back to it.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Certainty by Construction Progress Report 6</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>https://reasonablypolymorphic.com/blog/cbc-report6/index.html</link>
      <guid>https://reasonablypolymorphic.com/blog/cbc-report6/index.html</guid>
      <pubDate>2023-07-14</pubDate>
      <content:encoded><![CDATA[
        <p>The following is a progress report for <a href="https://leanpub.com/certainty-by-construction">Certainty by Construction</a>, a new book I‚Äôm writing on learning and effectively wielding Agda. Writing a book is a tedious and demoralizing process, so if this is the sort of thing you‚Äôre excited about, please do let me know!</p>
<hr />
<p>Aaaand we‚Äôre back. Traveling was nice, but it‚Äôs nicer to be home and being productive and making things.</p>
<p>This week I did a lot of work on the isomorphisms chapter. First and foremost, I proved that everything I knew about cardinalities from the Curry-Howard isomorphism held true. That is, that sum types add the cardinalities of their constituent types, product types multiply them, and by far the hardest to prove, that functions act as exponentials.</p>
<p>Going through the work of that taught me that I haven‚Äôt really internalized everything I ought to have regarding setoids, since I originally framed the problem wrong and needed Reed to help sort me out. There is some material in this chapter about building the relevant setoids for all of the necessary types, which sucks and would be better to avoid. I‚Äôm unsure if it will get moved out to the setoid chapter, or if I‚Äôll just give a sketch in the final version, or maybe if it just gets left where it is.</p>
<p>For me, the motivating use case behind the algebra of types is to find different representations of things, ones with better computational properties. This turns out to be extremely easy to exploit in Haskell, but upon trying to write about it, I realized how much magic the Haskell runtime is doing in order to make that happen. It‚Äôs amazing that I‚Äôm still managing to trick myself into thinking I understand things, even after working on this book for nearly a year. But I suppose that‚Äôs the whole purpose!</p>
<p>So anyway, that section isn‚Äôt yet finished, but I think one more week will be enough to tie it together. And at that point, I‚Äôve written everything I intend to, and will spend the remainder of my project time on editing, rewriting, cleaning up, and tackling the weird typesetting problems that remain. The end is nigh!</p>
<hr />
<p>That‚Äôs all for today. If you‚Äôve already bought the book, you can get the updates for free on <a href="https://leanpub.com/certainty-by-construction">Leanpub</a>. If you haven‚Äôt, might I suggest doing so? Your early support and feedback helps inspire me and ensure the book is as good as it can possibly be.</p>
      ]]></content:encoded>
  </item>
</channel>
</rss>
